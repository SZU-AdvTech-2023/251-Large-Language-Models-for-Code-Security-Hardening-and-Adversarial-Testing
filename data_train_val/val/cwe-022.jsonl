{"func_name": "getKey", "func_src_before": "def getKey(client):\n\t\"\"\"Retrieves the specified key for the specified client\n\tReturns an error if the key doesn't exist, obviously.\n\t\"\"\"\n\tglobal SERVER_JWT_PRIVATE_KEY\n\tglobal BAD_REQUEST\n\n\tvalidateClient(client)\n\n\tclient_pub_key = loadClientRSAKey(client)\n\ttoken_data = decodeRequestToken(request.data, client_pub_key)\n\n\t# Keys may only have alpha-numeric names\n\ttry:\n\t\tif re.search('[^a-zA-Z0-9]', token_data['key']):\n\t\t\traise FoxlockError(BAD_REQUEST, 'Invalid key requested')\n\t\trequested_key = open('keys/%s/%s.key' % (client, token_data['key']), 'r').read()\n\texcept KeyError:\n\t\traise FoxlockError(BAD_REQUEST, \"JWT did not contain attribute 'key'\")\n\texcept IOError:\n\t\traise FoxlockError(BAD_REQUEST, \"Key '%s' not found\" % token_data['key'])\n\n\t# Key is returned in a JWT encrypted with the client's public key, so only they can decrypt it\n\tkeytoken = packJWT({'key': requested_key}, SERVER_JWT_PRIVATE_KEY, client_pub_key)\n\n\treturn keytoken", "func_src_after": "def getKey(client):\n\t\"\"\"Retrieves the specified key for the specified client\n\tReturns an error if the key doesn't exist, obviously.\n\t\"\"\"\n\tglobal SERVER_JWT_PRIVATE_KEY\n\tglobal BAD_REQUEST\n\n\tvalidateClient(client)\n\tclient_pub_key = loadClientRSAKey(client)\n\ttoken_data = decodeRequestToken(request.data, client_pub_key)\n\tvalidateKeyName(token_data['key'])\n\n\t# Keys may only have alpha-numeric names\n\ttry:\n\t\trequested_key = open('keys/%s/%s.key' % (client, token_data['key']), 'r').read()\n\texcept KeyError:\n\t\traise FoxlockError(BAD_REQUEST, \"JWT did not contain attribute 'key'\")\n\texcept IOError:\n\t\traise FoxlockError(BAD_REQUEST, \"Key '%s' not found\" % token_data['key'])\n\n\t# Key is returned in a JWT encrypted with the client's public key, so only they can decrypt it\n\tkeytoken = packJWT({'key': requested_key}, SERVER_JWT_PRIVATE_KEY, client_pub_key)\n\n\treturn keytoken", "line_changes": {"deleted": [{"line_no": 9, "char_start": 213, "char_end": 214, "line": "\n"}, {"line_no": 15, "char_start": 369, "char_end": 420, "line": "\t\tif re.search('[^a-zA-Z0-9]', token_data['key']):\n"}, {"line_no": 16, "char_start": 420, "char_end": 480, "line": "\t\t\traise FoxlockError(BAD_REQUEST, 'Invalid key requested')\n"}], "added": [{"line_no": 11, "char_start": 319, "char_end": 355, "line": "\tvalidateKeyName(token_data['key'])\n"}]}, "char_changes": {"deleted": [{"char_start": 213, "char_end": 214, "chars": "\n"}, {"char_start": 368, "char_end": 479, "chars": "\n\t\tif re.search('[^a-zA-Z0-9]', token_data['key']):\n\t\t\traise FoxlockError(BAD_REQUEST, 'Invalid key requested')"}], "added": [{"char_start": 318, "char_end": 354, "chars": "\n\tvalidateKeyName(token_data['key'])"}, {"char_start": 398, "char_end": 398, "chars": ""}]}, "commit_link": "github.com/Mimickal/FoxLock/commit/7c665e556987f4e2c1a75e143a1e80ae066ad833", "file_name": "impl.py", "vul_type": "cwe-022"}
{"func_name": "ImportEPUB::ExtractContainer", "func_src_before": "void ImportEPUB::ExtractContainer()\n{\n    int res = 0;\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());\n#endif\n\n    if (zfile == NULL) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot unzip EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                QDir dir(m_ExtractedFolderPath);\n                // Full file path in the temporary directory.\n                QString file_path = m_ExtractedFolderPath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n\t\t    // add it to the list of files found inside the zip\n\t\t    if (cp437_file_name.isEmpty()) {\n\t\t        m_ZipFilePaths << qfile_name;\n\t\t    } else {\n                        m_ZipFilePaths << cp437_file_name;\n\t\t    }\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = m_ExtractedFolderPath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot open EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    unzClose(zfile);\n}", "func_src_after": "void ImportEPUB::ExtractContainer()\n{\n    int res = 0;\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());\n#endif\n\n    if (zfile == NULL) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot unzip EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n\n\t        // for security reasons we need the file path to always be inside the \n                // target folder and not outside, so we will remove all relative upward \n                // paths segments \"..\" from the file path before prepending the target \n                // folder to create the final target path\n\t        qfile_name = qfile_name.replace(\"../\",\"\");\n                cp437_file_name = cp437_file_name.replace(\"../\",\"\");\n\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                QDir dir(m_ExtractedFolderPath);\n                // Full file path in the temporary directory.\n                QString file_path = m_ExtractedFolderPath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n\t\t    // add it to the list of files found inside the zip\n\t\t    if (cp437_file_name.isEmpty()) {\n\t\t        m_ZipFilePaths << qfile_name;\n\t\t    } else {\n                        m_ZipFilePaths << cp437_file_name;\n\t\t    }\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = m_ExtractedFolderPath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot open EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    unzClose(zfile);\n}", "line_changes": {"deleted": [], "added": [{"line_no": 38, "char_start": 1427, "char_end": 1428, "line": "\n"}, {"line_no": 43, "char_start": 1743, "char_end": 1795, "line": "\t        qfile_name = qfile_name.replace(\"../\",\"\");\n"}, {"line_no": 44, "char_start": 1795, "char_end": 1864, "line": "                cp437_file_name = cp437_file_name.replace(\"../\",\"\");\n"}, {"line_no": 45, "char_start": 1864, "char_end": 1865, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1427, "char_end": 1865, "chars": "\n\t        // for security reasons we need the file path to always be inside the \n                // target folder and not outside, so we will remove all relative upward \n                // paths segments \"..\" from the file path before prepending the target \n                // folder to create the final target path\n\t        qfile_name = qfile_name.replace(\"../\",\"\");\n                cp437_file_name = cp437_file_name.replace(\"../\",\"\");\n\n"}]}, "commit_link": "github.com/Sigil-Ebook/Sigil/commit/369eebe936e4a8c83cc54662a3412ce8bef189e4", "file_name": "src/Importers/ImportEPUB.cpp", "vul_type": "cwe-022"}
{"func_name": "GetMagickModulePath", "func_src_before": "static MagickBooleanType GetMagickModulePath(const char *filename,\n  MagickModuleType module_type,char *path,ExceptionInfo *exception)\n{\n  char\n    *module_path;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(path != (char *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) CopyMagickString(path,filename,MaxTextExtent);\n  module_path=(char *) NULL;\n  switch (module_type)\n  {\n    case MagickImageCoderModule:\n    default:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for coder module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_MODULE_PATH\");\n#if defined(MAGICKCORE_CODER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_CODER_PATH);\n#endif\n      break;\n    }\n    case MagickImageFilterModule:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for filter module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_FILTER_PATH\");\n#if defined(MAGICKCORE_FILTER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_FILTER_PATH);\n#endif\n      break;\n    }\n  }\n  if (module_path != (char *) NULL)\n    {\n      register char\n        *p,\n        *q;\n\n      for (p=module_path-1; p != (char *) NULL; )\n      {\n        (void) CopyMagickString(path,p+1,MaxTextExtent);\n        q=strchr(path,DirectoryListSeparator);\n        if (q != (char *) NULL)\n          *q='\\0';\n        q=path+strlen(path)-1;\n        if ((q >= path) && (*q != *DirectorySeparator))\n          (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);\n        (void) ConcatenateMagickString(path,filename,MaxTextExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            module_path=DestroyString(module_path);\n            return(MagickTrue);\n          }\n        p=strchr(p+1,DirectoryListSeparator);\n      }\n      module_path=DestroyString(module_path);\n    }\n#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n  else\n#if defined(MAGICKCORE_CODER_PATH)\n    {\n      const char\n        *directory;\n\n      /*\n        Search hard coded paths.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=MAGICKCORE_CODER_PATH;\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=MAGICKCORE_FILTER_PATH;\n          break;\n        }\n      }\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s\",directory,filename);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n    {\n      const char\n        *registery_key;\n\n      unsigned char\n        *key_value;\n\n      /*\n        Locate path via registry key.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          registery_key=\"CoderModulesPath\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          registery_key=\"FilterModulesPath\";\n          break;\n        }\n      }\n      key_value=NTRegistryKeyLookup(registery_key);\n      if (key_value == (unsigned char *) NULL)\n        {\n          ThrowMagickException(exception,GetMagickModule(),ConfigureError,\n            \"RegistryKeyLookupFailed\",\"`%s'\",registery_key);\n          return(MagickFalse);\n        }\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",(char *) key_value,\n        DirectorySeparator,filename);\n      key_value=(unsigned char *) RelinquishMagickMemory(key_value);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#endif\n#endif\n#if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT)\n# error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined\n#endif\n#else\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"MAGICK_HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search MAGICK_HOME.\n        */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",home,\n          DirectorySeparator,filename);\n#else\n        const char\n          *directory;\n\n        switch (module_type)\n        {\n          case MagickImageCoderModule:\n          default:\n          {\n            directory=MAGICKCORE_CODER_RELATIVE_PATH;\n            break;\n          }\n          case MagickImageFilterModule:\n          {\n            directory=MAGICKCORE_FILTER_RELATIVE_PATH;\n            break;\n          }\n        }\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s/lib/%s/%s\",home,\n          directory,filename);\n#endif\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  if (*GetClientPath() != '\\0')\n    {\n      /*\n        Search based on executable directory.\n      */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",GetClientPath(),\n        DirectorySeparator,filename);\n#else\n      char\n        prefix[MaxTextExtent];\n\n      const char\n        *directory;\n\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=\"coders\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=\"filters\";\n          break;\n        }\n      }\n      (void) CopyMagickString(prefix,GetClientPath(),MaxTextExtent);\n      ChopPathComponents(prefix,1);\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s/lib/%s/%s/%s\",prefix,\n        MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename);\n#endif\n      if (IsPathAccessible(path) != MagickFalse)\n        return(MagickTrue);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    /*\n      Search module path.\n    */\n    if ((NTGetModulePath(\"CORE_RL_magick_.dll\",path) != MagickFalse) ||\n        (NTGetModulePath(\"CORE_DB_magick_.dll\",path) != MagickFalse) ||\n        (NTGetModulePath(\"Magick.dll\",path) != MagickFalse))\n      {\n        (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);\n        (void) ConcatenateMagickString(path,filename,MaxTextExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n#endif\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"XDG_CONFIG_HOME\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"LOCALAPPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"APPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"USERPROFILE\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $XDG_CONFIG_HOME/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%sImageMagick%s%s\",\n          home,DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n    home=GetEnvironmentValue(\"HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $HOME/.config/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\n          \"%s%s.config%sImageMagick%s%s\",home,DirectorySeparator,\n          DirectorySeparator,DirectorySeparator,filename);\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            home=DestroyString(home);\n            return(MagickTrue);\n          }\n        /*\n          Search $HOME/.magick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%s.magick%s%s\",home,\n          DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  /*\n    Search current directory.\n  */\n  if (IsPathAccessible(path) != MagickFalse)\n    return(MagickTrue);\n  if (exception->severity < ConfigureError)\n    ThrowFileException(exception,ConfigureWarning,\"UnableToOpenModuleFile\",\n      path);\n#endif\n  return(MagickFalse);\n}", "func_src_after": "static MagickBooleanType GetMagickModulePath(const char *filename,\n  MagickModuleType module_type,char *path,ExceptionInfo *exception)\n{\n  char\n    *module_path;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(path != (char *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) CopyMagickString(path,filename,MaxTextExtent);\n#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n  if (strstr(path,\"../\") != (char *) NULL)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",path);\n      return(MagickFalse);\n    }\n#endif\n  module_path=(char *) NULL;\n  switch (module_type)\n  {\n    case MagickImageCoderModule:\n    default:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for coder module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_MODULE_PATH\");\n#if defined(MAGICKCORE_CODER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_CODER_PATH);\n#endif\n      break;\n    }\n    case MagickImageFilterModule:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for filter module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_FILTER_PATH\");\n#if defined(MAGICKCORE_FILTER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_FILTER_PATH);\n#endif\n      break;\n    }\n  }\n  if (module_path != (char *) NULL)\n    {\n      register char\n        *p,\n        *q;\n\n      for (p=module_path-1; p != (char *) NULL; )\n      {\n        (void) CopyMagickString(path,p+1,MaxTextExtent);\n        q=strchr(path,DirectoryListSeparator);\n        if (q != (char *) NULL)\n          *q='\\0';\n        q=path+strlen(path)-1;\n        if ((q >= path) && (*q != *DirectorySeparator))\n          (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);\n        (void) ConcatenateMagickString(path,filename,MaxTextExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            module_path=DestroyString(module_path);\n            return(MagickTrue);\n          }\n        p=strchr(p+1,DirectoryListSeparator);\n      }\n      module_path=DestroyString(module_path);\n    }\n#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n  else\n#if defined(MAGICKCORE_CODER_PATH)\n    {\n      const char\n        *directory;\n\n      /*\n        Search hard coded paths.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=MAGICKCORE_CODER_PATH;\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=MAGICKCORE_FILTER_PATH;\n          break;\n        }\n      }\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s\",directory,filename);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n    {\n      const char\n        *registery_key;\n\n      unsigned char\n        *key_value;\n\n      /*\n        Locate path via registry key.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          registery_key=\"CoderModulesPath\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          registery_key=\"FilterModulesPath\";\n          break;\n        }\n      }\n      key_value=NTRegistryKeyLookup(registery_key);\n      if (key_value == (unsigned char *) NULL)\n        {\n          ThrowMagickException(exception,GetMagickModule(),ConfigureError,\n            \"RegistryKeyLookupFailed\",\"`%s'\",registery_key);\n          return(MagickFalse);\n        }\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",(char *) key_value,\n        DirectorySeparator,filename);\n      key_value=(unsigned char *) RelinquishMagickMemory(key_value);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#endif\n#endif\n#if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT)\n# error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined\n#endif\n#else\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"MAGICK_HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search MAGICK_HOME.\n        */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",home,\n          DirectorySeparator,filename);\n#else\n        const char\n          *directory;\n\n        switch (module_type)\n        {\n          case MagickImageCoderModule:\n          default:\n          {\n            directory=MAGICKCORE_CODER_RELATIVE_PATH;\n            break;\n          }\n          case MagickImageFilterModule:\n          {\n            directory=MAGICKCORE_FILTER_RELATIVE_PATH;\n            break;\n          }\n        }\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s/lib/%s/%s\",home,\n          directory,filename);\n#endif\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  if (*GetClientPath() != '\\0')\n    {\n      /*\n        Search based on executable directory.\n      */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",GetClientPath(),\n        DirectorySeparator,filename);\n#else\n      char\n        prefix[MaxTextExtent];\n\n      const char\n        *directory;\n\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=\"coders\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=\"filters\";\n          break;\n        }\n      }\n      (void) CopyMagickString(prefix,GetClientPath(),MaxTextExtent);\n      ChopPathComponents(prefix,1);\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s/lib/%s/%s/%s\",prefix,\n        MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename);\n#endif\n      if (IsPathAccessible(path) != MagickFalse)\n        return(MagickTrue);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    /*\n      Search module path.\n    */\n    if ((NTGetModulePath(\"CORE_RL_magick_.dll\",path) != MagickFalse) ||\n        (NTGetModulePath(\"CORE_DB_magick_.dll\",path) != MagickFalse) ||\n        (NTGetModulePath(\"Magick.dll\",path) != MagickFalse))\n      {\n        (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);\n        (void) ConcatenateMagickString(path,filename,MaxTextExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n#endif\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"XDG_CONFIG_HOME\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"LOCALAPPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"APPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"USERPROFILE\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $XDG_CONFIG_HOME/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%sImageMagick%s%s\",\n          home,DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n    home=GetEnvironmentValue(\"HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $HOME/.config/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\n          \"%s%s.config%sImageMagick%s%s\",home,DirectorySeparator,\n          DirectorySeparator,DirectorySeparator,filename);\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            home=DestroyString(home);\n            return(MagickTrue);\n          }\n        /*\n          Search $HOME/.magick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%s.magick%s%s\",home,\n          DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  /*\n    Search current directory.\n  */\n  if (IsPathAccessible(path) != MagickFalse)\n    return(MagickTrue);\n  if (exception->severity < ConfigureError)\n    ThrowFileException(exception,ConfigureWarning,\"UnableToOpenModuleFile\",\n      path);\n#endif\n  return(MagickFalse);\n}", "line_changes": {"deleted": [], "added": [{"line_no": 13, "char_start": 453, "char_end": 496, "line": "  if (strstr(path,\"../\") != (char *) NULL)\n"}, {"line_no": 14, "char_start": 496, "char_end": 502, "line": "    {\n"}, {"line_no": 15, "char_start": 502, "char_end": 521, "line": "      errno=EPERM;\n"}, {"line_no": 16, "char_start": 521, "char_end": 596, "line": "      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n"}, {"line_no": 17, "char_start": 596, "char_end": 634, "line": "        \"NotAuthorized\",\"`%s'\",path);\n"}, {"line_no": 18, "char_start": 634, "char_end": 661, "line": "      return(MagickFalse);\n"}, {"line_no": 19, "char_start": 661, "char_end": 667, "line": "    }\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 411, "char_end": 674, "chars": "#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n  if (strstr(path,\"../\") != (char *) NULL)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",path);\n      return(MagickFalse);\n    }\n#endif\n"}]}, "commit_link": "github.com/ImageMagick/ImageMagick/commit/fc6080f1321fd21e86ef916195cc110b05d9effb", "file_name": "magick/module.c", "vul_type": "cwe-022"}
{"func_name": "estimate_size", "func_src_before": "    @staticmethod\n    def estimate_size(task_id, taken_dirs, taken_files):\n        report = AnalysisController.get_report(task_id)\n        report = report[\"analysis\"]\n        path = report[\"info\"][\"analysis_path\"]\n\n        size_total = 0\n\n        for directory in taken_dirs:\n            destination = \"%s/%s\" % (path, directory)\n            if os.path.isdir(destination):\n                size_total += get_directory_size(destination)\n\n        for filename in taken_files:\n            destination = \"%s/%s\" % (path, filename)\n            if os.path.isfile(destination):\n                size_total += os.path.getsize(destination)\n\n        # estimate file size after zipping; 60% compression rate typically\n        size_estimated = size_total / 6.5\n\n        return {\n            \"size\": int(size_estimated),\n            \"size_human\": filesizeformat(size_estimated)\n        }", "func_src_after": "    @staticmethod\n    def estimate_size(task_id, taken_dirs, taken_files):\n        report = AnalysisController.get_report(task_id)\n        report = report[\"analysis\"]\n        path = report[\"info\"][\"analysis_path\"]\n\n        size_total = 0\n\n        for directory in taken_dirs:\n            destination = \"%s/%s\" % (path, os.path.basename(directory))\n            if os.path.isdir(destination):\n                size_total += get_directory_size(destination)\n\n        for filename in taken_files:\n            destination = \"%s/%s\" % (path, os.path.basename(filename))\n            if os.path.isfile(destination):\n                size_total += os.path.getsize(destination)\n\n        # estimate file size after zipping; 60% compression rate typically\n        size_estimated = size_total / 6.5\n\n        return {\n            \"size\": int(size_estimated),\n            \"size_human\": filesizeformat(size_estimated)\n        }", "line_changes": {"deleted": [{"line_no": 10, "char_start": 276, "char_end": 330, "line": "            destination = \"%s/%s\" % (path, directory)\n"}, {"line_no": 15, "char_start": 473, "char_end": 526, "line": "            destination = \"%s/%s\" % (path, filename)\n"}], "added": [{"line_no": 10, "char_start": 276, "char_end": 348, "line": "            destination = \"%s/%s\" % (path, os.path.basename(directory))\n"}, {"line_no": 15, "char_start": 491, "char_end": 562, "line": "            destination = \"%s/%s\" % (path, os.path.basename(filename))\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 319, "char_end": 336, "chars": "os.path.basename("}, {"char_start": 345, "char_end": 346, "chars": ")"}, {"char_start": 534, "char_end": 551, "chars": "os.path.basename("}, {"char_start": 559, "char_end": 560, "chars": ")"}]}, "commit_link": "github.com/cuckoosandbox/cuckoo/commit/b90267fe4e5ee266ec3d4310a7b5c92c805b7ea3", "file_name": "cuckoo/web/controllers/analysis/export/export.py", "vul_type": "cwe-022"}
{"func_name": "span", "func_src_before": "    def span(self, key):\n        path = os.path.join(self.namespace, key)\n        try:\n            self.etcd.write(path, None, dir=True, prevExist=False)\n        except etcd.EtcdAlreadyExist as err:\n            raise CSStoreExists(str(err))\n        except etcd.EtcdException as err:\n            log_error(\"Error storing key %s: [%r]\" % (key, repr(err)))\n            raise CSStoreError('Error occurred while trying to store key')", "func_src_after": "    def span(self, key):\n        path = self._absolute_key(key)\n        try:\n            self.etcd.write(path, None, dir=True, prevExist=False)\n        except etcd.EtcdAlreadyExist as err:\n            raise CSStoreExists(str(err))\n        except etcd.EtcdException as err:\n            log_error(\"Error storing key %s: [%r]\" % (key, repr(err)))\n            raise CSStoreError('Error occurred while trying to store key')", "line_changes": {"deleted": [{"line_no": 2, "char_start": 25, "char_end": 74, "line": "        path = os.path.join(self.namespace, key)\n"}], "added": [{"line_no": 2, "char_start": 25, "char_end": 64, "line": "        path = self._absolute_key(key)\n"}]}, "char_changes": {"deleted": [{"char_start": 40, "char_end": 53, "chars": "os.path.join("}, {"char_start": 58, "char_end": 59, "chars": "n"}, {"char_start": 60, "char_end": 62, "chars": "me"}, {"char_start": 63, "char_end": 66, "chars": "pac"}, {"char_start": 67, "char_end": 69, "chars": ", "}], "added": [{"char_start": 45, "char_end": 46, "chars": "_"}, {"char_start": 47, "char_end": 53, "chars": "bsolut"}, {"char_start": 54, "char_end": 56, "chars": "_k"}, {"char_start": 57, "char_end": 59, "chars": "y("}]}, "commit_link": "github.com/latchset/custodia/commit/785fc87f38b4811bc4ce43a0a9b2267ee7d500b4", "file_name": "custodia/store/etcdstore.py", "vul_type": "cwe-022"}
{"func_name": "_get_settings", "func_src_before": "def _get_settings(view):\n    return {\n        'linters': get_settings(view, 'anaconda_go_linters', []),\n        'lint_test': get_settings(\n            view, 'anaconda_go_lint_test', False),\n        'exclude_regexps': get_settings(\n            view, 'anaconda_go_exclude_regexps', []),\n        'max_line_length': get_settings(\n            view, 'anaconda_go_max_line_length', 120),\n        'gocyclo_threshold': get_settings(\n            view, 'anaconda_go_gocyclo_threshold', 10),\n        'golint_min_confidence': get_settings(\n            view, 'anaconda_go_golint_min_confidence', 0.80),\n        'goconst_min_occurrences': get_settings(\n            view, 'anaconda_go_goconst_min_occurrences', 3),\n        'min_const_length': get_settings(\n            view, 'anaconda_go_min_const_length', 3),\n        'dupl_threshold': get_settings(\n            view, 'anaconda_go_dupl_threshold', 50),\n        'path': get_working_directory(view)\n    }", "func_src_after": "def _get_settings(view):\n    return {\n        'linters': get_settings(view, 'anaconda_go_linters', []),\n        'lint_test': get_settings(\n            view, 'anaconda_go_lint_test', False),\n        'exclude_regexps': get_settings(\n            view, 'anaconda_go_exclude_regexps', []),\n        'max_line_length': get_settings(\n            view, 'anaconda_go_max_line_length', 120),\n        'gocyclo_threshold': get_settings(\n            view, 'anaconda_go_gocyclo_threshold', 10),\n        'golint_min_confidence': get_settings(\n            view, 'anaconda_go_golint_min_confidence', 0.80),\n        'goconst_min_occurrences': get_settings(\n            view, 'anaconda_go_goconst_min_occurrences', 3),\n        'min_const_length': get_settings(\n            view, 'anaconda_go_min_const_length', 3),\n        'dupl_threshold': get_settings(\n            view, 'anaconda_go_dupl_threshold', 50),\n        'path': os.path.dirname(view.file_name())\n    }", "line_changes": {"deleted": [{"line_no": 20, "char_start": 888, "char_end": 932, "line": "        'path': get_working_directory(view)\n"}], "added": [{"line_no": 20, "char_start": 888, "char_end": 938, "line": "        'path': os.path.dirname(view.file_name())\n"}]}, "char_changes": {"deleted": [{"char_start": 904, "char_end": 906, "chars": "ge"}, {"char_start": 907, "char_end": 916, "chars": "_working_"}, {"char_start": 920, "char_end": 925, "chars": "ctory"}], "added": [{"char_start": 905, "char_end": 912, "chars": "s.path."}, {"char_start": 915, "char_end": 918, "chars": "nam"}, {"char_start": 924, "char_end": 936, "chars": ".file_name()"}]}, "commit_link": "github.com/DamnWidget/anaconda_go/commit/d3db90bb8853d832927818699591b91f56f6413c", "file_name": "lib/_sublime.py", "vul_type": "cwe-022"}
