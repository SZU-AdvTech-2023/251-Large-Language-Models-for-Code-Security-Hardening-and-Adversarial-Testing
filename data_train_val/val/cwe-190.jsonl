{"func_name": "opj_get_encoding_parameters", "func_src_before": "static void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32  * p_tx1,\n                                        OPJ_INT32  * p_ty0,\n                                        OPJ_INT32  * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res)\n{\n    /* loop */\n    OPJ_UINT32  compno, resno;\n    /* pointers */\n    const opj_tcp_t *l_tcp = 00;\n    const opj_tccp_t * l_tccp = 00;\n    const opj_image_comp_t * l_img_comp = 00;\n\n    /* position in x and y of tile */\n    OPJ_UINT32 p, q;\n\n    /* preconditions */\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(p_tileno < p_cp->tw * p_cp->th);\n\n    /* initializations */\n    l_tcp = &p_cp->tcps [p_tileno];\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n\n    /* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */\n    p = p_tileno % p_cp->tw;\n    q = p_tileno / p_cp->tw;\n\n    /* find extent of tile */\n    *p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx),\n                         (OPJ_INT32)p_image->x0);\n    *p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx),\n                         (OPJ_INT32)p_image->x1);\n    *p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy),\n                         (OPJ_INT32)p_image->y0);\n    *p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy),\n                         (OPJ_INT32)p_image->y1);\n\n    /* max precision is 0 (can only grow) */\n    *p_max_prec = 0;\n    *p_max_res = 0;\n\n    /* take the largest value for dx_min and dy_min */\n    *p_dx_min = 0x7fffffff;\n    *p_dy_min  = 0x7fffffff;\n\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        /* arithmetic variables to calculate */\n        OPJ_UINT32 l_level_no;\n        OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n        OPJ_INT32 l_px0, l_py0, l_px1, py1;\n        OPJ_UINT32 l_pdx, l_pdy;\n        OPJ_UINT32 l_pw, l_ph;\n        OPJ_UINT32 l_product;\n        OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n        l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n        l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n        l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n        l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n        if (l_tccp->numresolutions > *p_max_res) {\n            *p_max_res = l_tccp->numresolutions;\n        }\n\n        /* use custom size for precincts */\n        for (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n            OPJ_UINT32 l_dx, l_dy;\n\n            /* precinct width and height */\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n\n            l_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));\n            l_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));\n\n            /* take the minimum size for dx for each comp and resolution */\n            *p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n            *p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n            /* various calculations of extents */\n            l_level_no = l_tccp->numresolutions - 1 - resno;\n\n            l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n            l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n            l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n            l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\n            l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\n            py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\n            l_pw = (l_rx0 == l_rx1) ? 0 : (OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n            l_ph = (l_ry0 == l_ry1) ? 0 : (OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\n            l_product = l_pw * l_ph;\n\n            /* update precision */\n            if (l_product > *p_max_prec) {\n                *p_max_prec = l_product;\n            }\n        }\n        ++l_img_comp;\n        ++l_tccp;\n    }\n}", "func_src_after": "static void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32  * p_tx1,\n                                        OPJ_INT32  * p_ty0,\n                                        OPJ_INT32  * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res)\n{\n    /* loop */\n    OPJ_UINT32  compno, resno;\n    /* pointers */\n    const opj_tcp_t *l_tcp = 00;\n    const opj_tccp_t * l_tccp = 00;\n    const opj_image_comp_t * l_img_comp = 00;\n\n    /* position in x and y of tile */\n    OPJ_UINT32 p, q;\n\n    /* non-corrected (in regard to image offset) tile offset */\n    OPJ_UINT32 l_tx0, l_ty0;\n\n    /* preconditions */\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(p_tileno < p_cp->tw * p_cp->th);\n\n    /* initializations */\n    l_tcp = &p_cp->tcps [p_tileno];\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n\n    /* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */\n    p = p_tileno % p_cp->tw;\n    q = p_tileno / p_cp->tw;\n\n    /* find extent of tile */\n    l_tx0 = p_cp->tx0 + p *\n            p_cp->tdx; /* can't be greater than p_image->x1 so won't overflow */\n    *p_tx0 = (OPJ_INT32)opj_uint_max(l_tx0, p_image->x0);\n    *p_tx1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, p_cp->tdx), p_image->x1);\n    l_ty0 = p_cp->ty0 + q *\n            p_cp->tdy; /* can't be greater than p_image->y1 so won't overflow */\n    *p_ty0 = (OPJ_INT32)opj_uint_max(l_ty0, p_image->y0);\n    *p_ty1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, p_cp->tdy), p_image->y1);\n\n    /* max precision is 0 (can only grow) */\n    *p_max_prec = 0;\n    *p_max_res = 0;\n\n    /* take the largest value for dx_min and dy_min */\n    *p_dx_min = 0x7fffffff;\n    *p_dy_min  = 0x7fffffff;\n\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        /* arithmetic variables to calculate */\n        OPJ_UINT32 l_level_no;\n        OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n        OPJ_INT32 l_px0, l_py0, l_px1, py1;\n        OPJ_UINT32 l_pdx, l_pdy;\n        OPJ_UINT32 l_pw, l_ph;\n        OPJ_UINT32 l_product;\n        OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n        l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n        l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n        l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n        l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n        if (l_tccp->numresolutions > *p_max_res) {\n            *p_max_res = l_tccp->numresolutions;\n        }\n\n        /* use custom size for precincts */\n        for (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n            OPJ_UINT32 l_dx, l_dy;\n\n            /* precinct width and height */\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n\n            l_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));\n            l_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));\n\n            /* take the minimum size for dx for each comp and resolution */\n            *p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n            *p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n            /* various calculations of extents */\n            l_level_no = l_tccp->numresolutions - 1 - resno;\n\n            l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n            l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n            l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n            l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\n            l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\n            py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\n            l_pw = (l_rx0 == l_rx1) ? 0 : (OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n            l_ph = (l_ry0 == l_ry1) ? 0 : (OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\n            l_product = l_pw * l_ph;\n\n            /* update precision */\n            if (l_product > *p_max_prec) {\n                *p_max_prec = l_product;\n            }\n        }\n        ++l_img_comp;\n        ++l_tccp;\n    }\n}", "line_changes": {"deleted": [{"line_no": 38, "char_start": 1329, "char_end": 1394, "line": "    *p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx),\n"}, {"line_no": 39, "char_start": 1394, "char_end": 1444, "line": "                         (OPJ_INT32)p_image->x0);\n"}, {"line_no": 40, "char_start": 1444, "char_end": 1515, "line": "    *p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx),\n"}, {"line_no": 41, "char_start": 1515, "char_end": 1565, "line": "                         (OPJ_INT32)p_image->x1);\n"}, {"line_no": 42, "char_start": 1565, "char_end": 1630, "line": "    *p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy),\n"}, {"line_no": 43, "char_start": 1630, "char_end": 1680, "line": "                         (OPJ_INT32)p_image->y0);\n"}, {"line_no": 44, "char_start": 1680, "char_end": 1751, "line": "    *p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy),\n"}, {"line_no": 45, "char_start": 1751, "char_end": 1801, "line": "                         (OPJ_INT32)p_image->y1);\n"}], "added": [{"line_no": 23, "char_start": 928, "char_end": 992, "line": "    /* non-corrected (in regard to image offset) tile offset */\n"}, {"line_no": 24, "char_start": 992, "char_end": 1021, "line": "    OPJ_UINT32 l_tx0, l_ty0;\n"}, {"line_no": 25, "char_start": 1021, "char_end": 1022, "line": "\n"}, {"line_no": 41, "char_start": 1423, "char_end": 1451, "line": "    l_tx0 = p_cp->tx0 + p *\n"}, {"line_no": 42, "char_start": 1451, "char_end": 1532, "line": "            p_cp->tdx; /* can't be greater than p_image->x1 so won't overflow */\n"}, {"line_no": 43, "char_start": 1532, "char_end": 1590, "line": "    *p_tx0 = (OPJ_INT32)opj_uint_max(l_tx0, p_image->x0);\n"}, {"line_no": 44, "char_start": 1590, "char_end": 1674, "line": "    *p_tx1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, p_cp->tdx), p_image->x1);\n"}, {"line_no": 45, "char_start": 1674, "char_end": 1702, "line": "    l_ty0 = p_cp->ty0 + q *\n"}, {"line_no": 46, "char_start": 1702, "char_end": 1783, "line": "            p_cp->tdy; /* can't be greater than p_image->y1 so won't overflow */\n"}, {"line_no": 47, "char_start": 1783, "char_end": 1841, "line": "    *p_ty0 = (OPJ_INT32)opj_uint_max(l_ty0, p_image->y0);\n"}, {"line_no": 48, "char_start": 1841, "char_end": 1925, "line": "    *p_ty1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, p_cp->tdy), p_image->y1);\n"}]}, "char_changes": {"deleted": [{"char_start": 952, "char_end": 952, "chars": ""}, {"char_start": 1333, "char_end": 1335, "chars": "*p"}, {"char_start": 1342, "char_end": 1366, "chars": "opj_int_max((OPJ_INT32)("}, {"char_start": 1391, "char_end": 1394, "chars": "),\n"}, {"char_start": 1400, "char_end": 1409, "chars": "         "}, {"char_start": 1469, "char_end": 1473, "chars": "(OPJ"}, {"char_start": 1474, "char_end": 1480, "chars": "INT32)"}, {"char_start": 1481, "char_end": 1482, "chars": "p"}, {"char_start": 1483, "char_end": 1487, "chars": "cp->"}, {"char_start": 1490, "char_end": 1502, "chars": " + (p + 1) *"}, {"char_start": 1514, "char_end": 1523, "chars": "\n        "}, {"char_start": 1524, "char_end": 1551, "chars": "                (OPJ_INT32)"}, {"char_start": 1569, "char_end": 1571, "chars": "*p"}, {"char_start": 1578, "char_end": 1602, "chars": "opj_int_max((OPJ_INT32)("}, {"char_start": 1627, "char_end": 1630, "chars": "),\n"}, {"char_start": 1636, "char_end": 1645, "chars": "         "}, {"char_start": 1705, "char_end": 1709, "chars": "(OPJ"}, {"char_start": 1710, "char_end": 1716, "chars": "INT32)"}, {"char_start": 1717, "char_end": 1718, "chars": "p"}, {"char_start": 1719, "char_end": 1723, "chars": "cp->"}, {"char_start": 1726, "char_end": 1738, "chars": " + (q + 1) *"}, {"char_start": 1750, "char_end": 1759, "chars": "\n        "}, {"char_start": 1760, "char_end": 1787, "chars": "                (OPJ_INT32)"}], "added": [{"char_start": 935, "char_end": 1029, "chars": "non-corrected (in regard to image offset) tile offset */\n    OPJ_UINT32 l_tx0, l_ty0;\n\n    /* "}, {"char_start": 1427, "char_end": 1428, "chars": "l"}, {"char_start": 1463, "char_end": 1473, "chars": "p_cp->tdx;"}, {"char_start": 1474, "char_end": 1476, "chars": "/*"}, {"char_start": 1477, "char_end": 1482, "chars": "can't"}, {"char_start": 1483, "char_end": 1485, "chars": "be"}, {"char_start": 1486, "char_end": 1493, "chars": "greater"}, {"char_start": 1494, "char_end": 1498, "chars": "than"}, {"char_start": 1499, "char_end": 1510, "chars": "p_image->x1"}, {"char_start": 1511, "char_end": 1513, "chars": "so"}, {"char_start": 1514, "char_end": 1519, "chars": "won't"}, {"char_start": 1520, "char_end": 1528, "chars": "overflow"}, {"char_start": 1529, "char_end": 1532, "chars": "*/\n"}, {"char_start": 1535, "char_end": 1545, "chars": " *p_tx0 = "}, {"char_start": 1556, "char_end": 1576, "chars": "opj_uint_max(l_tx0, "}, {"char_start": 1603, "char_end": 1614, "chars": "(OPJ_INT32)"}, {"char_start": 1618, "char_end": 1619, "chars": "u"}, {"char_start": 1627, "char_end": 1630, "chars": "opj"}, {"char_start": 1631, "char_end": 1640, "chars": "uint_adds"}, {"char_start": 1641, "char_end": 1642, "chars": "l"}, {"char_start": 1646, "char_end": 1647, "chars": ","}, {"char_start": 1678, "char_end": 1679, "chars": "l"}, {"char_start": 1714, "char_end": 1724, "chars": "p_cp->tdy;"}, {"char_start": 1725, "char_end": 1727, "chars": "/*"}, {"char_start": 1728, "char_end": 1733, "chars": "can't"}, {"char_start": 1734, "char_end": 1736, "chars": "be"}, {"char_start": 1737, "char_end": 1744, "chars": "greater"}, {"char_start": 1745, "char_end": 1749, "chars": "than"}, {"char_start": 1750, "char_end": 1761, "chars": "p_image->y1"}, {"char_start": 1762, "char_end": 1764, "chars": "so"}, {"char_start": 1765, "char_end": 1770, "chars": "won't"}, {"char_start": 1771, "char_end": 1779, "chars": "overflow"}, {"char_start": 1780, "char_end": 1783, "chars": "*/\n"}, {"char_start": 1786, "char_end": 1796, "chars": " *p_ty0 = "}, {"char_start": 1807, "char_end": 1827, "chars": "opj_uint_max(l_ty0, "}, {"char_start": 1854, "char_end": 1865, "chars": "(OPJ_INT32)"}, {"char_start": 1869, "char_end": 1870, "chars": "u"}, {"char_start": 1878, "char_end": 1881, "chars": "opj"}, {"char_start": 1882, "char_end": 1891, "chars": "uint_adds"}, {"char_start": 1892, "char_end": 1893, "chars": "l"}, {"char_start": 1897, "char_end": 1898, "chars": ","}]}, "commit_link": "github.com/uclouvain/openjpeg/commit/c58df149900df862806d0e892859b41115875845", "file_name": "src/lib/openjp2/pi.c", "vul_type": "cwe-190"}
{"func_name": "rfbScaledScreenUpdateRect", "func_src_before": "void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0)\n{\n    int x,y,w,v,z;\n    int x1, y1, w1, h1;\n    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n    unsigned char *srcptr, *dstptr;\n\n    /* Nothing to do!!! */\n    if (screen==ptr) return;\n\n    x1 = x0;\n    y1 = y0;\n    w1 = w0;\n    h1 = h0;\n\n    rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, \"rfbScaledScreenUpdateRect\");\n    x0 = ScaleX(ptr, screen, x1);\n    y0 = ScaleY(ptr, screen, y1);\n    w0 = ScaleX(ptr, screen, w1);\n    h0 = ScaleY(ptr, screen, h1);\n\n    bitsPerPixel = screen->bitsPerPixel;\n    bytesPerPixel = bitsPerPixel / 8;\n    bytesPerLine = w1 * bytesPerPixel;\n    srcptr = (unsigned char *)(screen->frameBuffer +\n     (y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));\n    dstptr = (unsigned char *)(ptr->frameBuffer +\n     ( y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));\n    /* The area of the source framebuffer for each destination pixel */\n    areaX = ScaleX(ptr,screen,1);\n    areaY = ScaleY(ptr,screen,1);\n    area2 = areaX*areaY;\n\n\n    /* Ensure that we do not go out of bounds */\n    if ((x1+w1) > (ptr->width))\n    {\n      if (x1==0) w1=ptr->width; else x1 = ptr->width - w1;\n    }\n    if ((y1+h1) > (ptr->height))\n    {\n      if (y1==0) h1=ptr->height; else y1 = ptr->height - h1;\n    }\n    /*\n     * rfbLog(\"rfbScaledScreenUpdateRect(%dXx%dY-%dWx%dH  ->  %dXx%dY-%dWx%dH <%dx%d>) {%dWx%dH -> %dWx%dH} 0x%p\\n\",\n     *    x0, y0, w0, h0, x1, y1, w1, h1, areaX, areaY,\n     *    screen->width, screen->height, ptr->width, ptr->height, ptr->frameBuffer);\n     */\n\n    if (screen->serverFormat.trueColour) { /* Blend neighbouring pixels together */\n      unsigned char *srcptr2;\n      unsigned long pixel_value, red, green, blue;\n      unsigned int redShift = screen->serverFormat.redShift;\n      unsigned int greenShift = screen->serverFormat.greenShift;\n      unsigned int blueShift = screen->serverFormat.blueShift;\n      unsigned long redMax = screen->serverFormat.redMax;\n      unsigned long greenMax = screen->serverFormat.greenMax;\n      unsigned long blueMax = screen->serverFormat.blueMax;\n\n     /* for each *destination* pixel... */\n     for (y = 0; y < h1; y++) {\n       for (x = 0; x < w1; x++) {\n         red = green = blue = 0;\n         /* Get the totals for rgb from the source grid... */\n         for (w = 0; w < areaX; w++) {\n           for (v = 0; v < areaY; v++) {\n             srcptr2 = &srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                               (v * screen->paddedWidthInBytes)];\n             pixel_value = 0;\n\n\n             switch (bytesPerPixel) {\n             case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n             case 2: pixel_value = *((unsigned short *)srcptr2); break;\n             case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n             default:\n               /* fixme: endianness problem? */\n               for (z = 0; z < bytesPerPixel; z++)\n                 pixel_value += (srcptr2[z] << (8 * z));\n                break;\n              }\n              /*\n              srcptr2 += bytesPerPixel;\n              */\n\n            red += ((pixel_value >> redShift) & redMax);\n            green += ((pixel_value >> greenShift) & greenMax);\n            blue += ((pixel_value >> blueShift) & blueMax);\n\n           }\n         }\n         /* We now have a total for all of the colors, find the average! */\n         red /= area2;\n         green /= area2;\n         blue /= area2;\n          /* Stuff the new value back into memory */\n         pixel_value = ((red & redMax) << redShift) | ((green & greenMax) << greenShift) | ((blue & blueMax) << blueShift);\n\n         switch (bytesPerPixel) {\n         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n         default:\n           /* fixme: endianness problem? */\n           for (z = 0; z < bytesPerPixel; z++)\n             dstptr[z]=(pixel_value >> (8 * z)) & 0xff;\n            break;\n          }\n          dstptr += bytesPerPixel;\n       }\n       srcptr += (screen->paddedWidthInBytes * areaY);\n       dstptr += (ptr->paddedWidthInBytes - bytesPerLine);\n     }\n   } else\n   { /* Not truecolour, so we can't blend. Just use the top-left pixel instead */\n     for (y = y1; y < (y1+h1); y++) {\n       for (x = x1; x < (x1+w1); x++)\n         memcpy (&ptr->frameBuffer[(y *ptr->paddedWidthInBytes) + (x * bytesPerPixel)],\n                 &screen->frameBuffer[(y * areaY * screen->paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n     }\n  }\n}", "func_src_after": "void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0)\n{\n    int x,y,w,v,z;\n    int x1, y1, w1, h1;\n    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n    unsigned char *srcptr, *dstptr;\n\n    /* Nothing to do!!! */\n    if (screen==ptr) return;\n\n    x1 = x0;\n    y1 = y0;\n    w1 = w0;\n    h1 = h0;\n\n    rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, \"rfbScaledScreenUpdateRect\");\n    x0 = ScaleX(ptr, screen, x1);\n    y0 = ScaleY(ptr, screen, y1);\n    w0 = ScaleX(ptr, screen, w1);\n    h0 = ScaleY(ptr, screen, h1);\n\n    bitsPerPixel = screen->bitsPerPixel;\n    bytesPerPixel = bitsPerPixel / 8;\n    bytesPerLine = w1 * bytesPerPixel;\n    srcptr = (unsigned char *)(screen->frameBuffer +\n     (y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));\n    dstptr = (unsigned char *)(ptr->frameBuffer +\n     ( y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));\n    /* The area of the source framebuffer for each destination pixel */\n    areaX = ScaleX(ptr,screen,1);\n    areaY = ScaleY(ptr,screen,1);\n    area2 = areaX*areaY;\n\n\n    /* Ensure that we do not go out of bounds */\n    if ((x1+w1) > (ptr->width))\n    {\n      if (x1==0) w1=ptr->width; else x1 = ptr->width - w1;\n    }\n    if ((y1+h1) > (ptr->height))\n    {\n      if (y1==0) h1=ptr->height; else y1 = ptr->height - h1;\n    }\n    /*\n     * rfbLog(\"rfbScaledScreenUpdateRect(%dXx%dY-%dWx%dH  ->  %dXx%dY-%dWx%dH <%dx%d>) {%dWx%dH -> %dWx%dH} 0x%p\\n\",\n     *    x0, y0, w0, h0, x1, y1, w1, h1, areaX, areaY,\n     *    screen->width, screen->height, ptr->width, ptr->height, ptr->frameBuffer);\n     */\n\n    if (screen->serverFormat.trueColour) { /* Blend neighbouring pixels together */\n      unsigned char *srcptr2;\n      unsigned long pixel_value, red, green, blue;\n      unsigned int redShift = screen->serverFormat.redShift;\n      unsigned int greenShift = screen->serverFormat.greenShift;\n      unsigned int blueShift = screen->serverFormat.blueShift;\n      unsigned long redMax = screen->serverFormat.redMax;\n      unsigned long greenMax = screen->serverFormat.greenMax;\n      unsigned long blueMax = screen->serverFormat.blueMax;\n\n     /* for each *destination* pixel... */\n     for (y = 0; y < h1; y++) {\n       for (x = 0; x < w1; x++) {\n         red = green = blue = 0;\n         /* Get the totals for rgb from the source grid... */\n         for (w = 0; w < areaX; w++) {\n           for (v = 0; v < areaY; v++) {\n             srcptr2 = &srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                               (v * screen->paddedWidthInBytes)];\n             pixel_value = 0;\n\n\n             switch (bytesPerPixel) {\n             case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n             case 2: pixel_value = *((unsigned short *)srcptr2); break;\n             case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n             default:\n               /* fixme: endianness problem? */\n               for (z = 0; z < bytesPerPixel; z++)\n                 pixel_value += ((unsigned long)srcptr2[z] << (8 * z));\n                break;\n              }\n              /*\n              srcptr2 += bytesPerPixel;\n              */\n\n            red += ((pixel_value >> redShift) & redMax);\n            green += ((pixel_value >> greenShift) & greenMax);\n            blue += ((pixel_value >> blueShift) & blueMax);\n\n           }\n         }\n         /* We now have a total for all of the colors, find the average! */\n         red /= area2;\n         green /= area2;\n         blue /= area2;\n          /* Stuff the new value back into memory */\n         pixel_value = ((red & redMax) << redShift) | ((green & greenMax) << greenShift) | ((blue & blueMax) << blueShift);\n\n         switch (bytesPerPixel) {\n         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n         default:\n           /* fixme: endianness problem? */\n           for (z = 0; z < bytesPerPixel; z++)\n             dstptr[z]=(pixel_value >> (8 * z)) & 0xff;\n            break;\n          }\n          dstptr += bytesPerPixel;\n       }\n       srcptr += (screen->paddedWidthInBytes * areaY);\n       dstptr += (ptr->paddedWidthInBytes - bytesPerLine);\n     }\n   } else\n   { /* Not truecolour, so we can't blend. Just use the top-left pixel instead */\n     for (y = y1; y < (y1+h1); y++) {\n       for (x = x1; x < (x1+w1); x++)\n         memcpy (&ptr->frameBuffer[(y *ptr->paddedWidthInBytes) + (x * bytesPerPixel)],\n                 &screen->frameBuffer[(y * areaY * screen->paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n     }\n  }\n}", "line_changes": {"deleted": [{"line_no": 79, "char_start": 3001, "char_end": 3058, "line": "                 pixel_value += (srcptr2[z] << (8 * z));\n"}], "added": [{"line_no": 79, "char_start": 3001, "char_end": 3073, "line": "                 pixel_value += ((unsigned long)srcptr2[z] << (8 * z));\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 3034, "char_end": 3049, "chars": "(unsigned long)"}]}, "commit_link": "github.com/LibVNC/libvncserver/commit/a6788d1da719ae006605b78d22f5a9f170b423af", "file_name": "libvncserver/scale.c", "vul_type": "cwe-190"}
{"func_name": "jsuGetFreeStack", "func_src_before": "size_t jsuGetFreeStack() {\n#ifdef ARM\n  void *frame = __builtin_frame_address(0);\n  size_t stackPos = (size_t)((char*)frame);\n  size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);\n  if (stackPos < stackEnd) return 0; // should never happen, but just in case of overflow!\n  return  stackPos - stackEnd;\n#elif defined(LINUX)\n  // On linux, we set STACK_BASE from `main`.\n  char ptr; // this is on the stack\n  extern void *STACK_BASE;\n  uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);\n  return 1000000 - count; // give it 1 megabyte of stack\n#else\n  // stack depth seems pretty platform-specific :( Default to a value that disables it\n  return 1000000; // no stack depth check on this platform\n#endif\n}", "func_src_after": "size_t jsuGetFreeStack() {\n#ifdef ARM\n  void *frame = __builtin_frame_address(0);\n  size_t stackPos = (size_t)((char*)frame);\n  size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);\n  if (stackPos < stackEnd) return 0; // should never happen, but just in case of overflow!\n  return  stackPos - stackEnd;\n#elif defined(LINUX)\n  // On linux, we set STACK_BASE from `main`.\n  char ptr; // this is on the stack\n  extern void *STACK_BASE;\n  uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);\n  const uint32_t max_stack = 1000000; // give it 1 megabyte of stack\n  if (count>max_stack) return 0;\n  return max_stack - count;\n#else\n  // stack depth seems pretty platform-specific :( Default to a value that disables it\n  return 1000000; // no stack depth check on this platform\n#endif\n}", "line_changes": {"deleted": [{"line_no": 13, "char_start": 499, "char_end": 556, "line": "  return 1000000 - count; // give it 1 megabyte of stack\n"}], "added": [{"line_no": 13, "char_start": 499, "char_end": 568, "line": "  const uint32_t max_stack = 1000000; // give it 1 megabyte of stack\n"}, {"line_no": 14, "char_start": 568, "char_end": 601, "line": "  if (count>max_stack) return 0;\n"}, {"line_no": 15, "char_start": 601, "char_end": 629, "line": "  return max_stack - count;\n"}]}, "char_changes": {"deleted": [{"char_start": 501, "char_end": 503, "chars": "re"}, {"char_start": 505, "char_end": 506, "chars": "r"}, {"char_start": 515, "char_end": 523, "chars": " - count"}], "added": [{"char_start": 501, "char_end": 505, "chars": "cons"}, {"char_start": 506, "char_end": 507, "chars": " "}, {"char_start": 508, "char_end": 509, "chars": "i"}, {"char_start": 510, "char_end": 527, "chars": "t32_t max_stack ="}, {"char_start": 567, "char_end": 628, "chars": "\n  if (count>max_stack) return 0;\n  return max_stack - count;"}]}, "commit_link": "github.com/espruino/Espruino/commit/a0d7f432abee692402c00e8b615ff5982dde9780", "file_name": "src/jsutils.c", "vul_type": "cwe-190"}
{"func_name": "ssl_parse_client_psk_identity", "func_src_before": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Receive client pre-shared key identity name\n     */\n    if( *p + 2 > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n\n    if( n < 1 || n > 65535 || *p + n > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        /* Identity is not a big secret since clients send it in the clear,\n         * but treat it carefully anyway, just in case */\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n\n    *p += n;\n\n    return( 0 );\n}", "func_src_after": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Receive client pre-shared key identity name\n     */\n    if( end - *p < 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n\n    if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        /* Identity is not a big secret since clients send it in the clear,\n         * but treat it carefully anyway, just in case */\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n\n    *p += n;\n\n    return( 0 );\n}", "line_changes": {"deleted": [{"line_no": 18, "char_start": 571, "char_end": 594, "line": "    if( *p + 2 > end )\n"}, {"line_no": 27, "char_start": 794, "char_end": 839, "line": "    if( n < 1 || n > 65535 || *p + n > end )\n"}], "added": [{"line_no": 18, "char_start": 571, "char_end": 594, "line": "    if( end - *p < 2 )\n"}, {"line_no": 27, "char_start": 794, "char_end": 852, "line": "    if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )\n"}]}, "char_changes": {"deleted": [{"char_start": 582, "char_end": 583, "chars": "+"}, {"char_start": 585, "char_end": 591, "chars": " > end"}, {"char_start": 824, "char_end": 826, "chars": "*p"}, {"char_start": 827, "char_end": 828, "chars": "+"}, {"char_start": 829, "char_end": 830, "chars": "n"}, {"char_start": 831, "char_end": 832, "chars": ">"}], "added": [{"char_start": 579, "char_end": 585, "chars": "end - "}, {"char_start": 588, "char_end": 589, "chars": "<"}, {"char_start": 828, "char_end": 839, "chars": "(size_t) ( "}, {"char_start": 842, "char_end": 849, "chars": " - *p )"}]}, "commit_link": "github.com/ARMmbed/mbedtls/commit/83c9f495ffe70c7dd280b41fdfd4881485a3bc28", "file_name": "library/ssl_srv.c", "vul_type": "cwe-190"}
{"func_name": "read_ujpg", "func_src_before": "bool read_ujpg( void )\n{\n    using namespace IOUtil;\n    using namespace Sirikata;\n//    colldata.start_decoder_worker_thread(std::bind(&simple_decoder, &colldata, str_in));\n    unsigned char ujpg_mrk[ 64 ];\n    // this is where we will enable seccomp, before reading user data\n    write_byte_bill(Billing::HEADER, true, 24); // for the fixed header\n\n    str_out->call_size_callback(max_file_size);\n    uint32_t compressed_header_size = 0;\n    if (ReadFull(str_in, ujpg_mrk, 4) != 4) {\n        custom_exit(ExitCode::SHORT_READ);\n    }\n    write_byte_bill(Billing::HEADER, true, 4);\n\n    compressed_header_size = LEtoUint32(ujpg_mrk);\n    if (compressed_header_size > 128 * 1024 * 1024 || max_file_size > 128 * 1024 * 1024) {\n        always_assert(false && \"Only support images < 128 megs\");\n        return false; // bool too big\n    }\n    bool pending_header_reads = false;\n    if (header_reader == NULL) {\n        std::vector<uint8_t, JpegAllocator<uint8_t> > compressed_header_buffer(compressed_header_size);\n        IOUtil::ReadFull(str_in, compressed_header_buffer.data(), compressed_header_buffer.size());\n        header_reader = new MemReadWriter((JpegAllocator<uint8_t>()));\n        {\n            if (ujgversion == 1) {\n                JpegAllocator<uint8_t> no_free_allocator;\n#if !defined(USE_STANDARD_MEMORY_ALLOCATORS) && !defined(_WIN32) && !defined(EMSCRIPTEN)\n                no_free_allocator.setup_memory_subsystem(32 * 1024 * 1024,\n                                                         16,\n                                                         &mem_init_nop,\n                                                         &MemMgrAllocatorMalloc,\n                                                         &mem_nop,\n                                                         &mem_realloc_nop,\n                                                         &MemMgrAllocatorMsize);\n#endif\n                std::pair<std::vector<uint8_t,\n                                      Sirikata::JpegAllocator<uint8_t> >,\n                          JpegError> uncompressed_header_buffer(\n                              ZlibDecoderDecompressionReader::Decompress(compressed_header_buffer.data(),\n                                                                         compressed_header_buffer.size(),\n                                                                         no_free_allocator,\n                                                                         max_file_size + 2048));\n                if (uncompressed_header_buffer.second) {\n                    always_assert(false && \"Data not properly zlib coded\");\n                    return false;\n                }\n                zlib_hdrs = compressed_header_buffer.size();\n                header_reader->SwapIn(uncompressed_header_buffer.first, 0);\n            } else {\n                std::pair<std::vector<uint8_t,\n                                      Sirikata::JpegAllocator<uint8_t> >,\n                          JpegError> uncompressed_header_buffer(\n                              Sirikata::BrotliCodec::Decompress(compressed_header_buffer.data(),\n                                                                compressed_header_buffer.size(),\n                                                                JpegAllocator<uint8_t>(),\n                                                                max_file_size * 2 + 128 * 1024 * 1024));\n                if (uncompressed_header_buffer.second) {\n                    always_assert(false && \"Data not properly zlib coded\");\n                    return false;\n                }\n                zlib_hdrs = compressed_header_buffer.size();\n                header_reader->SwapIn(uncompressed_header_buffer.first, 0);            \n            }\n        }\n        write_byte_bill(Billing::HEADER,\n                        true,\n                        compressed_header_buffer.size());\n    } else {\n        always_assert(compressed_header_size == 0 && \"Special concatenation requires 0 size header\");\n    }\n    grbs = sizeof(EOI);\n    grbgdata = EOI; // if we don't have any garbage, assume FFD9 EOI\n    // read header from file\n    ReadFull(header_reader, ujpg_mrk, 3 ) ;\n    // check marker\n    if ( memcmp( ujpg_mrk, \"HDR\", 3 ) == 0 ) {\n        // read size of header, alloc memory\n        ReadFull(header_reader, ujpg_mrk, 4 );\n        hdrs = LEtoUint32(ujpg_mrk);\n        hdrdata = (unsigned char*) aligned_alloc(hdrs);\n        memset(hdrdata, 0, hdrs);\n        if ( hdrdata == NULL ) {\n            fprintf( stderr, MEM_ERRMSG );\n            errorlevel.store(2);\n            return false;\n        }\n        // read hdrdata\n        ReadFull(header_reader, hdrdata, hdrs );\n    }\n    else {\n        fprintf( stderr, \"HDR marker not found\" );\n        errorlevel.store(2);\n        return false;\n    }\n    bool memory_optimized_image = (filetype != UJG) && !g_allow_progressive;\n    // parse header for image-info\n    if ( !setup_imginfo_jpg(memory_optimized_image) )\n        return false;\n\n    // beginning here: recovery information (needed for exact JPEG recovery)\n\n    // read padbit information from file\n    ReadFull(header_reader, ujpg_mrk, 3 );\n    // check marker\n    if ( memcmp( ujpg_mrk, \"P0D\", 3 ) == 0 ) {\n        // This is a more nuanced pad byte that can have different values per bit\n        header_reader->Read( reinterpret_cast<unsigned char*>(&padbit), 1 );\n    }\n    else if ( memcmp( ujpg_mrk, \"PAD\", 3 ) == 0 ) {\n        // this is a single pad bit that is implied to have all the same values\n        header_reader->Read( reinterpret_cast<unsigned char*>(&padbit), 1 );\n        if (!(padbit == 0 || padbit == 1 ||padbit == -1)) {\n            while (write(2,\n                        \"Legacy Padbit must be 0, 1 or -1\\n\",\n                         strlen(\"Legacy Padbit must be 0, 1 or -1\\n\")) < 0\n                   && errno == EINTR) {\n            }\n            custom_exit(ExitCode::STREAM_INCONSISTENT);\n        }\n        if (padbit == 1) {\n            padbit = 0x7f; // all 6 bits set\n        }\n    }\n    else {\n        fprintf( stderr, \"PAD marker not found\" );\n        errorlevel.store(2);\n        return false;\n    }\n    std::vector<ThreadHandoff> thread_handoff;\n    // read further recovery information if any\n    while ( ReadFull(header_reader, ujpg_mrk, 3 ) == 3 ) {\n        // check marker\n        if ( memcmp( ujpg_mrk, \"CRS\", 3 ) == 0 ) {\n            rst_cnt_set = true;\n            ReadFull(header_reader, ujpg_mrk, 4);\n            rst_cnt.resize(LEtoUint32(ujpg_mrk));\n            for (size_t i = 0; i < rst_cnt.size(); ++i) {\n                ReadFull(header_reader, ujpg_mrk, 4);\n                rst_cnt.at(i) = LEtoUint32(ujpg_mrk);\n            }\n        } else if ( memcmp( ujpg_mrk, \"HHX\", 2 ) == 0 ) { // only look at first two bytes\n            size_t to_alloc = ThreadHandoff::get_remaining_data_size_from_two_bytes(ujpg_mrk + 1) + 2;\n            if(to_alloc) {\n                std::vector<unsigned char> data(to_alloc);\n                data[0] = ujpg_mrk[1];\n                data[1] = ujpg_mrk[2];\n                ReadFull(header_reader, &data[2], to_alloc - 2);\n                thread_handoff = ThreadHandoff::deserialize(&data[0], to_alloc);\n            }\n        } else if ( memcmp( ujpg_mrk, \"FRS\", 3 ) == 0 ) {\n            // read number of false set RST markers per scan from file\n            ReadFull(header_reader, ujpg_mrk, 4);\n            scnc = LEtoUint32(ujpg_mrk);\n            \n            rst_err.insert(rst_err.end(), scnc - rst_err.size(), 0);\n            // read data\n            ReadFull(header_reader, rst_err.data(), scnc );\n        }\n        else if ( memcmp( ujpg_mrk, \"GRB\", 3 ) == 0 ) {\n            // read garbage (data after end of JPG) from file\n            ReadFull(header_reader, ujpg_mrk, 4);\n            grbs = LEtoUint32(ujpg_mrk);\n            grbgdata = aligned_alloc(grbs);\n            memset(grbgdata, 0, sizeof(grbs));\n            if ( grbgdata == NULL ) {\n                fprintf( stderr, MEM_ERRMSG );\n                errorlevel.store(2);\n                return false;\n            }\n            // read garbage data\n            ReadFull(header_reader, grbgdata, grbs );\n        }\n        else if ( memcmp( ujpg_mrk, \"PGR\", 3 ) == 0 || memcmp( ujpg_mrk, \"PGE\", 3 ) == 0 ) {\n            // read prefix garbage (data before beginning of JPG) from file\n            if (ujpg_mrk[2] == 'E') {\n                // embedded jpeg: full header required\n                embedded_jpeg = true;\n            }\n            ReadFull(header_reader, ujpg_mrk, 4);\n            prefix_grbs = LEtoUint32(ujpg_mrk);\n            prefix_grbgdata = aligned_alloc(prefix_grbs);\n            memset(prefix_grbgdata, 0, sizeof(prefix_grbs));\n            if ( prefix_grbgdata == NULL ) {\n                fprintf( stderr, MEM_ERRMSG );\n                errorlevel.store(2);\n                return false;\n            }\n            // read garbage data\n            ReadFull(header_reader, prefix_grbgdata, prefix_grbs );\n        }\n        else if ( memcmp( ujpg_mrk, \"SIZ\", 3 ) == 0 ) {\n            // full size of the original file\n            ReadFull(header_reader, ujpg_mrk, 4);\n            max_file_size = LEtoUint32(ujpg_mrk);\n        }\n        else if ( memcmp( ujpg_mrk, \"EEE\", 3) == 0) {\n            ReadFull(header_reader, ujpg_mrk, 28);\n            max_cmp = LEtoUint32(ujpg_mrk);\n            max_bpos = LEtoUint32(ujpg_mrk + 4);\n            max_sah = LEtoUint32(ujpg_mrk + 8);\n            max_dpos[0] = LEtoUint32(ujpg_mrk + 12);\n            max_dpos[1] = LEtoUint32(ujpg_mrk + 16);\n            max_dpos[2] = LEtoUint32(ujpg_mrk + 20);\n            max_dpos[3] = LEtoUint32(ujpg_mrk + 24);\n            early_eof_encountered = true;\n            colldata.set_truncation_bounds(max_cmp, max_bpos, max_dpos, max_sah);\n        }\n        else {\n            if (memcmp(ujpg_mrk, \"CNT\", 3) == 0 ) {\n                pending_header_reads = true;\n                break;\n            } else if (memcmp(ujpg_mrk, \"CMP\", 3) == 0 ) {\n                break;\n            } else {\n                fprintf( stderr, \"unknown data found\" );\n                errorlevel.store(2);\n            }\n            return false;\n        }\n    }\n    if (!pending_header_reads) {\n        delete header_reader;\n        header_reader = NULL;\n    }\n    write_byte_bill(Billing::HEADER,\n                    false,\n                    2 + hdrs + prefix_grbs + grbs);\n\n    ReadFull(str_in, ujpg_mrk, 3 ) ;\n    write_byte_bill(Billing::HEADER, true, 3);\n\n    write_byte_bill(Billing::DELIMITERS, true, 4 * NUM_THREADS); // trailing vpx_encode bits\n    write_byte_bill(Billing::HEADER, true, 4); //trailing size\n\n    if (memcmp(ujpg_mrk, \"CMP\", 3) != 0) {\n        always_assert(false && \"CMP must be present (uncompressed) in the file or CNT continue marker\");\n        return false; // not a JPG\n    }\n    colldata.signal_worker_should_begin();\n    g_decoder->initialize(str_in, thread_handoff);\n    colldata.start_decoder(g_decoder);\n    return true;\n}", "func_src_after": "bool read_ujpg( void )\n{\n    using namespace IOUtil;\n    using namespace Sirikata;\n//    colldata.start_decoder_worker_thread(std::bind(&simple_decoder, &colldata, str_in));\n    unsigned char ujpg_mrk[ 64 ];\n    // this is where we will enable seccomp, before reading user data\n    write_byte_bill(Billing::HEADER, true, 24); // for the fixed header\n\n    str_out->call_size_callback(max_file_size);\n    uint32_t compressed_header_size = 0;\n    if (ReadFull(str_in, ujpg_mrk, 4) != 4) {\n        custom_exit(ExitCode::SHORT_READ);\n    }\n    write_byte_bill(Billing::HEADER, true, 4);\n\n    compressed_header_size = LEtoUint32(ujpg_mrk);\n    if (compressed_header_size > 128 * 1024 * 1024 || max_file_size > 128 * 1024 * 1024) {\n        always_assert(false && \"Only support images < 128 megs\");\n        return false; // bool too big\n    }\n    bool pending_header_reads = false;\n    if (header_reader == NULL) {\n        std::vector<uint8_t, JpegAllocator<uint8_t> > compressed_header_buffer(compressed_header_size);\n        IOUtil::ReadFull(str_in, compressed_header_buffer.data(), compressed_header_buffer.size());\n        header_reader = new MemReadWriter((JpegAllocator<uint8_t>()));\n        {\n            if (ujgversion == 1) {\n                JpegAllocator<uint8_t> no_free_allocator;\n#if !defined(USE_STANDARD_MEMORY_ALLOCATORS) && !defined(_WIN32) && !defined(EMSCRIPTEN)\n                no_free_allocator.setup_memory_subsystem(32 * 1024 * 1024,\n                                                         16,\n                                                         &mem_init_nop,\n                                                         &MemMgrAllocatorMalloc,\n                                                         &mem_nop,\n                                                         &mem_realloc_nop,\n                                                         &MemMgrAllocatorMsize);\n#endif\n                std::pair<std::vector<uint8_t,\n                                      Sirikata::JpegAllocator<uint8_t> >,\n                          JpegError> uncompressed_header_buffer(\n                              ZlibDecoderDecompressionReader::Decompress(compressed_header_buffer.data(),\n                                                                         compressed_header_buffer.size(),\n                                                                         no_free_allocator,\n                                                                         max_file_size + 2048));\n                if (uncompressed_header_buffer.second) {\n                    always_assert(false && \"Data not properly zlib coded\");\n                    return false;\n                }\n                zlib_hdrs = compressed_header_buffer.size();\n                header_reader->SwapIn(uncompressed_header_buffer.first, 0);\n            } else {\n                std::pair<std::vector<uint8_t,\n                                      Sirikata::JpegAllocator<uint8_t> >,\n                          JpegError> uncompressed_header_buffer(\n                              Sirikata::BrotliCodec::Decompress(compressed_header_buffer.data(),\n                                                                compressed_header_buffer.size(),\n                                                                JpegAllocator<uint8_t>(),\n                                                                ((size_t)max_file_size) * 2 + 128 * 1024 * 1024));\n                if (uncompressed_header_buffer.second) {\n                    always_assert(false && \"Data not properly zlib coded\");\n                    return false;\n                }\n                zlib_hdrs = compressed_header_buffer.size();\n                header_reader->SwapIn(uncompressed_header_buffer.first, 0);            \n            }\n        }\n        write_byte_bill(Billing::HEADER,\n                        true,\n                        compressed_header_buffer.size());\n    } else {\n        always_assert(compressed_header_size == 0 && \"Special concatenation requires 0 size header\");\n    }\n    grbs = sizeof(EOI);\n    grbgdata = EOI; // if we don't have any garbage, assume FFD9 EOI\n    // read header from file\n    ReadFull(header_reader, ujpg_mrk, 3 ) ;\n    // check marker\n    if ( memcmp( ujpg_mrk, \"HDR\", 3 ) == 0 ) {\n        // read size of header, alloc memory\n        ReadFull(header_reader, ujpg_mrk, 4 );\n        hdrs = LEtoUint32(ujpg_mrk);\n        hdrdata = (unsigned char*) aligned_alloc(hdrs);\n        memset(hdrdata, 0, hdrs);\n        if ( hdrdata == NULL ) {\n            fprintf( stderr, MEM_ERRMSG );\n            errorlevel.store(2);\n            return false;\n        }\n        // read hdrdata\n        ReadFull(header_reader, hdrdata, hdrs );\n    }\n    else {\n        fprintf( stderr, \"HDR marker not found\" );\n        errorlevel.store(2);\n        return false;\n    }\n    bool memory_optimized_image = (filetype != UJG) && !g_allow_progressive;\n    // parse header for image-info\n    if ( !setup_imginfo_jpg(memory_optimized_image) )\n        return false;\n\n    // beginning here: recovery information (needed for exact JPEG recovery)\n\n    // read padbit information from file\n    ReadFull(header_reader, ujpg_mrk, 3 );\n    // check marker\n    if ( memcmp( ujpg_mrk, \"P0D\", 3 ) == 0 ) {\n        // This is a more nuanced pad byte that can have different values per bit\n        header_reader->Read( reinterpret_cast<unsigned char*>(&padbit), 1 );\n    }\n    else if ( memcmp( ujpg_mrk, \"PAD\", 3 ) == 0 ) {\n        // this is a single pad bit that is implied to have all the same values\n        header_reader->Read( reinterpret_cast<unsigned char*>(&padbit), 1 );\n        if (!(padbit == 0 || padbit == 1 ||padbit == -1)) {\n            while (write(2,\n                        \"Legacy Padbit must be 0, 1 or -1\\n\",\n                         strlen(\"Legacy Padbit must be 0, 1 or -1\\n\")) < 0\n                   && errno == EINTR) {\n            }\n            custom_exit(ExitCode::STREAM_INCONSISTENT);\n        }\n        if (padbit == 1) {\n            padbit = 0x7f; // all 6 bits set\n        }\n    }\n    else {\n        fprintf( stderr, \"PAD marker not found\" );\n        errorlevel.store(2);\n        return false;\n    }\n    std::vector<ThreadHandoff> thread_handoff;\n    // read further recovery information if any\n    while ( ReadFull(header_reader, ujpg_mrk, 3 ) == 3 ) {\n        // check marker\n        if ( memcmp( ujpg_mrk, \"CRS\", 3 ) == 0 ) {\n            rst_cnt_set = true;\n            ReadFull(header_reader, ujpg_mrk, 4);\n            rst_cnt.resize(LEtoUint32(ujpg_mrk));\n            for (size_t i = 0; i < rst_cnt.size(); ++i) {\n                ReadFull(header_reader, ujpg_mrk, 4);\n                rst_cnt.at(i) = LEtoUint32(ujpg_mrk);\n            }\n        } else if ( memcmp( ujpg_mrk, \"HHX\", 2 ) == 0 ) { // only look at first two bytes\n            size_t to_alloc = ThreadHandoff::get_remaining_data_size_from_two_bytes(ujpg_mrk + 1) + 2;\n            if(to_alloc) {\n                std::vector<unsigned char> data(to_alloc);\n                data[0] = ujpg_mrk[1];\n                data[1] = ujpg_mrk[2];\n                ReadFull(header_reader, &data[2], to_alloc - 2);\n                thread_handoff = ThreadHandoff::deserialize(&data[0], to_alloc);\n            }\n        } else if ( memcmp( ujpg_mrk, \"FRS\", 3 ) == 0 ) {\n            // read number of false set RST markers per scan from file\n            ReadFull(header_reader, ujpg_mrk, 4);\n            scnc = LEtoUint32(ujpg_mrk);\n            \n            rst_err.insert(rst_err.end(), scnc - rst_err.size(), 0);\n            // read data\n            ReadFull(header_reader, rst_err.data(), scnc );\n        }\n        else if ( memcmp( ujpg_mrk, \"GRB\", 3 ) == 0 ) {\n            // read garbage (data after end of JPG) from file\n            ReadFull(header_reader, ujpg_mrk, 4);\n            grbs = LEtoUint32(ujpg_mrk);\n            grbgdata = aligned_alloc(grbs);\n            memset(grbgdata, 0, sizeof(grbs));\n            if ( grbgdata == NULL ) {\n                fprintf( stderr, MEM_ERRMSG );\n                errorlevel.store(2);\n                return false;\n            }\n            // read garbage data\n            ReadFull(header_reader, grbgdata, grbs );\n        }\n        else if ( memcmp( ujpg_mrk, \"PGR\", 3 ) == 0 || memcmp( ujpg_mrk, \"PGE\", 3 ) == 0 ) {\n            // read prefix garbage (data before beginning of JPG) from file\n            if (ujpg_mrk[2] == 'E') {\n                // embedded jpeg: full header required\n                embedded_jpeg = true;\n            }\n            ReadFull(header_reader, ujpg_mrk, 4);\n            prefix_grbs = LEtoUint32(ujpg_mrk);\n            prefix_grbgdata = aligned_alloc(prefix_grbs);\n            memset(prefix_grbgdata, 0, sizeof(prefix_grbs));\n            if ( prefix_grbgdata == NULL ) {\n                fprintf( stderr, MEM_ERRMSG );\n                errorlevel.store(2);\n                return false;\n            }\n            // read garbage data\n            ReadFull(header_reader, prefix_grbgdata, prefix_grbs );\n        }\n        else if ( memcmp( ujpg_mrk, \"SIZ\", 3 ) == 0 ) {\n            // full size of the original file\n            ReadFull(header_reader, ujpg_mrk, 4);\n            max_file_size = LEtoUint32(ujpg_mrk);\n        }\n        else if ( memcmp( ujpg_mrk, \"EEE\", 3) == 0) {\n            ReadFull(header_reader, ujpg_mrk, 28);\n            max_cmp = LEtoUint32(ujpg_mrk);\n            max_bpos = LEtoUint32(ujpg_mrk + 4);\n            max_sah = LEtoUint32(ujpg_mrk + 8);\n            max_dpos[0] = LEtoUint32(ujpg_mrk + 12);\n            max_dpos[1] = LEtoUint32(ujpg_mrk + 16);\n            max_dpos[2] = LEtoUint32(ujpg_mrk + 20);\n            max_dpos[3] = LEtoUint32(ujpg_mrk + 24);\n            early_eof_encountered = true;\n            colldata.set_truncation_bounds(max_cmp, max_bpos, max_dpos, max_sah);\n        }\n        else {\n            if (memcmp(ujpg_mrk, \"CNT\", 3) == 0 ) {\n                pending_header_reads = true;\n                break;\n            } else if (memcmp(ujpg_mrk, \"CMP\", 3) == 0 ) {\n                break;\n            } else {\n                fprintf( stderr, \"unknown data found\" );\n                errorlevel.store(2);\n            }\n            return false;\n        }\n    }\n    if (!pending_header_reads) {\n        delete header_reader;\n        header_reader = NULL;\n    }\n    write_byte_bill(Billing::HEADER,\n                    false,\n                    2 + hdrs + prefix_grbs + grbs);\n\n    ReadFull(str_in, ujpg_mrk, 3 ) ;\n    write_byte_bill(Billing::HEADER, true, 3);\n\n    write_byte_bill(Billing::DELIMITERS, true, 4 * NUM_THREADS); // trailing vpx_encode bits\n    write_byte_bill(Billing::HEADER, true, 4); //trailing size\n\n    if (memcmp(ujpg_mrk, \"CMP\", 3) != 0) {\n        always_assert(false && \"CMP must be present (uncompressed) in the file or CNT continue marker\");\n        return false; // not a JPG\n    }\n    colldata.signal_worker_should_begin();\n    g_decoder->initialize(str_in, thread_handoff);\n    colldata.start_decoder(g_decoder);\n    return true;\n}", "line_changes": {"deleted": [{"line_no": 59, "char_start": 3293, "char_end": 3398, "line": "                                                                max_file_size * 2 + 128 * 1024 * 1024));\n"}], "added": [{"line_no": 59, "char_start": 3293, "char_end": 3408, "line": "                                                                ((size_t)max_file_size) * 2 + 128 * 1024 * 1024));\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 3357, "char_end": 3366, "chars": "((size_t)"}, {"char_start": 3379, "char_end": 3380, "chars": ")"}]}, "commit_link": "github.com/dropbox/lepton/commit/6a5ceefac1162783fffd9506a3de39c85c725761", "file_name": "src/lepton/jpgcoder.cc", "vul_type": "cwe-190"}
