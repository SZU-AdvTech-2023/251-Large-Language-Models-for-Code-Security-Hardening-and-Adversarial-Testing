{"func_name": "search_make_new", "func_src_before": "search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n\tstruct search_domain *dom;\n\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\t/* this is the postfix we want */\n\t\t\t/* the actual postfix string is kept at the end of the structure */\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\n\t/* we ran off the end of the list and still didn't find the requested string */\n\tEVUTIL_ASSERT(0);\n\treturn NULL; /* unreachable; stops warnings in some compilers. */\n}", "func_src_after": "search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tchar need_to_append_dot;\n\tstruct search_domain *dom;\n\n\tif (!base_len) return NULL;\n\tneed_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\t/* this is the postfix we want */\n\t\t\t/* the actual postfix string is kept at the end of the structure */\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\n\t/* we ran off the end of the list and still didn't find the requested string */\n\tEVUTIL_ASSERT(0);\n\treturn NULL; /* unreachable; stops warnings in some compilers. */\n}", "line_changes": {"deleted": [{"line_no": 3, "char_start": 138, "char_end": 211, "line": "\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n"}], "added": [{"line_no": 3, "char_start": 138, "char_end": 164, "line": "\tchar need_to_append_dot;\n"}, {"line_no": 6, "char_start": 193, "char_end": 222, "line": "\tif (!base_len) return NULL;\n"}, {"line_no": 7, "char_start": 222, "char_end": 284, "line": "\tneed_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n"}, {"line_no": 8, "char_start": 284, "char_end": 285, "line": "\n"}]}, "char_changes": {"deleted": [{"char_start": 209, "char_end": 237, "chars": ";\n\tstruct search_domain *dom"}], "added": [{"char_start": 140, "char_end": 150, "chars": "har need_t"}, {"char_start": 151, "char_end": 156, "chars": "_appe"}, {"char_start": 157, "char_end": 165, "chars": "d_dot;\n\t"}, {"char_start": 167, "char_end": 171, "chars": "ruct"}, {"char_start": 172, "char_end": 176, "chars": "sear"}, {"char_start": 178, "char_end": 182, "chars": "_dom"}, {"char_start": 183, "char_end": 209, "chars": "in *dom;\n\n\tif (!base_len) "}, {"char_start": 210, "char_end": 215, "chars": "eturn"}, {"char_start": 216, "char_end": 223, "chars": "NULL;\n\t"}]}, "commit_link": "github.com/libevent/libevent/commit/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e", "file_name": "evdns.c", "vul_type": "cwe-125"}
{"func_name": "TS_OBJ_print_bio", "func_src_before": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n{\n    char obj_txt[128];\n\n    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n\n    return 1;\n}", "func_src_after": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n{\n    char obj_txt[128];\n\n    OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_printf(bio, \"%s\\n\", obj_txt);\n\n    return 1;\n}", "line_changes": {"deleted": [{"line_no": 5, "char_start": 81, "char_end": 142, "line": "    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n"}, {"line_no": 6, "char_start": 142, "char_end": 176, "line": "    BIO_write(bio, obj_txt, len);\n"}, {"line_no": 7, "char_start": 176, "char_end": 205, "line": "    BIO_write(bio, \"\\n\", 1);\n"}], "added": [{"line_no": 5, "char_start": 81, "char_end": 132, "line": "    OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n"}, {"line_no": 6, "char_start": 132, "char_end": 170, "line": "    BIO_printf(bio, \"%s\\n\", obj_txt);\n"}]}, "char_changes": {"deleted": [{"char_start": 85, "char_end": 95, "chars": "int len = "}, {"char_start": 150, "char_end": 151, "chars": "w"}, {"char_start": 154, "char_end": 155, "chars": "e"}, {"char_start": 168, "char_end": 202, "chars": ", len);\n    BIO_write(bio, \"\\n\", 1"}], "added": [{"char_start": 140, "char_end": 141, "chars": "p"}, {"char_start": 145, "char_end": 146, "chars": "f"}, {"char_start": 153, "char_end": 155, "chars": "%s"}, {"char_start": 160, "char_end": 167, "chars": "obj_txt"}]}, "commit_link": "github.com/openssl/openssl/commit/0ed26acce328ec16a3aa635f1ca37365e8c7403a", "file_name": "crypto/ts/ts_lib.c", "vul_type": "cwe-125"}
{"func_name": "main", "func_src_before": "int main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    options_t *options = parse_arguments(argc, argv);\n\n    if (!options)\n    {\n        print_usage(argc, argv);\n        return 0;\n    }\n\n    // read input file\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n        free(options);\n        return 1;\n    }\n\n    stat(options->in_file, &filestats);\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n\n    // convert from binary to xml or vice-versa\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n\n    if (plist_out)\n    {\n        if (options->out_file != NULL)\n        {\n            FILE *oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n                free(options);\n                return 1;\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        }\n        // if no output file specified, write to stdout\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n\n        free(plist_out);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n\n    free(options);\n    return 0;\n}", "func_src_after": "int main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    options_t *options = parse_arguments(argc, argv);\n\n    if (!options)\n    {\n        print_usage(argc, argv);\n        return 0;\n    }\n\n    // read input file\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n        free(options);\n        return 1;\n    }\n\n    stat(options->in_file, &filestats);\n\n    if (filestats.st_size < 8) {\n        printf(\"ERROR: Input file is too small to contain valid plist data.\\n\");\n        return -1;\n    }\n\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n\n    // convert from binary to xml or vice-versa\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n\n    if (plist_out)\n    {\n        if (options->out_file != NULL)\n        {\n            FILE *oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n                free(options);\n                return 1;\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        }\n        // if no output file specified, write to stdout\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n\n        free(plist_out);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n\n    free(options);\n    return 0;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 26, "char_start": 533, "char_end": 534, "line": "\n"}, {"line_no": 27, "char_start": 534, "char_end": 567, "line": "    if (filestats.st_size < 8) {\n"}, {"line_no": 28, "char_start": 567, "char_end": 648, "line": "        printf(\"ERROR: Input file is too small to contain valid plist data.\\n\");\n"}, {"line_no": 29, "char_start": 648, "char_end": 667, "line": "        return -1;\n"}, {"line_no": 30, "char_start": 667, "char_end": 673, "line": "    }\n"}, {"line_no": 31, "char_start": 673, "char_end": 674, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 533, "char_end": 674, "chars": "\n    if (filestats.st_size < 8) {\n        printf(\"ERROR: Input file is too small to contain valid plist data.\\n\");\n        return -1;\n    }\n\n"}]}, "commit_link": "github.com/libimobiledevice/libplist/commit/7391a506352c009fe044dead7baad9e22dd279ee", "file_name": "tools/plistutil.c", "vul_type": "cwe-125"}
{"func_name": "AirPDcapDecryptWPABroadcastKey", "func_src_before": "AirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, guint eapol_len)\n{\n    guint8 key_version;\n    guint8 *key_data;\n    guint8  *szEncryptedKey;\n    guint16 key_bytes_len = 0; /* Length of the total key data field */\n    guint16 key_len;           /* Actual group key length */\n    static AIRPDCAP_KEY_ITEM dummy_key; /* needed in case AirPDcapRsnaMng() wants the key structure */\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\n\n    /* We skip verifying the MIC of the key. If we were implementing a WPA supplicant we'd want to verify, but for a sniffer it's not needed. */\n\n    /* Preparation for decrypting the group key -  determine group key data length */\n    /* depending on whether the pairwise key is TKIP or AES encryption key */\n    key_version = AIRPDCAP_EAP_KEY_DESCR_VER(pEAPKey->key_information[1]);\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\n        /* TKIP */\n        key_bytes_len = pntoh16(pEAPKey->key_length);\n    }else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES */\n        key_bytes_len = pntoh16(pEAPKey->key_data_len);\n\n        /* AES keys must be at least 128 bits = 16 bytes. */\n        if (key_bytes_len < 16) {\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n    }\n\n    if (key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY)) {\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Encrypted key is in the information element field of the EAPOL key packet */\n    key_data = (guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);\n    szEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);\n\n    DEBUG_DUMP(\"Encrypted Broadcast key:\", szEncryptedKey, key_bytes_len);\n    DEBUG_DUMP(\"KeyIV:\", pEAPKey->key_iv, 16);\n    DEBUG_DUMP(\"decryption_key:\", decryption_key, 16);\n\n    /* We are rekeying, save old sa */\n    tmp_sa=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));\n    memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n    sa->next=tmp_sa;\n\n    /* As we have no concept of the prior association request at this point, we need to deduce the     */\n    /* group key cipher from the length of the key bytes. In WPA this is straightforward as the        */\n    /* keybytes just contain the GTK, and the GTK is only in the group handshake, NOT the M3.          */\n    /* In WPA2 its a little more tricky as the M3 keybytes contain an RSN_IE, but the group handshake  */\n    /* does not. Also there are other (variable length) items in the keybytes which we need to account */\n    /* for to determine the true key length, and thus the group cipher.                                */\n\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\n        guint8 new_key[32];\n        guint8 dummy[256];\n        /* TKIP key */\n        /* Per 802.11i, Draft 3.0 spec, section 8.5.2, p. 97, line 4-8, */\n        /* group key is decrypted using RC4.  Concatenate the IV with the 16 byte EK (PTK+16) to get the decryption key */\n\n        rc4_state_struct rc4_state;\n\n        /* The WPA group key just contains the GTK bytes so deducing the type is straightforward   */\n        /* Note - WPA M3 doesn't contain a group key so we'll only be here for the group handshake */\n        sa->wpa.key_ver = (key_bytes_len >=TKIP_GROUP_KEY_LEN)?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n\n        /* Build the full decryption key based on the IV and part of the pairwise key */\n        memcpy(new_key, pEAPKey->key_iv, 16);\n        memcpy(new_key+16, decryption_key, 16);\n        DEBUG_DUMP(\"FullDecrKey:\", new_key, 32);\n\n        crypt_rc4_init(&rc4_state, new_key, sizeof(new_key));\n\n        /* Do dummy 256 iterations of the RC4 algorithm (per 802.11i, Draft 3.0, p. 97 line 6) */\n        crypt_rc4(&rc4_state, dummy, 256);\n        crypt_rc4(&rc4_state, szEncryptedKey, key_bytes_len);\n\n    } else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES CCMP key */\n\n        guint8 key_found;\n        guint8 key_length;\n        guint16 key_index;\n        guint8 *decrypted_data;\n\n        /* Unwrap the key; the result is key_bytes_len in length */\n        decrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey,  key_bytes_len);\n\n        /* With WPA2 what we get after Broadcast Key decryption is an actual RSN structure.\n           The key itself is stored as a GTK KDE\n           WPA2 IE (1 byte) id = 0xdd, length (1 byte), GTK OUI (4 bytes), key index (1 byte) and 1 reserved byte. Thus we have to\n           pass pointer to the actual key with 8 bytes offset */\n\n        key_found = FALSE;\n        key_index = 0;\n\n        /* Parse Key data until we found GTK KDE */\n        /* GTK KDE = 00-0F-AC 01 */\n        while(key_index < (key_bytes_len - 6) && !key_found){\n            guint8 rsn_id;\n            guint32 type;\n\n            /* Get RSN ID */\n            rsn_id = decrypted_data[key_index];\n            type = ((decrypted_data[key_index + 2] << 24) +\n                    (decrypted_data[key_index + 3] << 16) +\n                    (decrypted_data[key_index + 4] << 8) +\n                     (decrypted_data[key_index + 5]));\n\n            if (rsn_id == 0xdd && type == 0x000fac01) {\n                key_found = TRUE;\n            } else {\n                key_index += decrypted_data[key_index+1]+2;\n            }\n        }\n\n        if (key_found){\n            key_length = decrypted_data[key_index+1] - 6;\n\n            if (key_index+8 >= key_bytes_len ||\n                key_length > key_bytes_len - key_index - 8) {\n                g_free(decrypted_data);\n                g_free(szEncryptedKey);\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n\n            /* Skip over the GTK header info, and don't copy past the end of the encrypted data */\n            memcpy(szEncryptedKey, decrypted_data+key_index+8, key_length);\n        } else {\n            g_free(decrypted_data);\n            g_free(szEncryptedKey);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        if (key_length == TKIP_GROUP_KEY_LEN)\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP;\n        else\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n\n        g_free(decrypted_data);\n    }\n\n    key_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;\n    if (key_len > key_bytes_len) {\n        /* the key required for this protocol is longer than the key that we just calculated */\n        g_free(szEncryptedKey);\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Decrypted key is now in szEncryptedKey with len of key_len */\n    DEBUG_DUMP(\"Broadcast key:\", szEncryptedKey, key_len);\n\n    /* Load the proper key material info into the SA */\n    sa->key = &dummy_key;  /* we just need key to be not null because it is checked in AirPDcapRsnaMng().  The WPA key materials are actually in the .wpa structure */\n    sa->validKey = TRUE;\n\n    /* Since this is a GTK and its size is only 32 bytes (vs. the 64 byte size of a PTK), we fake it and put it in at a 32-byte offset so the  */\n    /* AirPDcapRsnaMng() function will extract the right piece of the GTK for decryption. (The first 16 bytes of the GTK are used for decryption.) */\n    memset(sa->wpa.ptk, 0, sizeof(sa->wpa.ptk));\n    memcpy(sa->wpa.ptk+32, szEncryptedKey, key_len);\n    g_free(szEncryptedKey);\n    return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n}", "func_src_after": "AirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, guint eapol_len)\n{\n    guint8 key_version;\n    guint8 *key_data;\n    guint8  *szEncryptedKey;\n    guint16 key_bytes_len = 0; /* Length of the total key data field */\n    guint16 key_len;           /* Actual group key length */\n    static AIRPDCAP_KEY_ITEM dummy_key; /* needed in case AirPDcapRsnaMng() wants the key structure */\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\n\n    /* We skip verifying the MIC of the key. If we were implementing a WPA supplicant we'd want to verify, but for a sniffer it's not needed. */\n\n    /* Preparation for decrypting the group key -  determine group key data length */\n    /* depending on whether the pairwise key is TKIP or AES encryption key */\n    key_version = AIRPDCAP_EAP_KEY_DESCR_VER(pEAPKey->key_information[1]);\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\n        /* TKIP */\n        key_bytes_len = pntoh16(pEAPKey->key_length);\n    }else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES */\n        key_bytes_len = pntoh16(pEAPKey->key_data_len);\n\n        /* AES keys must be at least 128 bits = 16 bytes. */\n        if (key_bytes_len < 16) {\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n    }\n\n    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\n        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\n        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Encrypted key is in the information element field of the EAPOL key packet */\n    key_data = (guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);\n    szEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);\n\n    DEBUG_DUMP(\"Encrypted Broadcast key:\", szEncryptedKey, key_bytes_len);\n    DEBUG_DUMP(\"KeyIV:\", pEAPKey->key_iv, 16);\n    DEBUG_DUMP(\"decryption_key:\", decryption_key, 16);\n\n    /* We are rekeying, save old sa */\n    tmp_sa=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));\n    memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n    sa->next=tmp_sa;\n\n    /* As we have no concept of the prior association request at this point, we need to deduce the     */\n    /* group key cipher from the length of the key bytes. In WPA this is straightforward as the        */\n    /* keybytes just contain the GTK, and the GTK is only in the group handshake, NOT the M3.          */\n    /* In WPA2 its a little more tricky as the M3 keybytes contain an RSN_IE, but the group handshake  */\n    /* does not. Also there are other (variable length) items in the keybytes which we need to account */\n    /* for to determine the true key length, and thus the group cipher.                                */\n\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\n        guint8 new_key[32];\n        guint8 dummy[256];\n        /* TKIP key */\n        /* Per 802.11i, Draft 3.0 spec, section 8.5.2, p. 97, line 4-8, */\n        /* group key is decrypted using RC4.  Concatenate the IV with the 16 byte EK (PTK+16) to get the decryption key */\n\n        rc4_state_struct rc4_state;\n\n        /* The WPA group key just contains the GTK bytes so deducing the type is straightforward   */\n        /* Note - WPA M3 doesn't contain a group key so we'll only be here for the group handshake */\n        sa->wpa.key_ver = (key_bytes_len >=TKIP_GROUP_KEY_LEN)?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n\n        /* Build the full decryption key based on the IV and part of the pairwise key */\n        memcpy(new_key, pEAPKey->key_iv, 16);\n        memcpy(new_key+16, decryption_key, 16);\n        DEBUG_DUMP(\"FullDecrKey:\", new_key, 32);\n\n        crypt_rc4_init(&rc4_state, new_key, sizeof(new_key));\n\n        /* Do dummy 256 iterations of the RC4 algorithm (per 802.11i, Draft 3.0, p. 97 line 6) */\n        crypt_rc4(&rc4_state, dummy, 256);\n        crypt_rc4(&rc4_state, szEncryptedKey, key_bytes_len);\n\n    } else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES CCMP key */\n\n        guint8 key_found;\n        guint8 key_length;\n        guint16 key_index;\n        guint8 *decrypted_data;\n\n        /* Unwrap the key; the result is key_bytes_len in length */\n        decrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey,  key_bytes_len);\n\n        /* With WPA2 what we get after Broadcast Key decryption is an actual RSN structure.\n           The key itself is stored as a GTK KDE\n           WPA2 IE (1 byte) id = 0xdd, length (1 byte), GTK OUI (4 bytes), key index (1 byte) and 1 reserved byte. Thus we have to\n           pass pointer to the actual key with 8 bytes offset */\n\n        key_found = FALSE;\n        key_index = 0;\n\n        /* Parse Key data until we found GTK KDE */\n        /* GTK KDE = 00-0F-AC 01 */\n        while(key_index < (key_bytes_len - 6) && !key_found){\n            guint8 rsn_id;\n            guint32 type;\n\n            /* Get RSN ID */\n            rsn_id = decrypted_data[key_index];\n            type = ((decrypted_data[key_index + 2] << 24) +\n                    (decrypted_data[key_index + 3] << 16) +\n                    (decrypted_data[key_index + 4] << 8) +\n                     (decrypted_data[key_index + 5]));\n\n            if (rsn_id == 0xdd && type == 0x000fac01) {\n                key_found = TRUE;\n            } else {\n                key_index += decrypted_data[key_index+1]+2;\n            }\n        }\n\n        if (key_found){\n            key_length = decrypted_data[key_index+1] - 6;\n\n            if (key_index+8 >= key_bytes_len ||\n                key_length > key_bytes_len - key_index - 8) {\n                g_free(decrypted_data);\n                g_free(szEncryptedKey);\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n\n            /* Skip over the GTK header info, and don't copy past the end of the encrypted data */\n            memcpy(szEncryptedKey, decrypted_data+key_index+8, key_length);\n        } else {\n            g_free(decrypted_data);\n            g_free(szEncryptedKey);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        if (key_length == TKIP_GROUP_KEY_LEN)\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP;\n        else\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n\n        g_free(decrypted_data);\n    }\n\n    key_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;\n    if (key_len > key_bytes_len) {\n        /* the key required for this protocol is longer than the key that we just calculated */\n        g_free(szEncryptedKey);\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Decrypted key is now in szEncryptedKey with len of key_len */\n    DEBUG_DUMP(\"Broadcast key:\", szEncryptedKey, key_len);\n\n    /* Load the proper key material info into the SA */\n    sa->key = &dummy_key;  /* we just need key to be not null because it is checked in AirPDcapRsnaMng().  The WPA key materials are actually in the .wpa structure */\n    sa->validKey = TRUE;\n\n    /* Since this is a GTK and its size is only 32 bytes (vs. the 64 byte size of a PTK), we fake it and put it in at a 32-byte offset so the  */\n    /* AirPDcapRsnaMng() function will extract the right piece of the GTK for decryption. (The first 16 bytes of the GTK are used for decryption.) */\n    memset(sa->wpa.ptk, 0, sizeof(sa->wpa.ptk));\n    memcpy(sa->wpa.ptk+32, szEncryptedKey, key_len);\n    g_free(szEncryptedKey);\n    return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n}", "line_changes": {"deleted": [{"line_no": 29, "char_start": 1297, "char_end": 1395, "line": "    if (key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY)) {\n"}], "added": [{"line_no": 29, "char_start": 1297, "char_end": 1344, "line": "    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\n"}, {"line_no": 30, "char_start": 1344, "char_end": 1391, "line": "        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\n"}, {"line_no": 31, "char_start": 1391, "char_end": 1454, "line": "        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1305, "char_end": 1306, "chars": "("}, {"char_start": 1339, "char_end": 1340, "chars": ")"}, {"char_start": 1343, "char_end": 1349, "chars": "\n     "}, {"char_start": 1350, "char_end": 1400, "chars": "  (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\n        ("}, {"char_start": 1448, "char_end": 1449, "chars": ")"}]}, "commit_link": "github.com/wireshark/wireshark/commit/b6d838eebf4456192360654092e5587c5207f185", "file_name": "epan/crypt/airpdcap.c", "vul_type": "cwe-125"}
{"func_name": "AdaptiveThresholdImage", "func_src_before": "MagickExport Image *AdaptiveThresholdImage(const Image *image,\n  const size_t width,const size_t height,const double bias,\n  ExceptionInfo *exception)\n{\n#define AdaptiveThresholdImageTag  \"AdaptiveThreshold/Image\"\n\n  CacheView\n    *image_view,\n    *threshold_view;\n\n  Image\n    *threshold_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickSizeType\n    number_pixels;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize threshold image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  threshold_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (threshold_image == (Image *) NULL)\n    return((Image *) NULL);\n  status=SetImageStorageClass(threshold_image,DirectClass,exception);\n  if (status == MagickFalse)\n    {\n      threshold_image=DestroyImage(threshold_image);\n      return((Image *) NULL);\n    }\n  /*\n    Threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  number_pixels=(MagickSizeType) width*height;\n  image_view=AcquireVirtualCacheView(image,exception);\n  threshold_view=AcquireAuthenticCacheView(threshold_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,threshold_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    double\n      channel_bias[MaxPixelChannels],\n      channel_sum[MaxPixelChannels];\n\n    register const Quantum\n      *magick_restrict p,\n      *magick_restrict pixels;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      i,\n      x;\n\n    ssize_t\n      center,\n      u,\n      v;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) width/2L),y-(ssize_t)\n      (height/2L),image->columns+width,height,exception);\n    q=QueueCacheViewAuthenticPixels(threshold_view,0,y,threshold_image->columns,\n      1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    center=(ssize_t) GetPixelChannels(image)*(image->columns+width)*(height/2L)+\n      GetPixelChannels(image)*(width/2);\n    for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n    {\n      PixelChannel channel = GetPixelChannelChannel(image,i);\n      PixelTrait traits = GetPixelChannelTraits(image,channel);\n      PixelTrait threshold_traits=GetPixelChannelTraits(threshold_image,\n        channel);\n      if ((traits == UndefinedPixelTrait) ||\n          (threshold_traits == UndefinedPixelTrait))\n        continue;\n      if ((threshold_traits & CopyPixelTrait) != 0)\n        {\n          SetPixelChannel(threshold_image,channel,p[center+i],q);\n          continue;\n        }\n      pixels=p;\n      channel_bias[channel]=0.0;\n      channel_sum[channel]=0.0;\n      for (v=0; v < (ssize_t) height; v++)\n      {\n        for (u=0; u < (ssize_t) width; u++)\n        {\n          if (u == (ssize_t) (width-1))\n            channel_bias[channel]+=pixels[i];\n          channel_sum[channel]+=pixels[i];\n          pixels+=GetPixelChannels(image);\n        }\n        pixels+=GetPixelChannels(image)*image->columns;\n      }\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        double\n          mean;\n\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        PixelTrait threshold_traits=GetPixelChannelTraits(threshold_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (threshold_traits == UndefinedPixelTrait))\n          continue;\n        if ((threshold_traits & CopyPixelTrait) != 0)\n          {\n            SetPixelChannel(threshold_image,channel,p[center+i],q);\n            continue;\n          }\n        channel_sum[channel]-=channel_bias[channel];\n        channel_bias[channel]=0.0;\n        pixels=p;\n        for (v=0; v < (ssize_t) height; v++)\n        {\n          channel_bias[channel]+=pixels[i];\n          pixels+=(width-1)*GetPixelChannels(image);\n          channel_sum[channel]+=pixels[i];\n          pixels+=GetPixelChannels(image)*(image->columns+1);\n        }\n        mean=(double) (channel_sum[channel]/number_pixels+bias);\n        SetPixelChannel(threshold_image,channel,(Quantum) ((double)\n          p[center+i] <= mean ? 0 : QuantumRange),q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(threshold_image);\n    }\n    if (SyncCacheViewAuthenticPixels(threshold_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,AdaptiveThresholdImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  threshold_image->type=image->type;\n  threshold_view=DestroyCacheView(threshold_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    threshold_image=DestroyImage(threshold_image);\n  return(threshold_image);\n}", "func_src_after": "MagickExport Image *AdaptiveThresholdImage(const Image *image,\n  const size_t width,const size_t height,const double bias,\n  ExceptionInfo *exception)\n{\n#define AdaptiveThresholdImageTag  \"AdaptiveThreshold/Image\"\n\n  CacheView\n    *image_view,\n    *threshold_view;\n\n  Image\n    *threshold_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickSizeType\n    number_pixels;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize threshold image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  threshold_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (threshold_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (width == 0)\n    return(threshold_image);\n  status=SetImageStorageClass(threshold_image,DirectClass,exception);\n  if (status == MagickFalse)\n    {\n      threshold_image=DestroyImage(threshold_image);\n      return((Image *) NULL);\n    }\n  /*\n    Threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  number_pixels=(MagickSizeType) width*height;\n  image_view=AcquireVirtualCacheView(image,exception);\n  threshold_view=AcquireAuthenticCacheView(threshold_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,threshold_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    double\n      channel_bias[MaxPixelChannels],\n      channel_sum[MaxPixelChannels];\n\n    register const Quantum\n      *magick_restrict p,\n      *magick_restrict pixels;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      i,\n      x;\n\n    ssize_t\n      center,\n      u,\n      v;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) width/2L),y-(ssize_t)\n      (height/2L),image->columns+width,height,exception);\n    q=QueueCacheViewAuthenticPixels(threshold_view,0,y,threshold_image->columns,\n      1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    center=(ssize_t) GetPixelChannels(image)*(image->columns+width)*(height/2L)+\n      GetPixelChannels(image)*(width/2);\n    for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n    {\n      PixelChannel channel = GetPixelChannelChannel(image,i);\n      PixelTrait traits = GetPixelChannelTraits(image,channel);\n      PixelTrait threshold_traits=GetPixelChannelTraits(threshold_image,\n        channel);\n      if ((traits == UndefinedPixelTrait) ||\n          (threshold_traits == UndefinedPixelTrait))\n        continue;\n      if ((threshold_traits & CopyPixelTrait) != 0)\n        {\n          SetPixelChannel(threshold_image,channel,p[center+i],q);\n          continue;\n        }\n      pixels=p;\n      channel_bias[channel]=0.0;\n      channel_sum[channel]=0.0;\n      for (v=0; v < (ssize_t) height; v++)\n      {\n        for (u=0; u < (ssize_t) width; u++)\n        {\n          if (u == (ssize_t) (width-1))\n            channel_bias[channel]+=pixels[i];\n          channel_sum[channel]+=pixels[i];\n          pixels+=GetPixelChannels(image);\n        }\n        pixels+=GetPixelChannels(image)*image->columns;\n      }\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        double\n          mean;\n\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        PixelTrait threshold_traits=GetPixelChannelTraits(threshold_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (threshold_traits == UndefinedPixelTrait))\n          continue;\n        if ((threshold_traits & CopyPixelTrait) != 0)\n          {\n            SetPixelChannel(threshold_image,channel,p[center+i],q);\n            continue;\n          }\n        channel_sum[channel]-=channel_bias[channel];\n        channel_bias[channel]=0.0;\n        pixels=p;\n        for (v=0; v < (ssize_t) height; v++)\n        {\n          channel_bias[channel]+=pixels[i];\n          pixels+=(width-1)*GetPixelChannels(image);\n          channel_sum[channel]+=pixels[i];\n          pixels+=GetPixelChannels(image)*(image->columns+1);\n        }\n        mean=(double) (channel_sum[channel]/number_pixels+bias);\n        SetPixelChannel(threshold_image,channel,(Quantum) ((double)\n          p[center+i] <= mean ? 0 : QuantumRange),q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(threshold_image);\n    }\n    if (SyncCacheViewAuthenticPixels(threshold_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,AdaptiveThresholdImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  threshold_image->type=image->type;\n  threshold_view=DestroyCacheView(threshold_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    threshold_image=DestroyImage(threshold_image);\n  return(threshold_image);\n}", "line_changes": {"deleted": [], "added": [{"line_no": 38, "char_start": 904, "char_end": 922, "line": "  if (width == 0)\n"}, {"line_no": 39, "char_start": 922, "char_end": 951, "line": "    return(threshold_image);\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 906, "char_end": 953, "chars": "if (width == 0)\n    return(threshold_image);\n  "}]}, "commit_link": "github.com/ImageMagick/ImageMagick/commit/a7759f410b773a1dd57b0e1fb28112e1cd8b97bc", "file_name": "MagickCore/threshold.c", "vul_type": "cwe-125"}
{"func_name": "INST_HANDLER", "func_src_before": "INST_HANDLER (lds) {\t// LDS Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\t// load value from RAMPD:k\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}", "func_src_after": "INST_HANDLER (lds) {\t// LDS Rd, k\n\tif (len < 4) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\t// load value from RAMPD:k\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}", "line_changes": {"deleted": [], "added": [{"line_no": 2, "char_start": 34, "char_end": 50, "line": "\tif (len < 4) {\n"}, {"line_no": 3, "char_start": 50, "char_end": 60, "line": "\t\treturn;\n"}, {"line_no": 4, "char_start": 60, "char_end": 63, "line": "\t}\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 36, "char_end": 65, "chars": "f (len < 4) {\n\t\treturn;\n\t}\n\ti"}]}, "commit_link": "github.com/radare/radare2/commit/041e53cab7ca33481ae45ecd65ad596976d78e68", "file_name": "libr/anal/p/anal_avr.c", "vul_type": "cwe-125"}
{"func_name": "jpeg_size", "func_src_before": "static int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                    return 0;\n                }\n                i+=2;\n                block_length = data[i] * 256 + data[i+1];\n            }\n        }\n    }\n\n    return -1;\n}", "func_src_after": "static int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                    return 0;\n                }\n                i+=2;\n                if (i + 1 < data_size)\n                    block_length = data[i] * 256 + data[i+1];\n            }\n        }\n    }\n\n    return -1;\n}", "line_changes": {"deleted": [{"line_no": 24, "char_start": 930, "char_end": 988, "line": "                block_length = data[i] * 256 + data[i+1];\n"}], "added": [{"line_no": 24, "char_start": 930, "char_end": 969, "line": "                if (i + 1 < data_size)\n"}, {"line_no": 25, "char_start": 969, "char_end": 1031, "line": "                    block_length = data[i] * 256 + data[i+1];\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 946, "char_end": 989, "chars": "if (i + 1 < data_size)\n                    "}]}, "commit_link": "github.com/AndreRenaud/PDFGen/commit/ee58aff6918b8bbc3be29b9e3089485ea46ff956", "file_name": "pdfgen.c", "vul_type": "cwe-125"}
{"func_name": "RLEDECOMPRESS", "func_src_before": "static INLINE BOOL RLEDECOMPRESS(const BYTE* pbSrcBuffer, UINT32 cbSrcBuffer, BYTE* pbDestBuffer,\n                                 UINT32 rowDelta, UINT32 width, UINT32 height)\n{\n\tconst BYTE* pbSrc = pbSrcBuffer;\n\tconst BYTE* pbEnd;\n\tconst BYTE* pbDestEnd;\n\tBYTE* pbDest = pbDestBuffer;\n\tPIXEL temp;\n\tPIXEL fgPel = WHITE_PIXEL;\n\tBOOL fInsertFgPel = FALSE;\n\tBOOL fFirstLine = TRUE;\n\tBYTE bitmask;\n\tPIXEL pixelA, pixelB;\n\tUINT32 runLength;\n\tUINT32 code;\n\tUINT32 advance;\n\tRLEEXTRA\n\n\tif ((rowDelta == 0) || (rowDelta < width))\n\t\treturn FALSE;\n\n\tif (!pbSrcBuffer || !pbDestBuffer)\n\t\treturn FALSE;\n\n\tpbEnd = pbSrcBuffer + cbSrcBuffer;\n\tpbDestEnd = pbDestBuffer + rowDelta * height;\n\n\twhile (pbSrc < pbEnd)\n\t{\n\t\t/* Watch out for the end of the first scanline. */\n\t\tif (fFirstLine)\n\t\t{\n\t\t\tif ((UINT32)(pbDest - pbDestBuffer) >= rowDelta)\n\t\t\t{\n\t\t\t\tfFirstLine = FALSE;\n\t\t\t\tfInsertFgPel = FALSE;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t   Extract the compression order code ID from the compression\n\t\t   order header.\n\t\t*/\n\t\tcode = ExtractCodeId(*pbSrc);\n\n\t\t/* Handle Background Run Orders. */\n\t\tif (code == REGULAR_BG_RUN || code == MEGA_MEGA_BG_RUN)\n\t\t{\n\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\tpbSrc = pbSrc + advance;\n\n\t\t\tif (fFirstLine)\n\t\t\t{\n\t\t\t\tif (fInsertFgPel)\n\t\t\t\t{\n\t\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, fgPel);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\trunLength = runLength - 1;\n\t\t\t\t}\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, BLACK_PIXEL);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (fInsertFgPel)\n\t\t\t\t{\n\t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n\n\t\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp ^ fgPel);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\trunLength--;\n\t\t\t\t}\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* A follow-on background run order will need a foreground pel inserted. */\n\t\t\tfInsertFgPel = TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* For any of the other run-types a follow-on background run\n\t\t    order does not need a foreground pel inserted. */\n\t\tfInsertFgPel = FALSE;\n\n\t\tswitch (code)\n\t\t{\n\t\t\t/* Handle Foreground Run Orders. */\n\t\t\tcase REGULAR_FG_RUN:\n\t\t\tcase MEGA_MEGA_FG_RUN:\n\t\t\tcase LITE_SET_FG_FG_RUN:\n\t\t\tcase MEGA_MEGA_SET_FG_RUN:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\n\t\t\t\tif (code == LITE_SET_FG_FG_RUN || code == MEGA_MEGA_SET_FG_RUN)\n\t\t\t\t{\n\t\t\t\t\tSRCREADPIXEL(fgPel, pbSrc);\n\t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\t}\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\t\tDESTWRITEPIXEL(pbDest, fgPel);\n\t\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n\t\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp ^ fgPel);\n\t\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Dithered Run Orders. */\n\t\t\tcase LITE_DITHERED_RUN:\n\t\t\tcase MEGA_MEGA_DITHERED_RUN:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\t\t\t\tSRCREADPIXEL(pixelA, pbSrc);\n\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\tSRCREADPIXEL(pixelB, pbSrc);\n\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength * 2))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelA);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelB);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Color Run Orders. */\n\t\t\tcase REGULAR_COLOR_RUN:\n\t\t\tcase MEGA_MEGA_COLOR_RUN:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\t\t\t\tSRCREADPIXEL(pixelA, pbSrc);\n\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelA);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Foreground/Background Image Orders. */\n\t\t\tcase REGULAR_FGBG_IMAGE:\n\t\t\tcase MEGA_MEGA_FGBG_IMAGE:\n\t\t\tcase LITE_SET_FG_FGBG_IMAGE:\n\t\t\tcase MEGA_MEGA_SET_FGBG_IMAGE:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\n\t\t\t\tif (code == LITE_SET_FG_FGBG_IMAGE || code == MEGA_MEGA_SET_FGBG_IMAGE)\n\t\t\t\t{\n\t\t\t\t\tSRCREADPIXEL(fgPel, pbSrc);\n\t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\t}\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\twhile (runLength > 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tbitmask = *pbSrc;\n\t\t\t\t\t\tpbSrc = pbSrc + 1;\n\t\t\t\t\t\tpbDest = WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, bitmask, fgPel, 8);\n\n\t\t\t\t\t\tif (!pbDest)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\trunLength = runLength - 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile (runLength > 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tbitmask = *pbSrc;\n\t\t\t\t\t\tpbSrc = pbSrc + 1;\n\t\t\t\t\t\tpbDest = WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, bitmask, fgPel, 8);\n\n\t\t\t\t\t\tif (!pbDest)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\trunLength = runLength - 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (runLength > 0)\n\t\t\t\t{\n\t\t\t\t\tbitmask = *pbSrc;\n\t\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\t\tif (fFirstLine)\n\t\t\t\t\t{\n\t\t\t\t\t\tpbDest =\n\t\t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, bitmask, fgPel, runLength);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpbDest =\n\t\t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, bitmask, fgPel, runLength);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!pbDest)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Color Image Orders. */\n\t\t\tcase REGULAR_COLOR_IMAGE:\n\t\t\tcase MEGA_MEGA_COLOR_IMAGE:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tSRCREADPIXEL(temp, pbSrc);\n\t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Special Order 1. */\n\t\t\tcase SPECIAL_FGBG_1:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, g_MaskSpecialFgBg1, fgPel, 8);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, g_MaskSpecialFgBg1, fgPel, 8);\n\t\t\t\t}\n\n\t\t\t\tif (!pbDest)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Special Order 2. */\n\t\t\tcase SPECIAL_FGBG_2:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, g_MaskSpecialFgBg2, fgPel, 8);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, g_MaskSpecialFgBg2, fgPel, 8);\n\t\t\t\t}\n\n\t\t\t\tif (!pbDest)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\t/* Handle White Order. */\n\t\t\tcase SPECIAL_WHITE:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tDESTWRITEPIXEL(pbDest, WHITE_PIXEL);\n\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Black Order. */\n\t\t\tcase SPECIAL_BLACK:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tDESTWRITEPIXEL(pbDest, BLACK_PIXEL);\n\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}", "func_src_after": "static INLINE BOOL RLEDECOMPRESS(const BYTE* pbSrcBuffer, UINT32 cbSrcBuffer, BYTE* pbDestBuffer,\n                                 UINT32 rowDelta, UINT32 width, UINT32 height)\n{\n\tconst BYTE* pbSrc = pbSrcBuffer;\n\tconst BYTE* pbEnd;\n\tconst BYTE* pbDestEnd;\n\tBYTE* pbDest = pbDestBuffer;\n\tPIXEL temp;\n\tPIXEL fgPel = WHITE_PIXEL;\n\tBOOL fInsertFgPel = FALSE;\n\tBOOL fFirstLine = TRUE;\n\tBYTE bitmask;\n\tPIXEL pixelA, pixelB;\n\tUINT32 runLength;\n\tUINT32 code;\n\tUINT32 advance;\n\tRLEEXTRA\n\n\tif ((rowDelta == 0) || (rowDelta < width))\n\t\treturn FALSE;\n\n\tif (!pbSrcBuffer || !pbDestBuffer)\n\t\treturn FALSE;\n\n\tpbEnd = pbSrcBuffer + cbSrcBuffer;\n\tpbDestEnd = pbDestBuffer + rowDelta * height;\n\n\twhile (pbSrc < pbEnd)\n\t{\n\t\t/* Watch out for the end of the first scanline. */\n\t\tif (fFirstLine)\n\t\t{\n\t\t\tif ((UINT32)(pbDest - pbDestBuffer) >= rowDelta)\n\t\t\t{\n\t\t\t\tfFirstLine = FALSE;\n\t\t\t\tfInsertFgPel = FALSE;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t   Extract the compression order code ID from the compression\n\t\t   order header.\n\t\t*/\n\t\tcode = ExtractCodeId(*pbSrc);\n\n\t\t/* Handle Background Run Orders. */\n\t\tif (code == REGULAR_BG_RUN || code == MEGA_MEGA_BG_RUN)\n\t\t{\n\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\tpbSrc = pbSrc + advance;\n\n\t\t\tif (fFirstLine)\n\t\t\t{\n\t\t\t\tif (fInsertFgPel)\n\t\t\t\t{\n\t\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, fgPel);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\trunLength = runLength - 1;\n\t\t\t\t}\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, BLACK_PIXEL);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (fInsertFgPel)\n\t\t\t\t{\n\t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n\n\t\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp ^ fgPel);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\trunLength--;\n\t\t\t\t}\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* A follow-on background run order will need a foreground pel inserted. */\n\t\t\tfInsertFgPel = TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* For any of the other run-types a follow-on background run\n\t\t    order does not need a foreground pel inserted. */\n\t\tfInsertFgPel = FALSE;\n\n\t\tswitch (code)\n\t\t{\n\t\t\t/* Handle Foreground Run Orders. */\n\t\t\tcase REGULAR_FG_RUN:\n\t\t\tcase MEGA_MEGA_FG_RUN:\n\t\t\tcase LITE_SET_FG_FG_RUN:\n\t\t\tcase MEGA_MEGA_SET_FG_RUN:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\n\t\t\t\tif (code == LITE_SET_FG_FG_RUN || code == MEGA_MEGA_SET_FG_RUN)\n\t\t\t\t{\n\t\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\tSRCREADPIXEL(fgPel, pbSrc);\n\t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\t}\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\t\tDESTWRITEPIXEL(pbDest, fgPel);\n\t\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n\t\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp ^ fgPel);\n\t\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Dithered Run Orders. */\n\t\t\tcase LITE_DITHERED_RUN:\n\t\t\tcase MEGA_MEGA_DITHERED_RUN:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tSRCREADPIXEL(pixelA, pbSrc);\n\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tSRCREADPIXEL(pixelB, pbSrc);\n\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength * 2))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelA);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelB);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Color Run Orders. */\n\t\t\tcase REGULAR_COLOR_RUN:\n\t\t\tcase MEGA_MEGA_COLOR_RUN:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tSRCREADPIXEL(pixelA, pbSrc);\n\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelA);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Foreground/Background Image Orders. */\n\t\t\tcase REGULAR_FGBG_IMAGE:\n\t\t\tcase MEGA_MEGA_FGBG_IMAGE:\n\t\t\tcase LITE_SET_FG_FGBG_IMAGE:\n\t\t\tcase MEGA_MEGA_SET_FGBG_IMAGE:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\n\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tif (code == LITE_SET_FG_FGBG_IMAGE || code == MEGA_MEGA_SET_FGBG_IMAGE)\n\t\t\t\t{\n\t\t\t\t\tSRCREADPIXEL(fgPel, pbSrc);\n\t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\t}\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\twhile (runLength > 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tbitmask = *pbSrc;\n\t\t\t\t\t\tpbSrc = pbSrc + 1;\n\t\t\t\t\t\tpbDest = WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, bitmask, fgPel, 8);\n\n\t\t\t\t\t\tif (!pbDest)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\trunLength = runLength - 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile (runLength > 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tbitmask = *pbSrc;\n\t\t\t\t\t\tpbSrc = pbSrc + 1;\n\t\t\t\t\t\tpbDest = WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, bitmask, fgPel, 8);\n\n\t\t\t\t\t\tif (!pbDest)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\trunLength = runLength - 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (runLength > 0)\n\t\t\t\t{\n\t\t\t\t\tbitmask = *pbSrc;\n\t\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\t\tif (fFirstLine)\n\t\t\t\t\t{\n\t\t\t\t\t\tpbDest =\n\t\t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, bitmask, fgPel, runLength);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpbDest =\n\t\t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, bitmask, fgPel, runLength);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!pbDest)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Color Image Orders. */\n\t\t\tcase REGULAR_COLOR_IMAGE:\n\t\t\tcase MEGA_MEGA_COLOR_IMAGE:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\tSRCREADPIXEL(temp, pbSrc);\n\t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Special Order 1. */\n\t\t\tcase SPECIAL_FGBG_1:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, g_MaskSpecialFgBg1, fgPel, 8);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, g_MaskSpecialFgBg1, fgPel, 8);\n\t\t\t\t}\n\n\t\t\t\tif (!pbDest)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Special Order 2. */\n\t\t\tcase SPECIAL_FGBG_2:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, g_MaskSpecialFgBg2, fgPel, 8);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, g_MaskSpecialFgBg2, fgPel, 8);\n\t\t\t\t}\n\n\t\t\t\tif (!pbDest)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\t/* Handle White Order. */\n\t\t\tcase SPECIAL_WHITE:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tDESTWRITEPIXEL(pbDest, WHITE_PIXEL);\n\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Black Order. */\n\t\t\tcase SPECIAL_BLACK:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tDESTWRITEPIXEL(pbDest, BLACK_PIXEL);\n\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 117, "char_start": 2683, "char_end": 2708, "line": "\t\t\t\t\tif (pbSrc >= pbEnd)\n"}, {"line_no": 118, "char_start": 2708, "char_end": 2728, "line": "\t\t\t\t\t\treturn FALSE;\n"}, {"line_no": 149, "char_start": 3371, "char_end": 3395, "line": "\t\t\t\tif (pbSrc >= pbEnd)\n"}, {"line_no": 150, "char_start": 3395, "char_end": 3414, "line": "\t\t\t\t\treturn FALSE;\n"}, {"line_no": 153, "char_start": 3472, "char_end": 3496, "line": "\t\t\t\tif (pbSrc >= pbEnd)\n"}, {"line_no": 154, "char_start": 3496, "char_end": 3515, "line": "\t\t\t\t\treturn FALSE;\n"}, {"line_no": 174, "char_start": 4004, "char_end": 4028, "line": "\t\t\t\tif (pbSrc >= pbEnd)\n"}, {"line_no": 175, "char_start": 4028, "char_end": 4047, "line": "\t\t\t\t\treturn FALSE;\n"}, {"line_no": 196, "char_start": 4554, "char_end": 4578, "line": "\t\t\t\tif (pbSrc >= pbEnd)\n"}, {"line_no": 197, "char_start": 4578, "char_end": 4597, "line": "\t\t\t\t\treturn FALSE;\n"}, {"line_no": 264, "char_start": 5955, "char_end": 5980, "line": "\t\t\t\t\tif (pbSrc >= pbEnd)\n"}, {"line_no": 265, "char_start": 5980, "char_end": 6000, "line": "\t\t\t\t\t\treturn FALSE;\n"}]}, "char_changes": {"deleted": [{"char_start": 2716, "char_end": 2716, "chars": ""}, {"char_start": 5714, "char_end": 5714, "chars": ""}], "added": [{"char_start": 2688, "char_end": 2733, "chars": "if (pbSrc >= pbEnd)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t"}, {"char_start": 3371, "char_end": 3414, "chars": "\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\treturn FALSE;\n"}, {"char_start": 3472, "char_end": 3515, "chars": "\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\treturn FALSE;\n"}, {"char_start": 4004, "char_end": 4047, "chars": "\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\treturn FALSE;\n"}, {"char_start": 4554, "char_end": 4597, "chars": "\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\treturn FALSE;\n"}, {"char_start": 5954, "char_end": 5999, "chars": "\n\t\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\t\treturn FALSE;"}]}, "commit_link": "github.com/FreeRDP/FreeRDP/commit/0a98c450c58ec150e44781c89aa6f8e7e0f571f5", "file_name": "libfreerdp/codec/include/bitmap.c", "vul_type": "cwe-125"}
{"func_name": "jp2_decode", "func_src_before": "jas_image_t *jp2_decode(jas_stream_t *in, const char *optstr)\n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tJAS_DBGLOG(100, (\"jp2_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"warning: component data type mismatch (IHDR)\\n\");\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch (BPCC)\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tif (!dec->image->cmprof_) {\n\t\t\tjas_iccprof_destroy(iccprof);\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n\t  sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tif (!pclrd->numlutents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n\t\t\t\tif (!lutents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,\n\t\t\t\t  pclrd->numlutents, lutents,\n\t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#else\n\t\t\t\t/* suppress -Wunused-but-set-variable */\n\t\t\t\t(void)cdefd;\n#endif\n\t\t\t} else {\n\t\t\t\tjas_eprintf(\"error: invalid MTYP in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Ensure that the number of channels being used by the decoder\n\t  matches the number of image components. */\n\tif (dec->numchans != jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: mismatch in number of components (%d != %d)\\n\",\n\t\t  dec->numchans, jas_image_numcmpts(dec->image));\n\t\tgoto error;\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->cdef->data.cdef.numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image,\n\t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type,\n\t\t\t  dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}", "func_src_after": "jas_image_t *jp2_decode(jas_stream_t *in, const char *optstr)\n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tJAS_DBGLOG(100, (\"jp2_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"error: number of components mismatch (IHDR)\\n\");\n\t\tgoto error;\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"error: component data type mismatch (IHDR)\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts !=\n\t\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image))) {\n\t\t\tjas_eprintf(\"error: number of components mismatch (BPCC)\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"error: component data type mismatch (BPCC)\\n\");\n\t\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tif (!dec->image->cmprof_) {\n\t\t\tjas_iccprof_destroy(iccprof);\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n\t  sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tif (!pclrd->numlutents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n\t\t\t\tif (!lutents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,\n\t\t\t\t  pclrd->numlutents, lutents,\n\t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#else\n\t\t\t\t/* suppress -Wunused-but-set-variable */\n\t\t\t\t(void)cdefd;\n#endif\n\t\t\t} else {\n\t\t\t\tjas_eprintf(\"error: invalid MTYP in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Ensure that the number of channels being used by the decoder\n\t  matches the number of image components. */\n\tif (dec->numchans != jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: mismatch in number of components (%d != %d)\\n\",\n\t\t  dec->numchans, jas_image_numcmpts(dec->image));\n\t\tgoto error;\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->cdef->data.cdef.numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image,\n\t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type,\n\t\t\t  dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}", "line_changes": {"deleted": [{"line_no": 137, "char_start": 2575, "char_end": 2634, "line": "\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n"}, {"line_no": 160, "char_start": 3325, "char_end": 3390, "line": "\t\tjas_eprintf(\"warning: component data type mismatch (IHDR)\\n\");\n"}, {"line_no": 172, "char_start": 3691, "char_end": 3769, "line": "\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(\n"}, {"line_no": 173, "char_start": 3769, "char_end": 3789, "line": "\t\t  dec->image))) {\n"}, {"line_no": 174, "char_start": 3789, "char_end": 3849, "line": "\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n"}, {"line_no": 183, "char_start": 4171, "char_end": 4239, "line": "\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch (BPCC)\\n\");\n"}], "added": [{"line_no": 137, "char_start": 2575, "char_end": 2639, "line": "\t\tjas_eprintf(\"error: number of components mismatch (IHDR)\\n\");\n"}, {"line_no": 138, "char_start": 2639, "char_end": 2653, "line": "\t\tgoto error;\n"}, {"line_no": 161, "char_start": 3344, "char_end": 3407, "line": "\t\tjas_eprintf(\"error: component data type mismatch (IHDR)\\n\");\n"}, {"line_no": 162, "char_start": 3407, "char_end": 3421, "line": "\t\tgoto error;\n"}, {"line_no": 174, "char_start": 3722, "char_end": 3761, "line": "\t\tif (dec->bpcc->data.bpcc.numcmpts !=\n"}, {"line_no": 175, "char_start": 3761, "char_end": 3819, "line": "\t\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image))) {\n"}, {"line_no": 176, "char_start": 3819, "char_end": 3884, "line": "\t\t\tjas_eprintf(\"error: number of components mismatch (BPCC)\\n\");\n"}, {"line_no": 177, "char_start": 3884, "char_end": 3899, "line": "\t\t\tgoto error;\n"}, {"line_no": 186, "char_start": 4221, "char_end": 4287, "line": "\t\t\t\t\tjas_eprintf(\"error: component data type mismatch (BPCC)\\n\");\n"}, {"line_no": 187, "char_start": 4287, "char_end": 4305, "line": "\t\t\t\t\t\tgoto error;\n"}]}, "char_changes": {"deleted": [{"char_start": 2590, "char_end": 2592, "chars": "wa"}, {"char_start": 2593, "char_end": 2597, "chars": "ning"}, {"char_start": 3340, "char_end": 3342, "chars": "wa"}, {"char_start": 3343, "char_end": 3347, "chars": "ning"}, {"char_start": 3768, "char_end": 3773, "chars": "\n\t\t  "}, {"char_start": 3805, "char_end": 3807, "chars": "wa"}, {"char_start": 3808, "char_end": 3812, "chars": "ning"}, {"char_start": 4189, "char_end": 4191, "chars": "wa"}, {"char_start": 4192, "char_end": 4196, "chars": "ning"}], "added": [{"char_start": 2590, "char_end": 2594, "chars": "erro"}, {"char_start": 2626, "char_end": 2633, "chars": " (IHDR)"}, {"char_start": 2639, "char_end": 2653, "chars": "\t\tgoto error;\n"}, {"char_start": 3359, "char_end": 3363, "chars": "erro"}, {"char_start": 3407, "char_end": 3421, "chars": "\t\tgoto error;\n"}, {"char_start": 3760, "char_end": 3764, "chars": "\n\t\t "}, {"char_start": 3835, "char_end": 3839, "chars": "erro"}, {"char_start": 3871, "char_end": 3878, "chars": " (BPCC)"}, {"char_start": 3884, "char_end": 3899, "chars": "\t\t\tgoto error;\n"}, {"char_start": 4239, "char_end": 4243, "chars": "erro"}, {"char_start": 4285, "char_end": 4303, "chars": ";\n\t\t\t\t\t\tgoto error"}]}, "commit_link": "github.com/jasper-software/jasper/commit/41f214b121b837fa30d9ca5f2430212110f5cd9b", "file_name": "src/libjasper/jp2/jp2_dec.c", "vul_type": "cwe-125"}
{"func_name": "get_conn_text", "func_src_before": "static inline void get_conn_text(const conn *c, const int af,\n                char* addr, struct sockaddr *sock_addr) {\n    char addr_text[MAXPATHLEN];\n    addr_text[0] = '\\0';\n    const char *protoname = \"?\";\n    unsigned short port = 0;\n\n    switch (af) {\n        case AF_INET:\n            (void) inet_ntop(af,\n                    &((struct sockaddr_in *)sock_addr)->sin_addr,\n                    addr_text,\n                    sizeof(addr_text) - 1);\n            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);\n            protoname = IS_UDP(c->transport) ? \"udp\" : \"tcp\";\n            break;\n\n        case AF_INET6:\n            addr_text[0] = '[';\n            addr_text[1] = '\\0';\n            if (inet_ntop(af,\n                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,\n                    addr_text + 1,\n                    sizeof(addr_text) - 2)) {\n                strcat(addr_text, \"]\");\n            }\n            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);\n            protoname = IS_UDP(c->transport) ? \"udp6\" : \"tcp6\";\n            break;\n\n        case AF_UNIX:\n            strncpy(addr_text,\n                    ((struct sockaddr_un *)sock_addr)->sun_path,\n                    sizeof(addr_text) - 1);\n            addr_text[sizeof(addr_text)-1] = '\\0';\n            protoname = \"unix\";\n            break;\n    }\n\n    if (strlen(addr_text) < 2) {\n        /* Most likely this is a connected UNIX-domain client which\n         * has no peer socket address, but there's no portable way\n         * to tell for sure.\n         */\n        sprintf(addr_text, \"<AF %d>\", af);\n    }\n\n    if (port) {\n        sprintf(addr, \"%s:%s:%u\", protoname, addr_text, port);\n    } else {\n        sprintf(addr, \"%s:%s\", protoname, addr_text);\n    }\n}", "func_src_after": "static inline void get_conn_text(const conn *c, const int af,\n                char* addr, struct sockaddr *sock_addr) {\n    char addr_text[MAXPATHLEN];\n    addr_text[0] = '\\0';\n    const char *protoname = \"?\";\n    unsigned short port = 0;\n    size_t pathlen = 0;\n\n    switch (af) {\n        case AF_INET:\n            (void) inet_ntop(af,\n                    &((struct sockaddr_in *)sock_addr)->sin_addr,\n                    addr_text,\n                    sizeof(addr_text) - 1);\n            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);\n            protoname = IS_UDP(c->transport) ? \"udp\" : \"tcp\";\n            break;\n\n        case AF_INET6:\n            addr_text[0] = '[';\n            addr_text[1] = '\\0';\n            if (inet_ntop(af,\n                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,\n                    addr_text + 1,\n                    sizeof(addr_text) - 2)) {\n                strcat(addr_text, \"]\");\n            }\n            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);\n            protoname = IS_UDP(c->transport) ? \"udp6\" : \"tcp6\";\n            break;\n\n        case AF_UNIX:\n            // this strncpy call originally could piss off an address\n            // sanitizer; we supplied the size of the dest buf as a limiter,\n            // but optimized versions of strncpy could read past the end of\n            // *src while looking for a null terminator. Since buf and\n            // sun_path here are both on the stack they could even overlap,\n            // which is \"undefined\". In all OSS versions of strncpy I could\n            // find this has no effect; it'll still only copy until the first null\n            // terminator is found. Thus it's possible to get the OS to\n            // examine past the end of sun_path but it's unclear to me if this\n            // can cause any actual problem.\n            //\n            // We need a safe_strncpy util function but I'll punt on figuring\n            // that out for now.\n            pathlen = sizeof(((struct sockaddr_un *)sock_addr)->sun_path);\n            if (MAXPATHLEN <= pathlen) {\n                pathlen = MAXPATHLEN - 1;\n            }\n            strncpy(addr_text,\n                    ((struct sockaddr_un *)sock_addr)->sun_path,\n                    pathlen);\n            addr_text[pathlen] = '\\0';\n            protoname = \"unix\";\n            break;\n    }\n\n    if (strlen(addr_text) < 2) {\n        /* Most likely this is a connected UNIX-domain client which\n         * has no peer socket address, but there's no portable way\n         * to tell for sure.\n         */\n        sprintf(addr_text, \"<AF %d>\", af);\n    }\n\n    if (port) {\n        sprintf(addr, \"%s:%s:%u\", protoname, addr_text, port);\n    } else {\n        sprintf(addr, \"%s:%s\", protoname, addr_text);\n    }\n}", "line_changes": {"deleted": [{"line_no": 34, "char_start": 1203, "char_end": 1247, "line": "                    sizeof(addr_text) - 1);\n"}, {"line_no": 35, "char_start": 1247, "char_end": 1298, "line": "            addr_text[sizeof(addr_text)-1] = '\\0';\n"}], "added": [{"line_no": 7, "char_start": 239, "char_end": 263, "line": "    size_t pathlen = 0;\n"}, {"line_no": 46, "char_start": 1982, "char_end": 2057, "line": "            pathlen = sizeof(((struct sockaddr_un *)sock_addr)->sun_path);\n"}, {"line_no": 47, "char_start": 2057, "char_end": 2098, "line": "            if (MAXPATHLEN <= pathlen) {\n"}, {"line_no": 48, "char_start": 2098, "char_end": 2140, "line": "                pathlen = MAXPATHLEN - 1;\n"}, {"line_no": 49, "char_start": 2140, "char_end": 2154, "line": "            }\n"}, {"line_no": 52, "char_start": 2250, "char_end": 2280, "line": "                    pathlen);\n"}, {"line_no": 53, "char_start": 2280, "char_end": 2319, "line": "            addr_text[pathlen] = '\\0';\n"}]}, "char_changes": {"deleted": [{"char_start": 1223, "char_end": 1230, "chars": "sizeof("}, {"char_start": 1231, "char_end": 1235, "chars": "ddr_"}, {"char_start": 1237, "char_end": 1244, "chars": "xt) - 1"}, {"char_start": 1269, "char_end": 1276, "chars": "sizeof("}, {"char_start": 1277, "char_end": 1281, "chars": "ddr_"}, {"char_start": 1283, "char_end": 1288, "chars": "xt)-1"}], "added": [{"char_start": 239, "char_end": 263, "chars": "    size_t pathlen = 0;\n"}, {"char_start": 1131, "char_end": 2154, "chars": "            // this strncpy call originally could piss off an address\n            // sanitizer; we supplied the size of the dest buf as a limiter,\n            // but optimized versions of strncpy could read past the end of\n            // *src while looking for a null terminator. Since buf and\n            // sun_path here are both on the stack they could even overlap,\n            // which is \"undefined\". In all OSS versions of strncpy I could\n            // find this has no effect; it'll still only copy until the first null\n            // terminator is found. Thus it's possible to get the OS to\n            // examine past the end of sun_path but it's unclear to me if this\n            // can cause any actual problem.\n            //\n            // We need a safe_strncpy util function but I'll punt on figuring\n            // that out for now.\n            pathlen = sizeof(((struct sockaddr_un *)sock_addr)->sun_path);\n            if (MAXPATHLEN <= pathlen) {\n                pathlen = MAXPATHLEN - 1;\n            }\n"}, {"char_start": 2270, "char_end": 2271, "chars": "p"}, {"char_start": 2273, "char_end": 2275, "chars": "hl"}, {"char_start": 2276, "char_end": 2277, "chars": "n"}, {"char_start": 2302, "char_end": 2303, "chars": "p"}, {"char_start": 2305, "char_end": 2307, "chars": "hl"}, {"char_start": 2308, "char_end": 2309, "chars": "n"}]}, "commit_link": "github.com/memcached/memcached/commit/554b56687a19300a75ec24184746b5512580c819", "file_name": "memcached.c", "vul_type": "cwe-125"}
{"func_name": "parse_sec_attr_44", "func_src_before": "static void parse_sec_attr_44(sc_file_t *file, const u8 *buf, size_t len)\n{\n\t/* OpenSc Operation values for each command operation-type */\n\tconst int df_idx[8] = {\t /* byte 1 = OpenSC type of AC Bit0,  byte 2 = OpenSC type of AC Bit1 ...*/\n\t\tSC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\tSC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};\n\tconst int ef_idx[8] = {\n\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\tconst int efi_idx[8] = { /* internal EF used for RSA keys */\n\t\tSC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\n\tu8\t\tbValue;\n\tint\t\ti;\n\tint\t\tiKeyRef = 0;\n\tint\t\tiMethod;\n\tint\t\tiPinCount;\n\tint\t\tiOffset = 0;\n\tint\t\tiOperation;\n\tconst int*\tp_idx;\n\n\t/* Check all sub-AC definitions within the total AC */\n\twhile (len > 1) {\t\t\t\t/* minimum length = 2 */\n\t\tsize_t iACLen   = buf[iOffset] & 0x0F;\n\t\tif (iACLen > len)\n\t\t\tbreak;\n\n\t\tiMethod = SC_AC_NONE;\t\t/* default no authentication required */\n\n\t\tif (buf[iOffset] & 0X80) { /* AC in adaptive coding */\n\t\t\t/* Evaluates only the command-byte, not the optional P1/P2/Option bytes */\n\t\t\tsize_t\tiParmLen = 1;\t\t\t/* command-byte is always present */\n\t\t\tsize_t\tiKeyLen  = 0;\t\t\t/* Encryption key is optional */\n\n\t\t\tif (buf[iOffset]   & 0x20) iKeyLen++;\n\t\t\tif (buf[iOffset+1] & 0x40) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x20) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x10) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x08) iParmLen++;\n\n\t\t\t/* Get KeyNumber if available */\n\t\t\tif(iKeyLen) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1+(size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset+iACLen];\n\n\t\t\t\tswitch( (iSC>>5) & 0x03 ){\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t/* key authentication */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tiMethod = SC_AC_AUT;\t\t/* key authentication  */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tiMethod = SC_AC_PRO;\t\t/* secure messaging */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiKeyRef = iSC & 0x1F;\t\t\t/* get key number */\n\t\t\t}\n\n\t\t\t/* Get PinNumber if available */\n\t\t\tif (iACLen > (1+iParmLen+iKeyLen)) {  /* check via total length if pin is present */\n\t\t\t\tif (len < 1+1+1+(size_t)iParmLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiKeyRef = buf[iOffset+1+1+iParmLen];  /* PTL + AM-header + parameter-bytes */\n\t\t\t\tiMethod = SC_AC_CHV;\n\t\t\t}\n\n\t\t\t/* Convert SETCOS command to OpenSC command group */\n\t\t\tif (len < 1+2)\n\t\t\t\tbreak;\n\t\t\tswitch(buf[iOffset+2]){\n\t\t\tcase 0x2A:\t\t\t/* crypto operation */\n\t\t\t\tiOperation = SC_AC_OP_CRYPTO;\n\t\t\t\tbreak;\n\t\t\tcase 0x46:\t\t\t/* key-generation operation */\n\t\t\t\tiOperation = SC_AC_OP_UPDATE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tiOperation = SC_AC_OP_SELECT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_file_add_acl_entry(file, iOperation, iMethod, iKeyRef);\n\t\t}\n\t\telse { /* AC in simple coding */\n\t\t\t   /* Initial AC is treated as an operational AC */\n\n\t\t\t/* Get specific Cmd groups for specified file-type */\n\t\t\tswitch (file->type) {\n\t\t\tcase SC_FILE_TYPE_DF:            /* DF */\n\t\t\t\tp_idx = df_idx;\n\t\t\t\tbreak;\n\t\t\tcase SC_FILE_TYPE_INTERNAL_EF:   /* EF for RSA keys */\n\t\t\t\tp_idx = efi_idx;\n\t\t\t\tbreak;\n\t\t\tdefault:                         /* EF */\n\t\t\t\tp_idx = ef_idx;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Encryption key present ? */\n\t\t\tiPinCount = iACLen - 1;\t\t\n\n\t\t\tif (buf[iOffset] & 0x20) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1 + (size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset + iACLen];\n\n\t\t\t\tswitch( (iSC>>5) & 0x03 ) {\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t/* key authentication */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tiMethod = SC_AC_AUT;\t\t/* key authentication  */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tiMethod = SC_AC_PRO;\t\t/* secure messaging */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiKeyRef = iSC & 0x1F;\t\t\t/* get key number */\n\n\t\t\t\tiPinCount--;\t\t\t\t/* one byte used for keyReference  */\n\t\t\t}\n\n\t\t\t/* Pin present ? */\n\t\t\tif ( iPinCount > 0 ) {\n\t\t\t\tif (len < 1 + 2)\n\t\t\t\t\tbreak;\n\t\t\t\tiKeyRef = buf[iOffset + 2];\t/* pin ref */\n\t\t\t\tiMethod = SC_AC_CHV;\n\t\t\t}\n\n\t\t\t/* Add AC for each command-operationType into OpenSc structure */\n\t\t\tbValue = buf[iOffset + 1];\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tif((bValue & 1) && (p_idx[i] >= 0))\n\t\t\t\t\tsc_file_add_acl_entry(file, p_idx[i], iMethod, iKeyRef);\n\t\t\t\tbValue >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Current field treated, get next AC sub-field */\n\t\tiOffset += iACLen +1;\t\t/* AC + PTL-byte */\n\t\tlen     -= iACLen +1;\n\t}\n}", "func_src_after": "static void parse_sec_attr_44(sc_file_t *file, const u8 *buf, size_t len)\n{\n\t/* OpenSc Operation values for each command operation-type */\n\tconst int df_idx[8] = {\t /* byte 1 = OpenSC type of AC Bit0,  byte 2 = OpenSC type of AC Bit1 ...*/\n\t\tSC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\tSC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};\n\tconst int ef_idx[8] = {\n\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\tconst int efi_idx[8] = { /* internal EF used for RSA keys */\n\t\tSC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\n\tu8\t\tbValue;\n\tint\t\ti;\n\tint\t\tiKeyRef = 0;\n\tint\t\tiMethod;\n\tint\t\tiPinCount;\n\tint\t\tiOffset = 0;\n\tint\t\tiOperation;\n\tconst int*\tp_idx;\n\n\t/* Check all sub-AC definitions within the total AC */\n\twhile (len > 1) {\t\t\t\t/* minimum length = 2 */\n\t\tsize_t iACLen   = buf[iOffset] & 0x0F;\n\t\tif (iACLen > len)\n\t\t\tbreak;\n\n\t\tiMethod = SC_AC_NONE;\t\t/* default no authentication required */\n\n\t\tif (buf[iOffset] & 0X80) { /* AC in adaptive coding */\n\t\t\t/* Evaluates only the command-byte, not the optional P1/P2/Option bytes */\n\t\t\tsize_t\tiParmLen = 1;\t\t\t/* command-byte is always present */\n\t\t\tsize_t\tiKeyLen  = 0;\t\t\t/* Encryption key is optional */\n\n\t\t\tif (buf[iOffset]   & 0x20) iKeyLen++;\n\t\t\tif (buf[iOffset+1] & 0x40) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x20) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x10) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x08) iParmLen++;\n\n\t\t\t/* Get KeyNumber if available */\n\t\t\tif(iKeyLen) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1+(size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset+iACLen];\n\n\t\t\t\tswitch( (iSC>>5) & 0x03 ){\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t/* key authentication */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tiMethod = SC_AC_AUT;\t\t/* key authentication  */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tiMethod = SC_AC_PRO;\t\t/* secure messaging */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiKeyRef = iSC & 0x1F;\t\t\t/* get key number */\n\t\t\t}\n\n\t\t\t/* Get PinNumber if available */\n\t\t\tif (iACLen > (1+iParmLen+iKeyLen)) {  /* check via total length if pin is present */\n\t\t\t\tif (len < 1+1+1+(size_t)iParmLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiKeyRef = buf[iOffset+1+1+iParmLen];  /* PTL + AM-header + parameter-bytes */\n\t\t\t\tiMethod = SC_AC_CHV;\n\t\t\t}\n\n\t\t\t/* Convert SETCOS command to OpenSC command group */\n\t\t\tif (len < 1+2)\n\t\t\t\tbreak;\n\t\t\tswitch(buf[iOffset+2]){\n\t\t\tcase 0x2A:\t\t\t/* crypto operation */\n\t\t\t\tiOperation = SC_AC_OP_CRYPTO;\n\t\t\t\tbreak;\n\t\t\tcase 0x46:\t\t\t/* key-generation operation */\n\t\t\t\tiOperation = SC_AC_OP_UPDATE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tiOperation = SC_AC_OP_SELECT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_file_add_acl_entry(file, iOperation, iMethod, iKeyRef);\n\t\t}\n\t\telse { /* AC in simple coding */\n\t\t\t   /* Initial AC is treated as an operational AC */\n\n\t\t\t/* Get specific Cmd groups for specified file-type */\n\t\t\tswitch (file->type) {\n\t\t\tcase SC_FILE_TYPE_DF:            /* DF */\n\t\t\t\tp_idx = df_idx;\n\t\t\t\tbreak;\n\t\t\tcase SC_FILE_TYPE_INTERNAL_EF:   /* EF for RSA keys */\n\t\t\t\tp_idx = efi_idx;\n\t\t\t\tbreak;\n\t\t\tdefault:                         /* EF */\n\t\t\t\tp_idx = ef_idx;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Encryption key present ? */\n\t\t\tiPinCount = iACLen > 0 ? iACLen - 1 : 0;\n\n\t\t\tif (buf[iOffset] & 0x20) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1 + (size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset + iACLen];\n\n\t\t\t\tswitch( (iSC>>5) & 0x03 ) {\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t/* key authentication */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tiMethod = SC_AC_AUT;\t\t/* key authentication  */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tiMethod = SC_AC_PRO;\t\t/* secure messaging */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiKeyRef = iSC & 0x1F;\t\t\t/* get key number */\n\n\t\t\t\tiPinCount--;\t\t\t\t/* one byte used for keyReference  */\n\t\t\t}\n\n\t\t\t/* Pin present ? */\n\t\t\tif ( iPinCount > 0 ) {\n\t\t\t\tif (len < 1 + 2)\n\t\t\t\t\tbreak;\n\t\t\t\tiKeyRef = buf[iOffset + 2];\t/* pin ref */\n\t\t\t\tiMethod = SC_AC_CHV;\n\t\t\t}\n\n\t\t\t/* Add AC for each command-operationType into OpenSc structure */\n\t\t\tbValue = buf[iOffset + 1];\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tif((bValue & 1) && (p_idx[i] >= 0))\n\t\t\t\t\tsc_file_add_acl_entry(file, p_idx[i], iMethod, iKeyRef);\n\t\t\t\tbValue >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Current field treated, get next AC sub-field */\n\t\tiOffset += iACLen +1;\t\t/* AC + PTL-byte */\n\t\tlen     -= iACLen +1;\n\t}\n}", "line_changes": {"deleted": [{"line_no": 108, "char_start": 3184, "char_end": 3213, "line": "\t\t\tiPinCount = iACLen - 1;\t\t\n"}], "added": [{"line_no": 108, "char_start": 3184, "char_end": 3228, "line": "\t\t\tiPinCount = iACLen > 0 ? iACLen - 1 : 0;\n"}]}, "char_changes": {"deleted": [{"char_start": 3210, "char_end": 3212, "chars": "\t\t"}], "added": [{"char_start": 3206, "char_end": 3219, "chars": "> 0 ? iACLen "}, {"char_start": 3222, "char_end": 3226, "chars": " : 0"}]}, "commit_link": "github.com/OpenSC/OpenSC/commit/c3f23b836e5a1766c36617fe1da30d22f7b63de2", "file_name": "src/libopensc/card-setcos.c", "vul_type": "cwe-125"}
{"func_name": "do_core_note", "func_src_before": "do_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags, size_t size, int clazz)\n{\n#ifdef ELFCORE\n\tint os_style = -1;\n\t/*\n\t * Sigh.  The 2.0.36 kernel in Debian 2.1, at\n\t * least, doesn't correctly implement name\n\t * sections, in core dumps, as specified by\n\t * the \"Program Linking\" section of \"UNIX(R) System\n\t * V Release 4 Programmer's Guide: ANSI C and\n\t * Programming Support Tools\", because my copy\n\t * clearly says \"The first 'namesz' bytes in 'name'\n\t * contain a *null-terminated* [emphasis mine]\n\t * character representation of the entry's owner\n\t * or originator\", but the 2.0.36 kernel code\n\t * doesn't include the terminating null in the\n\t * name....\n\t */\n\tif ((namesz == 4 && strncmp((char *)&nbuf[noff], \"CORE\", 4) == 0) ||\n\t    (namesz == 5 && strcmp((char *)&nbuf[noff], \"CORE\") == 0)) {\n\t\tos_style = OS_STYLE_SVR4;\n\t} \n\n\tif ((namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0)) {\n\t\tos_style = OS_STYLE_FREEBSD;\n\t}\n\n\tif ((namesz >= 11 && strncmp((char *)&nbuf[noff], \"NetBSD-CORE\", 11)\n\t    == 0)) {\n\t\tos_style = OS_STYLE_NETBSD;\n\t}\n\n\tif (os_style != -1 && (*flags & FLAGS_DID_CORE_STYLE) == 0) {\n\t\tif (file_printf(ms, \", %s-style\", os_style_names[os_style])\n\t\t    == -1)\n\t\t\treturn 1;\n\t\t*flags |= FLAGS_DID_CORE_STYLE;\n\t\t*flags |= os_style;\n\t}\n\n\tswitch (os_style) {\n\tcase OS_STYLE_NETBSD:\n\t\tif (type == NT_NETBSD_CORE_PROCINFO) {\n\t\t\tchar sbuf[512];\n\t\t\tstruct NetBSD_elfcore_procinfo pi;\n\t\t\tmemset(&pi, 0, sizeof(pi));\n\t\t\tmemcpy(&pi, nbuf + doff, descsz);\n\n\t\t\tif (file_printf(ms, \", from '%.31s', pid=%u, uid=%u, \"\n\t\t\t    \"gid=%u, nlwps=%u, lwp=%u (signal %u/code %u)\",\n\t\t\t    file_printable(sbuf, sizeof(sbuf),\n\t\t\t    CAST(char *, pi.cpi_name)),\n\t\t\t    elf_getu32(swap, (uint32_t)pi.cpi_pid),\n\t\t\t    elf_getu32(swap, pi.cpi_euid),\n\t\t\t    elf_getu32(swap, pi.cpi_egid),\n\t\t\t    elf_getu32(swap, pi.cpi_nlwps),\n\t\t\t    elf_getu32(swap, (uint32_t)pi.cpi_siglwp),\n\t\t\t    elf_getu32(swap, pi.cpi_signo),\n\t\t\t    elf_getu32(swap, pi.cpi_sigcode)) == -1)\n\t\t\t\treturn 1;\n\n\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {\n\t\t\tsize_t i, j;\n\t\t\tunsigned char c;\n\t\t\t/*\n\t\t\t * Extract the program name.  We assume\n\t\t\t * it to be 16 characters (that's what it\n\t\t\t * is in SunOS 5.x and Linux).\n\t\t\t *\n\t\t\t * Unfortunately, it's at a different offset\n\t\t\t * in various OSes, so try multiple offsets.\n\t\t\t * If the characters aren't all printable,\n\t\t\t * reject it.\n\t\t\t */\n\t\t\tfor (i = 0; i < NOFFSETS; i++) {\n\t\t\t\tunsigned char *cname, *cp;\n\t\t\t\tsize_t reloffset = prpsoffsets(i);\n\t\t\t\tsize_t noffset = doff + reloffset;\n\t\t\t\tsize_t k;\n\t\t\t\tfor (j = 0; j < 16; j++, noffset++,\n\t\t\t\t    reloffset++) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Make sure we're not past\n\t\t\t\t\t * the end of the buffer; if\n\t\t\t\t\t * we are, just give up.\n\t\t\t\t\t */\n\t\t\t\t\tif (noffset >= size)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Make sure we're not past\n\t\t\t\t\t * the end of the contents;\n\t\t\t\t\t * if we are, this obviously\n\t\t\t\t\t * isn't the right offset.\n\t\t\t\t\t */\n\t\t\t\t\tif (reloffset >= descsz)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\tc = nbuf[noffset];\n\t\t\t\t\tif (c == '\\0') {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A '\\0' at the\n\t\t\t\t\t\t * beginning is\n\t\t\t\t\t\t * obviously wrong.\n\t\t\t\t\t\t * Any other '\\0'\n\t\t\t\t\t\t * means we're done.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A nonprintable\n\t\t\t\t\t\t * character is also\n\t\t\t\t\t\t * wrong.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!isprint(c) || isquote(c))\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Well, that worked.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Try next offsets, in case this match is\n\t\t\t\t * in the middle of a string.\n\t\t\t\t */\n\t\t\t\tfor (k = i + 1 ; k < NOFFSETS; k++) {\n\t\t\t\t\tsize_t no;\n\t\t\t\t\tint adjust = 1;\n\t\t\t\t\tif (prpsoffsets(k) >= prpsoffsets(i))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (no = doff + prpsoffsets(k);\n\t\t\t\t\t     no < doff + prpsoffsets(i); no++)\n\t\t\t\t\t\tadjust = adjust\n\t\t\t\t\t\t         && isprint(nbuf[no]);\n\t\t\t\t\tif (adjust)\n\t\t\t\t\t\ti = k;\n\t\t\t\t}\n\n\t\t\t\tcname = (unsigned char *)\n\t\t\t\t    &nbuf[doff + prpsoffsets(i)];\n\t\t\t\tfor (cp = cname; *cp && isprint(*cp); cp++)\n\t\t\t\t\tcontinue;\n\t\t\t\t/*\n\t\t\t\t * Linux apparently appends a space at the end\n\t\t\t\t * of the command line: remove it.\n\t\t\t\t */\n\t\t\t\twhile (cp > cname && isspace(cp[-1]))\n\t\t\t\t\tcp--;\n\t\t\t\tif (file_printf(ms, \", from '%.*s'\",\n\t\t\t\t    (int)(cp - cname), cname) == -1)\n\t\t\t\t\treturn 1;\n\t\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\t\treturn 1;\n\n\t\t\ttryanother:\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\treturn 0;\n}", "func_src_after": "do_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags, size_t size, int clazz)\n{\n#ifdef ELFCORE\n\tint os_style = -1;\n\t/*\n\t * Sigh.  The 2.0.36 kernel in Debian 2.1, at\n\t * least, doesn't correctly implement name\n\t * sections, in core dumps, as specified by\n\t * the \"Program Linking\" section of \"UNIX(R) System\n\t * V Release 4 Programmer's Guide: ANSI C and\n\t * Programming Support Tools\", because my copy\n\t * clearly says \"The first 'namesz' bytes in 'name'\n\t * contain a *null-terminated* [emphasis mine]\n\t * character representation of the entry's owner\n\t * or originator\", but the 2.0.36 kernel code\n\t * doesn't include the terminating null in the\n\t * name....\n\t */\n\tif ((namesz == 4 && strncmp((char *)&nbuf[noff], \"CORE\", 4) == 0) ||\n\t    (namesz == 5 && strcmp((char *)&nbuf[noff], \"CORE\") == 0)) {\n\t\tos_style = OS_STYLE_SVR4;\n\t} \n\n\tif ((namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0)) {\n\t\tos_style = OS_STYLE_FREEBSD;\n\t}\n\n\tif ((namesz >= 11 && strncmp((char *)&nbuf[noff], \"NetBSD-CORE\", 11)\n\t    == 0)) {\n\t\tos_style = OS_STYLE_NETBSD;\n\t}\n\n\tif (os_style != -1 && (*flags & FLAGS_DID_CORE_STYLE) == 0) {\n\t\tif (file_printf(ms, \", %s-style\", os_style_names[os_style])\n\t\t    == -1)\n\t\t\treturn 1;\n\t\t*flags |= FLAGS_DID_CORE_STYLE;\n\t\t*flags |= os_style;\n\t}\n\n\tswitch (os_style) {\n\tcase OS_STYLE_NETBSD:\n\t\tif (type == NT_NETBSD_CORE_PROCINFO) {\n\t\t\tchar sbuf[512];\n\t\t\tstruct NetBSD_elfcore_procinfo pi;\n\t\t\tmemset(&pi, 0, sizeof(pi));\n\t\t\tmemcpy(&pi, nbuf + doff, descsz);\n\n\t\t\tif (file_printf(ms, \", from '%.31s', pid=%u, uid=%u, \"\n\t\t\t    \"gid=%u, nlwps=%u, lwp=%u (signal %u/code %u)\",\n\t\t\t    file_printable(sbuf, sizeof(sbuf),\n\t\t\t    CAST(char *, pi.cpi_name)),\n\t\t\t    elf_getu32(swap, (uint32_t)pi.cpi_pid),\n\t\t\t    elf_getu32(swap, pi.cpi_euid),\n\t\t\t    elf_getu32(swap, pi.cpi_egid),\n\t\t\t    elf_getu32(swap, pi.cpi_nlwps),\n\t\t\t    elf_getu32(swap, (uint32_t)pi.cpi_siglwp),\n\t\t\t    elf_getu32(swap, pi.cpi_signo),\n\t\t\t    elf_getu32(swap, pi.cpi_sigcode)) == -1)\n\t\t\t\treturn 1;\n\n\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {\n\t\t\tsize_t i, j;\n\t\t\tunsigned char c;\n\t\t\t/*\n\t\t\t * Extract the program name.  We assume\n\t\t\t * it to be 16 characters (that's what it\n\t\t\t * is in SunOS 5.x and Linux).\n\t\t\t *\n\t\t\t * Unfortunately, it's at a different offset\n\t\t\t * in various OSes, so try multiple offsets.\n\t\t\t * If the characters aren't all printable,\n\t\t\t * reject it.\n\t\t\t */\n\t\t\tfor (i = 0; i < NOFFSETS; i++) {\n\t\t\t\tunsigned char *cname, *cp;\n\t\t\t\tsize_t reloffset = prpsoffsets(i);\n\t\t\t\tsize_t noffset = doff + reloffset;\n\t\t\t\tsize_t k;\n\t\t\t\tfor (j = 0; j < 16; j++, noffset++,\n\t\t\t\t    reloffset++) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Make sure we're not past\n\t\t\t\t\t * the end of the buffer; if\n\t\t\t\t\t * we are, just give up.\n\t\t\t\t\t */\n\t\t\t\t\tif (noffset >= size)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Make sure we're not past\n\t\t\t\t\t * the end of the contents;\n\t\t\t\t\t * if we are, this obviously\n\t\t\t\t\t * isn't the right offset.\n\t\t\t\t\t */\n\t\t\t\t\tif (reloffset >= descsz)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\tc = nbuf[noffset];\n\t\t\t\t\tif (c == '\\0') {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A '\\0' at the\n\t\t\t\t\t\t * beginning is\n\t\t\t\t\t\t * obviously wrong.\n\t\t\t\t\t\t * Any other '\\0'\n\t\t\t\t\t\t * means we're done.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A nonprintable\n\t\t\t\t\t\t * character is also\n\t\t\t\t\t\t * wrong.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!isprint(c) || isquote(c))\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Well, that worked.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Try next offsets, in case this match is\n\t\t\t\t * in the middle of a string.\n\t\t\t\t */\n\t\t\t\tfor (k = i + 1 ; k < NOFFSETS; k++) {\n\t\t\t\t\tsize_t no;\n\t\t\t\t\tint adjust = 1;\n\t\t\t\t\tif (prpsoffsets(k) >= prpsoffsets(i))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (no = doff + prpsoffsets(k);\n\t\t\t\t\t     no < doff + prpsoffsets(i); no++)\n\t\t\t\t\t\tadjust = adjust\n\t\t\t\t\t\t         && isprint(nbuf[no]);\n\t\t\t\t\tif (adjust)\n\t\t\t\t\t\ti = k;\n\t\t\t\t}\n\n\t\t\t\tcname = (unsigned char *)\n\t\t\t\t    &nbuf[doff + prpsoffsets(i)];\n\t\t\t\tfor (cp = cname; cp < nbuf + size && *cp\n\t\t\t\t    && isprint(*cp); cp++)\n\t\t\t\t\tcontinue;\n\t\t\t\t/*\n\t\t\t\t * Linux apparently appends a space at the end\n\t\t\t\t * of the command line: remove it.\n\t\t\t\t */\n\t\t\t\twhile (cp > cname && isspace(cp[-1]))\n\t\t\t\t\tcp--;\n\t\t\t\tif (file_printf(ms, \", from '%.*s'\",\n\t\t\t\t    (int)(cp - cname), cname) == -1)\n\t\t\t\t\treturn 1;\n\t\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\t\treturn 1;\n\n\t\t\ttryanother:\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\treturn 0;\n}", "line_changes": {"deleted": [{"line_no": 153, "char_start": 4087, "char_end": 4135, "line": "\t\t\t\tfor (cp = cname; *cp && isprint(*cp); cp++)\n"}], "added": [{"line_no": 153, "char_start": 4087, "char_end": 4132, "line": "\t\t\t\tfor (cp = cname; cp < nbuf + size && *cp\n"}, {"line_no": 154, "char_start": 4132, "char_end": 4163, "line": "\t\t\t\t    && isprint(*cp); cp++)\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 4108, "char_end": 4128, "chars": "cp < nbuf + size && "}, {"char_start": 4131, "char_end": 4139, "chars": "\n\t\t\t\t   "}]}, "commit_link": "github.com/file/file/commit/a642587a9c9e2dd7feacdf513c3643ce26ad3c22", "file_name": "src/readelf.c", "vul_type": "cwe-125"}
{"func_name": "gst_asf_demux_process_ext_content_desc", "func_src_before": "gst_asf_demux_process_ext_content_desc (GstASFDemux * demux, guint8 * data,\n    guint64 size)\n{\n  /* Other known (and unused) 'text/unicode' metadata available :\n   *\n   *   WM/Lyrics =\n   *   WM/MediaPrimaryClassID = {D1607DBC-E323-4BE2-86A1-48A42A28441E}\n   *   WMFSDKVersion = 9.00.00.2980\n   *   WMFSDKNeeded = 0.0.0.0000\n   *   WM/UniqueFileIdentifier = AMGa_id=R    15334;AMGp_id=P     5149;AMGt_id=T  2324984\n   *   WM/Publisher = 4AD\n   *   WM/Provider = AMG\n   *   WM/ProviderRating = 8\n   *   WM/ProviderStyle = Rock (similar to WM/Genre)\n   *   WM/GenreID (similar to WM/Genre)\n   *   WM/TrackNumber (same as WM/Track but as a string)\n   *\n   * Other known (and unused) 'non-text' metadata available :\n   *\n   *   WM/EncodingTime\n   *   WM/MCDI\n   *   IsVBR\n   *\n   * We might want to read WM/TrackNumber and use atoi() if we don't have\n   * WM/Track\n   */\n\n  GstTagList *taglist;\n  guint16 blockcount, i;\n  gboolean content3D = FALSE;\n\n  struct\n  {\n    const gchar *interleave_name;\n    GstASF3DMode interleaving_type;\n  } stereoscopic_layout_map[] = {\n    {\n    \"SideBySideRF\", GST_ASF_3D_SIDE_BY_SIDE_HALF_RL}, {\n    \"SideBySideLF\", GST_ASF_3D_SIDE_BY_SIDE_HALF_LR}, {\n    \"OverUnderRT\", GST_ASF_3D_TOP_AND_BOTTOM_HALF_RL}, {\n    \"OverUnderLT\", GST_ASF_3D_TOP_AND_BOTTOM_HALF_LR}, {\n    \"DualStream\", GST_ASF_3D_DUAL_STREAM}\n  };\n  GST_INFO_OBJECT (demux, \"object is an extended content description\");\n\n  taglist = gst_tag_list_new_empty ();\n\n  /* Content Descriptor Count */\n  if (size < 2)\n    goto not_enough_data;\n\n  blockcount = gst_asf_demux_get_uint16 (&data, &size);\n\n  for (i = 1; i <= blockcount; ++i) {\n    const gchar *gst_tag_name;\n    guint16 datatype;\n    guint16 value_len;\n    guint16 name_len;\n    GValue tag_value = { 0, };\n    gsize in, out;\n    gchar *name;\n    gchar *name_utf8 = NULL;\n    gchar *value;\n\n    /* Descriptor */\n    if (!gst_asf_demux_get_string (&name, &name_len, &data, &size))\n      goto not_enough_data;\n\n    if (size < 2) {\n      g_free (name);\n      goto not_enough_data;\n    }\n    /* Descriptor Value Data Type */\n    datatype = gst_asf_demux_get_uint16 (&data, &size);\n\n    /* Descriptor Value (not really a string, but same thing reading-wise) */\n    if (!gst_asf_demux_get_string (&value, &value_len, &data, &size)) {\n      g_free (name);\n      goto not_enough_data;\n    }\n\n    name_utf8 =\n        g_convert (name, name_len, \"UTF-8\", \"UTF-16LE\", &in, &out, NULL);\n\n    if (name_utf8 != NULL) {\n      GST_DEBUG (\"Found tag/metadata %s\", name_utf8);\n\n      gst_tag_name = gst_asf_demux_get_gst_tag_from_tag_name (name_utf8);\n      GST_DEBUG (\"gst_tag_name %s\", GST_STR_NULL (gst_tag_name));\n\n      switch (datatype) {\n        case ASF_DEMUX_DATA_TYPE_UTF16LE_STRING:{\n          gchar *value_utf8;\n\n          value_utf8 = g_convert (value, value_len, \"UTF-8\", \"UTF-16LE\",\n              &in, &out, NULL);\n\n          /* get rid of tags with empty value */\n          if (value_utf8 != NULL && *value_utf8 != '\\0') {\n            GST_DEBUG (\"string value %s\", value_utf8);\n\n            value_utf8[out] = '\\0';\n\n            if (gst_tag_name != NULL) {\n              if (strcmp (gst_tag_name, GST_TAG_DATE_TIME) == 0) {\n                guint year = atoi (value_utf8);\n\n                if (year > 0) {\n                  g_value_init (&tag_value, GST_TYPE_DATE_TIME);\n                  g_value_take_boxed (&tag_value, gst_date_time_new_y (year));\n                }\n              } else if (strcmp (gst_tag_name, GST_TAG_GENRE) == 0) {\n                guint id3v1_genre_id;\n                const gchar *genre_str;\n\n                if (sscanf (value_utf8, \"(%u)\", &id3v1_genre_id) == 1 &&\n                    ((genre_str = gst_tag_id3_genre_get (id3v1_genre_id)))) {\n                  GST_DEBUG (\"Genre: %s -> %s\", value_utf8, genre_str);\n                  g_free (value_utf8);\n                  value_utf8 = g_strdup (genre_str);\n                }\n              } else {\n                GType tag_type;\n\n                /* convert tag from string to other type if required */\n                tag_type = gst_tag_get_type (gst_tag_name);\n                g_value_init (&tag_value, tag_type);\n                if (!gst_value_deserialize (&tag_value, value_utf8)) {\n                  GValue from_val = { 0, };\n\n                  g_value_init (&from_val, G_TYPE_STRING);\n                  g_value_set_string (&from_val, value_utf8);\n                  if (!g_value_transform (&from_val, &tag_value)) {\n                    GST_WARNING_OBJECT (demux,\n                        \"Could not transform string tag to \" \"%s tag type %s\",\n                        gst_tag_name, g_type_name (tag_type));\n                    g_value_unset (&tag_value);\n                  }\n                  g_value_unset (&from_val);\n                }\n              }\n            } else {\n              /* metadata ! */\n              GST_DEBUG (\"Setting metadata\");\n              g_value_init (&tag_value, G_TYPE_STRING);\n              g_value_set_string (&tag_value, value_utf8);\n              /* If we found a stereoscopic marker, look for StereoscopicLayout\n               * metadata */\n              if (content3D) {\n                guint i;\n                if (strncmp (\"StereoscopicLayout\", name_utf8,\n                        strlen (name_utf8)) == 0) {\n                  for (i = 0; i < G_N_ELEMENTS (stereoscopic_layout_map); i++) {\n                    if (g_str_equal (stereoscopic_layout_map[i].interleave_name,\n                            value_utf8)) {\n                      demux->asf_3D_mode =\n                          stereoscopic_layout_map[i].interleaving_type;\n                      GST_INFO (\"find interleave type %u\", demux->asf_3D_mode);\n                    }\n                  }\n                }\n                GST_INFO_OBJECT (demux, \"3d type is %u\", demux->asf_3D_mode);\n              } else {\n                demux->asf_3D_mode = GST_ASF_3D_NONE;\n                GST_INFO_OBJECT (demux, \"None 3d type\");\n              }\n            }\n          } else if (value_utf8 == NULL) {\n            GST_WARNING (\"Failed to convert string value to UTF8, skipping\");\n          } else {\n            GST_DEBUG (\"Skipping empty string value for %s\",\n                GST_STR_NULL (gst_tag_name));\n          }\n          g_free (value_utf8);\n          break;\n        }\n        case ASF_DEMUX_DATA_TYPE_BYTE_ARRAY:{\n          if (gst_tag_name) {\n            if (!g_str_equal (gst_tag_name, GST_TAG_IMAGE)) {\n              GST_FIXME (\"Unhandled byte array tag %s\",\n                  GST_STR_NULL (gst_tag_name));\n              break;\n            } else {\n              asf_demux_parse_picture_tag (taglist, (guint8 *) value,\n                  value_len);\n            }\n          }\n          break;\n        }\n        case ASF_DEMUX_DATA_TYPE_DWORD:{\n          guint uint_val = GST_READ_UINT32_LE (value);\n\n          /* this is the track number */\n          g_value_init (&tag_value, G_TYPE_UINT);\n\n          /* WM/Track counts from 0 */\n          if (!strcmp (name_utf8, \"WM/Track\"))\n            ++uint_val;\n\n          g_value_set_uint (&tag_value, uint_val);\n          break;\n        }\n          /* Detect 3D */\n        case ASF_DEMUX_DATA_TYPE_BOOL:{\n          gboolean bool_val = GST_READ_UINT32_LE (value);\n\n          if (strncmp (\"Stereoscopic\", name_utf8, strlen (name_utf8)) == 0) {\n            if (bool_val) {\n              GST_INFO_OBJECT (demux, \"This is 3D contents\");\n              content3D = TRUE;\n            } else {\n              GST_INFO_OBJECT (demux, \"This is not 3D contenst\");\n              content3D = FALSE;\n            }\n          }\n\n          break;\n        }\n        default:{\n          GST_DEBUG (\"Skipping tag %s of type %d\", gst_tag_name, datatype);\n          break;\n        }\n      }\n\n      if (G_IS_VALUE (&tag_value)) {\n        if (gst_tag_name) {\n          GstTagMergeMode merge_mode = GST_TAG_MERGE_APPEND;\n\n          /* WM/TrackNumber is more reliable than WM/Track, since the latter\n           * is supposed to have a 0 base but is often wrongly written to start\n           * from 1 as well, so prefer WM/TrackNumber when we have it: either\n           * replace the value added earlier from WM/Track or put it first in\n           * the list, so that it will get picked up by _get_uint() */\n          if (strcmp (name_utf8, \"WM/TrackNumber\") == 0)\n            merge_mode = GST_TAG_MERGE_REPLACE;\n\n          gst_tag_list_add_values (taglist, merge_mode, gst_tag_name,\n              &tag_value, NULL);\n        } else {\n          GST_DEBUG (\"Setting global metadata %s\", name_utf8);\n          gst_structure_set_value (demux->global_metadata, name_utf8,\n              &tag_value);\n        }\n\n        g_value_unset (&tag_value);\n      }\n    }\n\n    g_free (name);\n    g_free (value);\n    g_free (name_utf8);\n  }\n\n  gst_asf_demux_add_global_tags (demux, taglist);\n\n  return GST_FLOW_OK;\n\n  /* Errors */\nnot_enough_data:\n  {\n    GST_WARNING (\"Unexpected end of data parsing ext content desc object\");\n    gst_tag_list_unref (taglist);\n    return GST_FLOW_OK;         /* not really fatal */\n  }\n}", "func_src_after": "gst_asf_demux_process_ext_content_desc (GstASFDemux * demux, guint8 * data,\n    guint64 size)\n{\n  /* Other known (and unused) 'text/unicode' metadata available :\n   *\n   *   WM/Lyrics =\n   *   WM/MediaPrimaryClassID = {D1607DBC-E323-4BE2-86A1-48A42A28441E}\n   *   WMFSDKVersion = 9.00.00.2980\n   *   WMFSDKNeeded = 0.0.0.0000\n   *   WM/UniqueFileIdentifier = AMGa_id=R    15334;AMGp_id=P     5149;AMGt_id=T  2324984\n   *   WM/Publisher = 4AD\n   *   WM/Provider = AMG\n   *   WM/ProviderRating = 8\n   *   WM/ProviderStyle = Rock (similar to WM/Genre)\n   *   WM/GenreID (similar to WM/Genre)\n   *   WM/TrackNumber (same as WM/Track but as a string)\n   *\n   * Other known (and unused) 'non-text' metadata available :\n   *\n   *   WM/EncodingTime\n   *   WM/MCDI\n   *   IsVBR\n   *\n   * We might want to read WM/TrackNumber and use atoi() if we don't have\n   * WM/Track\n   */\n\n  GstTagList *taglist;\n  guint16 blockcount, i;\n  gboolean content3D = FALSE;\n\n  struct\n  {\n    const gchar *interleave_name;\n    GstASF3DMode interleaving_type;\n  } stereoscopic_layout_map[] = {\n    {\n    \"SideBySideRF\", GST_ASF_3D_SIDE_BY_SIDE_HALF_RL}, {\n    \"SideBySideLF\", GST_ASF_3D_SIDE_BY_SIDE_HALF_LR}, {\n    \"OverUnderRT\", GST_ASF_3D_TOP_AND_BOTTOM_HALF_RL}, {\n    \"OverUnderLT\", GST_ASF_3D_TOP_AND_BOTTOM_HALF_LR}, {\n    \"DualStream\", GST_ASF_3D_DUAL_STREAM}\n  };\n  GST_INFO_OBJECT (demux, \"object is an extended content description\");\n\n  taglist = gst_tag_list_new_empty ();\n\n  /* Content Descriptor Count */\n  if (size < 2)\n    goto not_enough_data;\n\n  blockcount = gst_asf_demux_get_uint16 (&data, &size);\n\n  for (i = 1; i <= blockcount; ++i) {\n    const gchar *gst_tag_name;\n    guint16 datatype;\n    guint16 value_len;\n    guint16 name_len;\n    GValue tag_value = { 0, };\n    gsize in, out;\n    gchar *name;\n    gchar *name_utf8 = NULL;\n    gchar *value;\n\n    /* Descriptor */\n    if (!gst_asf_demux_get_string (&name, &name_len, &data, &size))\n      goto not_enough_data;\n\n    if (size < 2) {\n      g_free (name);\n      goto not_enough_data;\n    }\n    /* Descriptor Value Data Type */\n    datatype = gst_asf_demux_get_uint16 (&data, &size);\n\n    /* Descriptor Value (not really a string, but same thing reading-wise) */\n    if (!gst_asf_demux_get_string (&value, &value_len, &data, &size)) {\n      g_free (name);\n      goto not_enough_data;\n    }\n\n    name_utf8 =\n        g_convert (name, name_len, \"UTF-8\", \"UTF-16LE\", &in, &out, NULL);\n\n    if (name_utf8 != NULL) {\n      GST_DEBUG (\"Found tag/metadata %s\", name_utf8);\n\n      gst_tag_name = gst_asf_demux_get_gst_tag_from_tag_name (name_utf8);\n      GST_DEBUG (\"gst_tag_name %s\", GST_STR_NULL (gst_tag_name));\n\n      switch (datatype) {\n        case ASF_DEMUX_DATA_TYPE_UTF16LE_STRING:{\n          gchar *value_utf8;\n\n          value_utf8 = g_convert (value, value_len, \"UTF-8\", \"UTF-16LE\",\n              &in, &out, NULL);\n\n          /* get rid of tags with empty value */\n          if (value_utf8 != NULL && *value_utf8 != '\\0') {\n            GST_DEBUG (\"string value %s\", value_utf8);\n\n            value_utf8[out] = '\\0';\n\n            if (gst_tag_name != NULL) {\n              if (strcmp (gst_tag_name, GST_TAG_DATE_TIME) == 0) {\n                guint year = atoi (value_utf8);\n\n                if (year > 0) {\n                  g_value_init (&tag_value, GST_TYPE_DATE_TIME);\n                  g_value_take_boxed (&tag_value, gst_date_time_new_y (year));\n                }\n              } else if (strcmp (gst_tag_name, GST_TAG_GENRE) == 0) {\n                guint id3v1_genre_id;\n                const gchar *genre_str;\n\n                if (sscanf (value_utf8, \"(%u)\", &id3v1_genre_id) == 1 &&\n                    ((genre_str = gst_tag_id3_genre_get (id3v1_genre_id)))) {\n                  GST_DEBUG (\"Genre: %s -> %s\", value_utf8, genre_str);\n                  g_free (value_utf8);\n                  value_utf8 = g_strdup (genre_str);\n                }\n              } else {\n                GType tag_type;\n\n                /* convert tag from string to other type if required */\n                tag_type = gst_tag_get_type (gst_tag_name);\n                g_value_init (&tag_value, tag_type);\n                if (!gst_value_deserialize (&tag_value, value_utf8)) {\n                  GValue from_val = { 0, };\n\n                  g_value_init (&from_val, G_TYPE_STRING);\n                  g_value_set_string (&from_val, value_utf8);\n                  if (!g_value_transform (&from_val, &tag_value)) {\n                    GST_WARNING_OBJECT (demux,\n                        \"Could not transform string tag to \" \"%s tag type %s\",\n                        gst_tag_name, g_type_name (tag_type));\n                    g_value_unset (&tag_value);\n                  }\n                  g_value_unset (&from_val);\n                }\n              }\n            } else {\n              /* metadata ! */\n              GST_DEBUG (\"Setting metadata\");\n              g_value_init (&tag_value, G_TYPE_STRING);\n              g_value_set_string (&tag_value, value_utf8);\n              /* If we found a stereoscopic marker, look for StereoscopicLayout\n               * metadata */\n              if (content3D) {\n                guint i;\n                if (strncmp (\"StereoscopicLayout\", name_utf8,\n                        strlen (name_utf8)) == 0) {\n                  for (i = 0; i < G_N_ELEMENTS (stereoscopic_layout_map); i++) {\n                    if (g_str_equal (stereoscopic_layout_map[i].interleave_name,\n                            value_utf8)) {\n                      demux->asf_3D_mode =\n                          stereoscopic_layout_map[i].interleaving_type;\n                      GST_INFO (\"find interleave type %u\", demux->asf_3D_mode);\n                    }\n                  }\n                }\n                GST_INFO_OBJECT (demux, \"3d type is %u\", demux->asf_3D_mode);\n              } else {\n                demux->asf_3D_mode = GST_ASF_3D_NONE;\n                GST_INFO_OBJECT (demux, \"None 3d type\");\n              }\n            }\n          } else if (value_utf8 == NULL) {\n            GST_WARNING (\"Failed to convert string value to UTF8, skipping\");\n          } else {\n            GST_DEBUG (\"Skipping empty string value for %s\",\n                GST_STR_NULL (gst_tag_name));\n          }\n          g_free (value_utf8);\n          break;\n        }\n        case ASF_DEMUX_DATA_TYPE_BYTE_ARRAY:{\n          if (gst_tag_name) {\n            if (!g_str_equal (gst_tag_name, GST_TAG_IMAGE)) {\n              GST_FIXME (\"Unhandled byte array tag %s\",\n                  GST_STR_NULL (gst_tag_name));\n              break;\n            } else {\n              asf_demux_parse_picture_tag (taglist, (guint8 *) value,\n                  value_len);\n            }\n          }\n          break;\n        }\n        case ASF_DEMUX_DATA_TYPE_DWORD:{\n          guint uint_val;\n\n          if (value_len < 4)\n            break;\n\n          uint_val = GST_READ_UINT32_LE (value);\n\n          /* this is the track number */\n          g_value_init (&tag_value, G_TYPE_UINT);\n\n          /* WM/Track counts from 0 */\n          if (!strcmp (name_utf8, \"WM/Track\"))\n            ++uint_val;\n\n          g_value_set_uint (&tag_value, uint_val);\n          break;\n        }\n          /* Detect 3D */\n        case ASF_DEMUX_DATA_TYPE_BOOL:{\n          gboolean bool_val;\n\n          if (value_len < 4)\n            break;\n\n          bool_val = GST_READ_UINT32_LE (value);\n\n          if (strncmp (\"Stereoscopic\", name_utf8, strlen (name_utf8)) == 0) {\n            if (bool_val) {\n              GST_INFO_OBJECT (demux, \"This is 3D contents\");\n              content3D = TRUE;\n            } else {\n              GST_INFO_OBJECT (demux, \"This is not 3D contenst\");\n              content3D = FALSE;\n            }\n          }\n\n          break;\n        }\n        default:{\n          GST_DEBUG (\"Skipping tag %s of type %d\", gst_tag_name, datatype);\n          break;\n        }\n      }\n\n      if (G_IS_VALUE (&tag_value)) {\n        if (gst_tag_name) {\n          GstTagMergeMode merge_mode = GST_TAG_MERGE_APPEND;\n\n          /* WM/TrackNumber is more reliable than WM/Track, since the latter\n           * is supposed to have a 0 base but is often wrongly written to start\n           * from 1 as well, so prefer WM/TrackNumber when we have it: either\n           * replace the value added earlier from WM/Track or put it first in\n           * the list, so that it will get picked up by _get_uint() */\n          if (strcmp (name_utf8, \"WM/TrackNumber\") == 0)\n            merge_mode = GST_TAG_MERGE_REPLACE;\n\n          gst_tag_list_add_values (taglist, merge_mode, gst_tag_name,\n              &tag_value, NULL);\n        } else {\n          GST_DEBUG (\"Setting global metadata %s\", name_utf8);\n          gst_structure_set_value (demux->global_metadata, name_utf8,\n              &tag_value);\n        }\n\n        g_value_unset (&tag_value);\n      }\n    }\n\n    g_free (name);\n    g_free (value);\n    g_free (name_utf8);\n  }\n\n  gst_asf_demux_add_global_tags (demux, taglist);\n\n  return GST_FLOW_OK;\n\n  /* Errors */\nnot_enough_data:\n  {\n    GST_WARNING (\"Unexpected end of data parsing ext content desc object\");\n    gst_tag_list_unref (taglist);\n    return GST_FLOW_OK;         /* not really fatal */\n  }\n}", "line_changes": {"deleted": [{"line_no": 191, "char_start": 6766, "char_end": 6821, "line": "          guint uint_val = GST_READ_UINT32_LE (value);\n"}, {"line_no": 205, "char_start": 7169, "char_end": 7227, "line": "          gboolean bool_val = GST_READ_UINT32_LE (value);\n"}], "added": [{"line_no": 191, "char_start": 6766, "char_end": 6792, "line": "          guint uint_val;\n"}, {"line_no": 192, "char_start": 6792, "char_end": 6793, "line": "\n"}, {"line_no": 193, "char_start": 6793, "char_end": 6822, "line": "          if (value_len < 4)\n"}, {"line_no": 194, "char_start": 6822, "char_end": 6841, "line": "            break;\n"}, {"line_no": 195, "char_start": 6841, "char_end": 6842, "line": "\n"}, {"line_no": 196, "char_start": 6842, "char_end": 6891, "line": "          uint_val = GST_READ_UINT32_LE (value);\n"}, {"line_no": 210, "char_start": 7239, "char_end": 7268, "line": "          gboolean bool_val;\n"}, {"line_no": 211, "char_start": 7268, "char_end": 7269, "line": "\n"}, {"line_no": 212, "char_start": 7269, "char_end": 7298, "line": "          if (value_len < 4)\n"}, {"line_no": 213, "char_start": 7298, "char_end": 7317, "line": "            break;\n"}, {"line_no": 214, "char_start": 7317, "char_end": 7318, "line": "\n"}, {"line_no": 215, "char_start": 7318, "char_end": 7367, "line": "          bool_val = GST_READ_UINT32_LE (value);\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 6790, "char_end": 6860, "chars": ";\n\n          if (value_len < 4)\n            break;\n\n          uint_val"}, {"char_start": 7257, "char_end": 7327, "chars": " bool_val;\n\n          if (value_len < 4)\n            break;\n\n         "}]}, "commit_link": "github.com/GStreamer/gst-plugins-ugly/commit/d21017b52a585f145e8d62781bcc1c5fefc7ee37", "file_name": "gst/asfdemux/gstasfdemux.c", "vul_type": "cwe-125"}
{"func_name": "enc_untrusted_recvmsg", "func_src_before": "ssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) {\n  size_t total_buffer_size = CalculateTotalMessageSize(msg);\n\n  MessageWriter input;\n  input.Push(sockfd);\n  input.Push<uint64_t>(msg->msg_namelen);\n  input.Push<uint64_t>(total_buffer_size);\n  input.Push<uint64_t>(msg->msg_controllen);\n  input.Push(msg->msg_flags);\n  input.Push(flags);\n\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvMsgHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvmsg\", 2,\n                           /*match_exact_params=*/false);\n\n  ssize_t result = output.next<ssize_t>();\n  int klinux_errno = output.next<int>();\n\n  // recvmsg() returns the number of characters received. On error, -1 is\n  // returned, with errno set to indicate the cause of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto msg_name_extent = output.next();\n  // The returned |msg_namelen| should not exceed the buffer size.\n  if (msg_name_extent.size() <= msg->msg_namelen) {\n    msg->msg_namelen = msg_name_extent.size();\n  }\n  memcpy(msg->msg_name, msg_name_extent.As<char>(), msg->msg_namelen);\n\n  // A single buffer is passed from the untrusted side, copy it into the\n  // scattered buffers inside the enclave.\n  auto msg_iov_extent = output.next();\n  size_t total_bytes = msg_iov_extent.size();\n  size_t bytes_copied = 0;\n  for (int i = 0; i < msg->msg_iovlen && bytes_copied < total_bytes; ++i) {\n    size_t bytes_to_copy =\n        std::min(msg->msg_iov[i].iov_len, total_bytes - bytes_copied);\n    memcpy(msg->msg_iov[i].iov_base, msg_iov_extent.As<char>() + bytes_copied,\n           bytes_to_copy);\n    bytes_copied += bytes_to_copy;\n  }\n\n  auto msg_control_extent = output.next();\n  // The returned |msg_controllen| should not exceed the buffer size.\n  if (msg_control_extent.size() <= msg->msg_controllen) {\n    msg->msg_controllen = msg_control_extent.size();\n  }\n  memcpy(msg->msg_control, msg_control_extent.As<char>(), msg->msg_controllen);\n\n  return result;\n}", "func_src_after": "ssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) {\n  size_t total_buffer_size = CalculateTotalMessageSize(msg);\n\n  MessageWriter input;\n  input.Push(sockfd);\n  input.Push<uint64_t>(msg->msg_namelen);\n  input.Push<uint64_t>(total_buffer_size);\n  input.Push<uint64_t>(msg->msg_controllen);\n  input.Push(msg->msg_flags);\n  input.Push(flags);\n\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvMsgHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvmsg\", 2,\n                           /*match_exact_params=*/false);\n\n  ssize_t result = output.next<ssize_t>();\n  int klinux_errno = output.next<int>();\n\n  // recvmsg() returns the number of characters received. On error, -1 is\n  // returned, with errno set to indicate the cause of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  if (result > total_buffer_size) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_recvmsg: result exceeds requested\");\n  }\n\n  auto msg_name_extent = output.next();\n  // The returned |msg_namelen| should not exceed the buffer size.\n  if (msg_name_extent.size() <= msg->msg_namelen) {\n    msg->msg_namelen = msg_name_extent.size();\n  }\n  memcpy(msg->msg_name, msg_name_extent.As<char>(), msg->msg_namelen);\n\n  // A single buffer is passed from the untrusted side, copy it into the\n  // scattered buffers inside the enclave.\n  auto msg_iov_extent = output.next();\n  size_t total_bytes = msg_iov_extent.size();\n  size_t bytes_copied = 0;\n  for (int i = 0; i < msg->msg_iovlen && bytes_copied < total_bytes; ++i) {\n    size_t bytes_to_copy =\n        std::min(msg->msg_iov[i].iov_len, total_bytes - bytes_copied);\n    memcpy(msg->msg_iov[i].iov_base, msg_iov_extent.As<char>() + bytes_copied,\n           bytes_to_copy);\n    bytes_copied += bytes_to_copy;\n  }\n\n  auto msg_control_extent = output.next();\n  // The returned |msg_controllen| should not exceed the buffer size.\n  if (msg_control_extent.size() <= msg->msg_controllen) {\n    msg->msg_controllen = msg_control_extent.size();\n  }\n  memcpy(msg->msg_control, msg_control_extent.As<char>(), msg->msg_controllen);\n\n  return result;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 29, "char_start": 947, "char_end": 983, "line": "  if (result > total_buffer_size) {\n"}, {"line_no": 30, "char_start": 983, "char_end": 1044, "line": "    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n"}, {"line_no": 31, "char_start": 1044, "char_end": 1104, "line": "        \"enc_untrusted_recvmsg: result exceeds requested\");\n"}, {"line_no": 32, "char_start": 1104, "char_end": 1108, "line": "  }\n"}, {"line_no": 33, "char_start": 1108, "char_end": 1109, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 949, "char_end": 1111, "chars": "if (result > total_buffer_size) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_recvmsg: result exceeds requested\");\n  }\n\n  "}]}, "commit_link": "github.com/google/asylo/commit/fa6485c5d16a7355eab047d4a44345a73bc9131e", "file_name": "asylo/platform/host_call/trusted/host_calls.cc", "vul_type": "cwe-125"}
{"func_name": "HPHP::HHVM_METHOD", "func_src_before": "static Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String& /*type*/ /* = null_string */,\n                         int /*slabid*/ /* = 0 */, int /*limit*/ /* = 100 */) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n  memcached_stat_st *stats;\n\n  stats = memcached_stat(&data->m_memcache, nullptr, &ret);\n  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n\n  int server_count = memcached_server_count(&data->m_memcache);\n\n  Array return_val;\n\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    char stats_key[30] = {0};\n    size_t key_len;\n\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n\n    stat = stats + server_id;\n\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n\n    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n\n    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n  }\n\n  free(stats);\n  return return_val;\n}", "func_src_after": "static Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String& /*type*/ /* = null_string */,\n                         int /*slabid*/ /* = 0 */, int /*limit*/ /* = 100 */) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n  memcached_stat_st *stats;\n\n  stats = memcached_stat(&data->m_memcache, nullptr, &ret);\n  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n\n  int server_count = memcached_server_count(&data->m_memcache);\n\n  Array return_val;\n\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n\n    stat = stats + server_id;\n\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n\n    auto const port_str = folly::to<std::string>(port);\n    auto const key_len = strlen(hostname) + 1 + port_str.length();\n    auto key = String(key_len, ReserveString);\n    key += hostname;\n    key += \":\";\n    key += port_str;\n    return_val.set(key, server_stats);\n  }\n\n  free(stats);\n  return return_val;\n}", "line_changes": {"deleted": [{"line_no": 19, "char_start": 607, "char_end": 637, "line": "    char stats_key[30] = {0};\n"}, {"line_no": 20, "char_start": 637, "char_end": 657, "line": "    size_t key_len;\n"}, {"line_no": 21, "char_start": 657, "char_end": 658, "line": "\n"}, {"line_no": 34, "char_start": 1060, "char_end": 1139, "line": "    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n"}, {"line_no": 35, "char_start": 1139, "char_end": 1140, "line": "\n"}, {"line_no": 36, "char_start": 1140, "char_end": 1214, "line": "    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n"}], "added": [{"line_no": 31, "char_start": 1009, "char_end": 1065, "line": "    auto const port_str = folly::to<std::string>(port);\n"}, {"line_no": 32, "char_start": 1065, "char_end": 1132, "line": "    auto const key_len = strlen(hostname) + 1 + port_str.length();\n"}, {"line_no": 33, "char_start": 1132, "char_end": 1179, "line": "    auto key = String(key_len, ReserveString);\n"}, {"line_no": 34, "char_start": 1179, "char_end": 1200, "line": "    key += hostname;\n"}, {"line_no": 35, "char_start": 1200, "char_end": 1216, "line": "    key += \":\";\n"}, {"line_no": 36, "char_start": 1216, "char_end": 1237, "line": "    key += port_str;\n"}, {"line_no": 37, "char_start": 1237, "char_end": 1276, "line": "    return_val.set(key, server_stats);\n"}]}, "char_changes": {"deleted": [{"char_start": 611, "char_end": 662, "chars": "char stats_key[30] = {0};\n    size_t key_len;\n\n    "}, {"char_start": 1064, "char_end": 1071, "chars": "key_len"}, {"char_start": 1072, "char_end": 1075, "chars": "= s"}, {"char_start": 1078, "char_end": 1080, "chars": "in"}, {"char_start": 1081, "char_end": 1083, "chars": "f("}, {"char_start": 1085, "char_end": 1086, "chars": "a"}, {"char_start": 1088, "char_end": 1094, "chars": "_key, "}, {"char_start": 1096, "char_end": 1100, "chars": "zeof"}, {"char_start": 1101, "char_end": 1102, "chars": "s"}, {"char_start": 1106, "char_end": 1107, "chars": "_"}, {"char_start": 1110, "char_end": 1112, "chars": "),"}, {"char_start": 1113, "char_end": 1121, "chars": "\"%s:%d\","}, {"char_start": 1130, "char_end": 1131, "chars": ","}, {"char_start": 1139, "char_end": 1140, "chars": "\n"}, {"char_start": 1144, "char_end": 1145, "chars": "r"}, {"char_start": 1147, "char_end": 1148, "chars": "u"}, {"char_start": 1151, "char_end": 1153, "chars": "va"}, {"char_start": 1154, "char_end": 1155, "chars": "."}, {"char_start": 1157, "char_end": 1159, "chars": "t("}, {"char_start": 1165, "char_end": 1166, "chars": "("}, {"char_start": 1169, "char_end": 1172, "chars": "ts_"}, {"char_start": 1175, "char_end": 1176, "chars": ","}, {"char_start": 1181, "char_end": 1185, "chars": "len,"}, {"char_start": 1186, "char_end": 1191, "chars": "CopyS"}, {"char_start": 1193, "char_end": 1194, "chars": "i"}, {"char_start": 1195, "char_end": 1197, "chars": "g)"}], "added": [{"char_start": 1013, "char_end": 1028, "chars": "auto const port"}, {"char_start": 1029, "char_end": 1032, "chars": "str"}, {"char_start": 1035, "char_end": 1045, "chars": "folly::to<"}, {"char_start": 1046, "char_end": 1052, "chars": "td::st"}, {"char_start": 1055, "char_end": 1057, "chars": "g>"}, {"char_start": 1058, "char_end": 1061, "chars": "por"}, {"char_start": 1062, "char_end": 1069, "chars": ");\n    "}, {"char_start": 1070, "char_end": 1071, "chars": "u"}, {"char_start": 1072, "char_end": 1073, "chars": "o"}, {"char_start": 1074, "char_end": 1075, "chars": "c"}, {"char_start": 1076, "char_end": 1077, "chars": "n"}, {"char_start": 1079, "char_end": 1080, "chars": " "}, {"char_start": 1083, "char_end": 1087, "chars": "_len"}, {"char_start": 1088, "char_end": 1090, "chars": "= "}, {"char_start": 1091, "char_end": 1097, "chars": "trlen("}, {"char_start": 1105, "char_end": 1112, "chars": ") + 1 +"}, {"char_start": 1117, "char_end": 1129, "chars": "_str.length("}, {"char_start": 1136, "char_end": 1142, "chars": "auto k"}, {"char_start": 1143, "char_end": 1148, "chars": "y = S"}, {"char_start": 1150, "char_end": 1151, "chars": "i"}, {"char_start": 1152, "char_end": 1157, "chars": "g(key"}, {"char_start": 1159, "char_end": 1165, "chars": "en, Re"}, {"char_start": 1167, "char_end": 1170, "chars": "rve"}, {"char_start": 1176, "char_end": 1192, "chars": ");\n    key += ho"}, {"char_start": 1194, "char_end": 1195, "chars": "n"}, {"char_start": 1196, "char_end": 1204, "chars": "me;\n    "}, {"char_start": 1207, "char_end": 1219, "chars": " += \":\";\n   "}, {"char_start": 1224, "char_end": 1227, "chars": "+= "}, {"char_start": 1228, "char_end": 1233, "chars": "ort_s"}, {"char_start": 1235, "char_end": 1246, "chars": ";\n    retur"}, {"char_start": 1247, "char_end": 1259, "chars": "_val.set(key"}]}, "commit_link": "github.com/facebook/hhvm/commit/4bff3bfbe90d10451e4638c2118d1ad1117bb3e3", "file_name": "hphp/runtime/ext/memcache/ext_memcache.cpp", "vul_type": "cwe-125"}
