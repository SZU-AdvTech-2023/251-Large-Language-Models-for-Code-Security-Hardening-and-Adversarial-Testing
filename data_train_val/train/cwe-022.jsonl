{"func_name": "dd_get_item_size", "func_src_before": "long dd_get_item_size(struct dump_dir *dd, const char *name)\n{\n    long size = -1;\n    char *iname = concat_path_file(dd->dd_dirname, name);\n    struct stat statbuf;\n\n    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))\n        size = statbuf.st_size;\n    else\n    {\n        if (errno == ENOENT)\n            size = 0;\n        else\n            perror_msg(\"Can't get size of file '%s'\", iname);\n    }\n\n    free(iname);\n\n    return size;\n}", "func_src_after": "long dd_get_item_size(struct dump_dir *dd, const char *name)\n{\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);\n\n    long size = -1;\n    char *iname = concat_path_file(dd->dd_dirname, name);\n    struct stat statbuf;\n\n    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))\n        size = statbuf.st_size;\n    else\n    {\n        if (errno == ENOENT)\n            size = 0;\n        else\n            perror_msg(\"Can't get size of file '%s'\", iname);\n    }\n\n    free(iname);\n\n    return size;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 3, "char_start": 63, "char_end": 103, "line": "    if (!str_is_correct_filename(name))\n"}, {"line_no": 4, "char_start": 103, "char_end": 191, "line": "        error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);\n"}, {"line_no": 5, "char_start": 191, "char_end": 192, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 67, "char_end": 196, "chars": "if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);\n\n    "}]}, "commit_link": "github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277", "file_name": "src/lib/dump_dir.c", "vul_type": "cwe-022"}
{"func_name": "zmi_page_request", "func_src_before": "    def zmi_page_request(self, *args, **kwargs):\r\n      request = self.REQUEST\r\n      RESPONSE = request.RESPONSE\r\n      SESSION = request.SESSION\r\n      self._zmi_page_request()\r\n      RESPONSE.setHeader('Expires',DateTime(request['ZMI_TIME']-10000).toZone('GMT+1').rfc822())\r\n      RESPONSE.setHeader('Cache-Control', 'no-cache')\r\n      RESPONSE.setHeader('Pragma', 'no-cache')\r\n      RESPONSE.setHeader('Content-Type', 'text/html;charset=%s'%request['ZMS_CHARSET'])\r\n      if not request.get( 'preview'):\r\n        request.set( 'preview','preview')\r\n      langs = self.getLanguages(request)\r\n      if request.get('lang') not in langs:\r\n        request.set('lang',langs[0])\r\n      if request.get('manage_lang') not in self.getLocale().get_manage_langs():\r\n        request.set('manage_lang',self.get_manage_lang())\r\n      if not request.get('manage_tabs_message'):\r\n        request.set( 'manage_tabs_message',self.getConfProperty('ZMS.manage_tabs_message',''))\r\n      # manage_system\r\n      if request.form.has_key('zmi-manage-system'):\r\n        request.SESSION.set('zmi-manage-system',int(request.get('zmi-manage-system')))\r\n      # avoid declarative urls\r\n      physical_path = self.getPhysicalPath()\r\n      path_to_handle = request['URL0'][len(request['BASE0']):].split('/')\r\n      path = path_to_handle[:-1]\r\n      if len(filter(lambda x:x.find('.')>0 or x.startswith('manage_'),path))==0:\r\n        for i in range(len(path)):\r\n          if path[:-(i+1)] != physical_path[:-(i+1)]:\r\n            path[:-(i+1)] = physical_path[:-(i+1)]\r\n        new_path = path+[path_to_handle[-1]]\r\n        if path_to_handle != new_path:\r\n          request.RESPONSE.redirect('/'.join(new_path))", "func_src_after": "    def zmi_page_request(self, *args, **kwargs):\r\n      request = self.REQUEST\r\n      RESPONSE = request.RESPONSE\r\n      SESSION = request.SESSION\r\n      self._zmi_page_request()\r\n      RESPONSE.setHeader('Expires',DateTime(request['ZMI_TIME']-10000).toZone('GMT+1').rfc822())\r\n      RESPONSE.setHeader('Cache-Control', 'no-cache')\r\n      RESPONSE.setHeader('Pragma', 'no-cache')\r\n      RESPONSE.setHeader('Content-Type', 'text/html;charset=%s'%request['ZMS_CHARSET'])\r\n      if not request.get( 'preview'):\r\n        request.set( 'preview','preview')\r\n      langs = self.getLanguages(request)\r\n      if request.get('lang') not in langs:\r\n        request.set('lang',langs[0])\r\n      if request.get('manage_lang') not in self.getLocale().get_manage_langs():\r\n        request.set('manage_lang',self.get_manage_lang())\r\n      if not request.get('manage_tabs_message'):\r\n        request.set( 'manage_tabs_message',self.getConfProperty('ZMS.manage_tabs_message',''))\r\n      # manage_system\r\n      if request.form.has_key('zmi-manage-system'):\r\n        request.SESSION.set('zmi-manage-system',int(request.get('zmi-manage-system')))\r\n      # avoid declarative urls\r\n      physical_path = self.getPhysicalPath()\r\n      path_to_handle = request['URL0'][len(request['BASE0']):].split('/')\r\n      path = path_to_handle[:-1]\r\n      if self.getDocumentElement().id in path and len(filter(lambda x:x.find('.')>0 or x.startswith('manage_'),path))==0:\r\n        for i in range(len(path)):\r\n          if path[:-(i+1)] != physical_path[:-(i+1)]:\r\n            path[:-(i+1)] = physical_path[:-(i+1)]\r\n        new_path = path+[path_to_handle[-1]]\r\n        if path_to_handle != new_path:\r\n          request.RESPONSE.redirect('/'.join(new_path))", "line_changes": {"deleted": [{"line_no": 26, "char_start": 1313, "char_end": 1395, "line": "      if len(filter(lambda x:x.find('.')>0 or x.startswith('manage_'),path))==0:\r\n"}], "added": [{"line_no": 26, "char_start": 1313, "char_end": 1436, "line": "      if self.getDocumentElement().id in path and len(filter(lambda x:x.find('.')>0 or x.startswith('manage_'),path))==0:\r\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1322, "char_end": 1363, "chars": "self.getDocumentElement().id in path and "}]}, "commit_link": "github.com/zms-publishing/zms4/commit/3f28620d475220dfdb06f79787158ac50727c61a", "file_name": "ZMSItem.py", "vul_type": "cwe-022"}
{"func_name": "nntp_hcache_namer", "func_src_before": "static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  return snprintf(dest, destlen, \"%s.hcache\", path);\n}", "func_src_after": "static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  int count = snprintf(dest, destlen, \"%s.hcache\", path);\n\n  /* Strip out any directories in the path */\n  char *first = strchr(dest, '/');\n  char *last = strrchr(dest, '/');\n  if (first && last && (last > first))\n  {\n    memmove(first, last, strlen(last) + 1);\n    count -= (last - first);\n  }\n\n  return count;\n}", "line_changes": {"deleted": [{"line_no": 3, "char_start": 77, "char_end": 130, "line": "  return snprintf(dest, destlen, \"%s.hcache\", path);\n"}], "added": [{"line_no": 3, "char_start": 77, "char_end": 135, "line": "  int count = snprintf(dest, destlen, \"%s.hcache\", path);\n"}, {"line_no": 4, "char_start": 135, "char_end": 136, "line": "\n"}, {"line_no": 5, "char_start": 136, "char_end": 182, "line": "  /* Strip out any directories in the path */\n"}, {"line_no": 6, "char_start": 182, "char_end": 217, "line": "  char *first = strchr(dest, '/');\n"}, {"line_no": 7, "char_start": 217, "char_end": 252, "line": "  char *last = strrchr(dest, '/');\n"}, {"line_no": 8, "char_start": 252, "char_end": 291, "line": "  if (first && last && (last > first))\n"}, {"line_no": 9, "char_start": 291, "char_end": 295, "line": "  {\n"}, {"line_no": 10, "char_start": 295, "char_end": 339, "line": "    memmove(first, last, strlen(last) + 1);\n"}, {"line_no": 11, "char_start": 339, "char_end": 368, "line": "    count -= (last - first);\n"}, {"line_no": 12, "char_start": 368, "char_end": 372, "line": "  }\n"}, {"line_no": 13, "char_start": 372, "char_end": 373, "line": "\n"}, {"line_no": 14, "char_start": 373, "char_end": 389, "line": "  return count;\n"}]}, "char_changes": {"deleted": [{"char_start": 79, "char_end": 81, "chars": "re"}, {"char_start": 83, "char_end": 84, "chars": "r"}], "added": [{"char_start": 79, "char_end": 81, "chars": "in"}, {"char_start": 82, "char_end": 85, "chars": " co"}, {"char_start": 87, "char_end": 90, "chars": "t ="}, {"char_start": 133, "char_end": 387, "chars": ";\n\n  /* Strip out any directories in the path */\n  char *first = strchr(dest, '/');\n  char *last = strrchr(dest, '/');\n  if (first && last && (last > first))\n  {\n    memmove(first, last, strlen(last) + 1);\n    count -= (last - first);\n  }\n\n  return count"}]}, "commit_link": "github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e", "file_name": "newsrc.c", "vul_type": "cwe-022"}
{"func_name": "TarFileReader::extract", "func_src_before": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n\n  LOG_DEBUG(5, \"Extracting: \" << path);\n\n  return extract(*SystemUtilities::oopen(path));\n}", "func_src_after": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) {\n    path += \"/\" + getFilename();\n\n    // Check that path is under the target directory\n    string a = SystemUtilities::getCanonicalPath(_path);\n    string b = SystemUtilities::getCanonicalPath(path);\n    if (!String::startsWith(b, a))\n      THROW(\"Tar path points outside of the extraction directory: \" << path);\n  }\n\n  LOG_DEBUG(5, \"Extracting: \" << path);\n\n  switch (getType()) {\n  case NORMAL_FILE: case CONTIGUOUS_FILE:\n    return extract(*SystemUtilities::oopen(path));\n  case DIRECTORY: SystemUtilities::ensureDirectory(path); break;\n  default: THROW(\"Unsupported tar file type \" << getType());\n  }\n\n  return getFilename();\n}", "line_changes": {"deleted": [{"line_no": 6, "char_start": 180, "char_end": 251, "line": "  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n"}, {"line_no": 10, "char_start": 293, "char_end": 342, "line": "  return extract(*SystemUtilities::oopen(path));\n"}], "added": [{"line_no": 6, "char_start": 180, "char_end": 224, "line": "  if (SystemUtilities::isDirectory(path)) {\n"}, {"line_no": 7, "char_start": 224, "char_end": 257, "line": "    path += \"/\" + getFilename();\n"}, {"line_no": 8, "char_start": 257, "char_end": 258, "line": "\n"}, {"line_no": 10, "char_start": 311, "char_end": 368, "line": "    string a = SystemUtilities::getCanonicalPath(_path);\n"}, {"line_no": 11, "char_start": 368, "char_end": 424, "line": "    string b = SystemUtilities::getCanonicalPath(path);\n"}, {"line_no": 12, "char_start": 424, "char_end": 459, "line": "    if (!String::startsWith(b, a))\n"}, {"line_no": 13, "char_start": 459, "char_end": 537, "line": "      THROW(\"Tar path points outside of the extraction directory: \" << path);\n"}, {"line_no": 14, "char_start": 537, "char_end": 541, "line": "  }\n"}, {"line_no": 18, "char_start": 583, "char_end": 606, "line": "  switch (getType()) {\n"}, {"line_no": 19, "char_start": 606, "char_end": 648, "line": "  case NORMAL_FILE: case CONTIGUOUS_FILE:\n"}, {"line_no": 20, "char_start": 648, "char_end": 699, "line": "    return extract(*SystemUtilities::oopen(path));\n"}, {"line_no": 21, "char_start": 699, "char_end": 764, "line": "  case DIRECTORY: SystemUtilities::ensureDirectory(path); break;\n"}, {"line_no": 22, "char_start": 764, "char_end": 825, "line": "  default: THROW(\"Unsupported tar file type \" << getType());\n"}, {"line_no": 23, "char_start": 825, "char_end": 829, "line": "  }\n"}, {"line_no": 24, "char_start": 829, "char_end": 830, "line": "\n"}, {"line_no": 25, "char_start": 830, "char_end": 854, "line": "  return getFilename();\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 222, "char_end": 228, "chars": "{\n    "}, {"char_start": 260, "char_end": 544, "chars": "  // Check that path is under the target directory\n    string a = SystemUtilities::getCanonicalPath(_path);\n    string b = SystemUtilities::getCanonicalPath(path);\n    if (!String::startsWith(b, a))\n      THROW(\"Tar path points outside of the extraction directory: \" << path);\n  }\n\n  "}, {"char_start": 585, "char_end": 652, "chars": "switch (getType()) {\n  case NORMAL_FILE: case CONTIGUOUS_FILE:\n    "}, {"char_start": 696, "char_end": 851, "chars": ");\n  case DIRECTORY: SystemUtilities::ensureDirectory(path); break;\n  default: THROW(\"Unsupported tar file type \" << getType());\n  }\n\n  return getFilename("}]}, "commit_link": "github.com/CauldronDevelopmentLLC/cbang/commit/1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7", "file_name": "src/cbang/tar/TarFileReader.cpp", "vul_type": "cwe-022"}
{"func_name": "handle_method_call", "func_src_before": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}", "func_src_after": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (!allowed_problem_dir(problem_id))\n        {\n            return_InvalidProblemDir_error(invocation, problem_id);\n            return;\n        }\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        if (!allowed_problem_dir(problem_id))\n        {\n            return_InvalidProblemDir_error(invocation, problem_id);\n            return;\n        }\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name\", element);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}", "line_changes": {"deleted": [], "added": [{"line_no": 259, "char_start": 9073, "char_end": 9119, "line": "        if (!allowed_problem_dir(problem_id))\n"}, {"line_no": 260, "char_start": 9119, "char_end": 9129, "line": "        {\n"}, {"line_no": 261, "char_start": 9129, "char_end": 9197, "line": "            return_InvalidProblemDir_error(invocation, problem_id);\n"}, {"line_no": 262, "char_start": 9197, "char_end": 9217, "line": "            return;\n"}, {"line_no": 263, "char_start": 9217, "char_end": 9227, "line": "        }\n"}, {"line_no": 264, "char_start": 9227, "char_end": 9228, "line": "\n"}, {"line_no": 324, "char_start": 11714, "char_end": 11760, "line": "        if (!allowed_problem_dir(problem_id))\n"}, {"line_no": 325, "char_start": 11760, "char_end": 11770, "line": "        {\n"}, {"line_no": 326, "char_start": 11770, "char_end": 11838, "line": "            return_InvalidProblemDir_error(invocation, problem_id);\n"}, {"line_no": 327, "char_start": 11838, "char_end": 11858, "line": "            return;\n"}, {"line_no": 328, "char_start": 11858, "char_end": 11868, "line": "        }\n"}, {"line_no": 329, "char_start": 11868, "char_end": 11869, "line": "\n"}, {"line_no": 447, "char_start": 16070, "char_end": 16117, "line": "        if (!str_is_correct_filename(element))\n"}, {"line_no": 448, "char_start": 16117, "char_end": 16127, "line": "        {\n"}, {"line_no": 449, "char_start": 16127, "char_end": 16196, "line": "            log_notice(\"'%s' is not a valid element name\", element);\n"}, {"line_no": 450, "char_start": 16196, "char_end": 16281, "line": "            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n"}, {"line_no": 451, "char_start": 16281, "char_end": 16348, "line": "            g_dbus_method_invocation_return_dbus_error(invocation,\n"}, {"line_no": 452, "char_start": 16348, "char_end": 16437, "line": "                                              \"org.freedesktop.problems.InvalidElement\",\n"}, {"line_no": 453, "char_start": 16437, "char_end": 16491, "line": "                                              error);\n"}, {"line_no": 454, "char_start": 16491, "char_end": 16492, "line": "\n"}, {"line_no": 455, "char_start": 16492, "char_end": 16517, "line": "            free(error);\n"}, {"line_no": 456, "char_start": 16517, "char_end": 16537, "line": "            return;\n"}, {"line_no": 457, "char_start": 16537, "char_end": 16547, "line": "        }\n"}, {"line_no": 458, "char_start": 16547, "char_end": 16548, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 9086, "char_end": 9241, "chars": "allowed_problem_dir(problem_id))\n        {\n            return_InvalidProblemDir_error(invocation, problem_id);\n            return;\n        }\n\n        if (!"}, {"char_start": 11712, "char_end": 11867, "chars": "\n\n        if (!allowed_problem_dir(problem_id))\n        {\n            return_InvalidProblemDir_error(invocation, problem_id);\n            return;\n        }"}, {"char_start": 16068, "char_end": 16546, "chars": "\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name\", element);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }"}]}, "commit_link": "github.com/abrt/abrt/commit/7a47f57975be0d285a2f20758e4572dca6d9cdd3", "file_name": "src/dbus/abrt-dbus.c", "vul_type": "cwe-022"}
{"func_name": "_inject_file_into_fs", "func_src_before": "def _inject_file_into_fs(fs, path, contents):\n    absolute_path = os.path.join(fs, path.lstrip('/'))\n    parent_dir = os.path.dirname(absolute_path)\n    utils.execute('mkdir', '-p', parent_dir, run_as_root=True)\n    utils.execute('tee', absolute_path, process_input=contents,\n          run_as_root=True)", "func_src_after": "def _inject_file_into_fs(fs, path, contents, append=False):\n    absolute_path = _join_and_check_path_within_fs(fs, path.lstrip('/'))\n\n    parent_dir = os.path.dirname(absolute_path)\n    utils.execute('mkdir', '-p', parent_dir, run_as_root=True)\n\n    args = []\n    if append:\n        args.append('-a')\n    args.append(absolute_path)\n\n    kwargs = dict(process_input=contents, run_as_root=True)\n\n    utils.execute('tee', *args, **kwargs)", "line_changes": {"deleted": [{"line_no": 5, "char_start": 212, "char_end": 276, "line": "    utils.execute('tee', absolute_path, process_input=contents,\n"}, {"line_no": 6, "char_start": 276, "char_end": 303, "line": "          run_as_root=True)\n"}], "added": [{"line_no": 1, "char_start": 0, "char_end": 60, "line": "def _inject_file_into_fs(fs, path, contents, append=False):\n"}, {"line_no": 2, "char_start": 60, "char_end": 133, "line": "    absolute_path = _join_and_check_path_within_fs(fs, path.lstrip('/'))\n"}, {"line_no": 3, "char_start": 133, "char_end": 134, "line": "\n"}, {"line_no": 6, "char_start": 245, "char_end": 246, "line": "\n"}, {"line_no": 7, "char_start": 246, "char_end": 260, "line": "    args = []\n"}, {"line_no": 8, "char_start": 260, "char_end": 275, "line": "    if append:\n"}, {"line_no": 9, "char_start": 275, "char_end": 301, "line": "        args.append('-a')\n"}, {"line_no": 10, "char_start": 301, "char_end": 332, "line": "    args.append(absolute_path)\n"}, {"line_no": 11, "char_start": 332, "char_end": 333, "line": "\n"}, {"line_no": 12, "char_start": 333, "char_end": 393, "line": "    kwargs = dict(process_input=contents, run_as_root=True)\n"}, {"line_no": 13, "char_start": 393, "char_end": 394, "line": "\n"}, {"line_no": 14, "char_start": 394, "char_end": 435, "line": "    utils.execute('tee', *args, **kwargs)\n"}]}, "char_changes": {"deleted": [{"char_start": 67, "char_end": 69, "chars": "s."}, {"char_start": 73, "char_end": 76, "chars": ".jo"}, {"char_start": 216, "char_end": 218, "chars": "ut"}, {"char_start": 219, "char_end": 220, "chars": "l"}, {"char_start": 222, "char_end": 224, "chars": "ex"}, {"char_start": 225, "char_end": 229, "chars": "cute"}, {"char_start": 231, "char_end": 234, "chars": "tee"}, {"char_start": 235, "char_end": 236, "chars": ","}, {"char_start": 250, "char_end": 251, "chars": ","}, {"char_start": 275, "char_end": 285, "chars": "\n         "}], "added": [{"char_start": 43, "char_end": 57, "chars": ", append=False"}, {"char_start": 80, "char_end": 82, "chars": "_j"}, {"char_start": 83, "char_end": 96, "chars": "in_and_check_"}, {"char_start": 100, "char_end": 105, "chars": "_with"}, {"char_start": 107, "char_end": 110, "chars": "_fs"}, {"char_start": 133, "char_end": 134, "chars": "\n"}, {"char_start": 245, "char_end": 246, "chars": "\n"}, {"char_start": 250, "char_end": 264, "chars": "args = []\n    "}, {"char_start": 265, "char_end": 286, "chars": "f append:\n        arg"}, {"char_start": 288, "char_end": 291, "chars": "app"}, {"char_start": 292, "char_end": 294, "chars": "nd"}, {"char_start": 296, "char_end": 298, "chars": "-a"}, {"char_start": 299, "char_end": 304, "chars": ")\n   "}, {"char_start": 306, "char_end": 318, "chars": "rgs.append(a"}, {"char_start": 330, "char_end": 333, "chars": ")\n\n"}, {"char_start": 334, "char_end": 351, "chars": "   kwargs = dict("}, {"char_start": 392, "char_end": 435, "chars": "\n\n    utils.execute('tee', *args, **kwargs)"}]}, "commit_link": "github.com/openstack/nova/commit/2427d4a99bed35baefd8f17ba422cb7aae8dcca7", "file_name": "nova/virt/disk/api.py", "vul_type": "cwe-022"}
{"func_name": "set_interface_var", "func_src_before": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t/* XXX: magic constant */\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}", "func_src_after": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t/* XXX: magic constant */\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\n\t/* No path traversal */\n\tif (strstr(name, \"..\") || strchr(name, '/'))\n\t\treturn -1;\n\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 10, "char_start": 239, "char_end": 264, "line": "\t/* No path traversal */\n"}, {"line_no": 11, "char_start": 264, "char_end": 310, "line": "\tif (strstr(name, \"..\") || strchr(name, '/'))\n"}, {"line_no": 12, "char_start": 310, "char_end": 323, "line": "\t\treturn -1;\n"}, {"line_no": 13, "char_start": 323, "char_end": 324, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 240, "char_end": 325, "chars": "/* No path traversal */\n\tif (strstr(name, \"..\") || strchr(name, '/'))\n\t\treturn -1;\n\n\t"}]}, "commit_link": "github.com/reubenhwk/radvd/commit/92e22ca23e52066da2258df8c76a2dca8a428bcc", "file_name": "device-linux.c", "vul_type": "cwe-022"}
{"func_name": "cut", "func_src_before": "    def cut(self, key):\n        try:\n            self.etcd.delete(os.path.join(self.namespace, key))\n        except etcd.EtcdKeyNotFound:\n            return False\n        except etcd.EtcdException as err:\n            log_error(\"Error removing key %s: [%r]\" % (key, repr(err)))\n            raise CSStoreError('Error occurred while trying to cut key')\n        return True", "func_src_after": "    def cut(self, key):\n        try:\n            self.etcd.delete(self._absolute_key(key))\n        except etcd.EtcdKeyNotFound:\n            return False\n        except etcd.EtcdException as err:\n            log_error(\"Error removing key %s: [%r]\" % (key, repr(err)))\n            raise CSStoreError('Error occurred while trying to cut key')\n        return True", "line_changes": {"deleted": [{"line_no": 3, "char_start": 37, "char_end": 101, "line": "            self.etcd.delete(os.path.join(self.namespace, key))\n"}], "added": [{"line_no": 3, "char_start": 37, "char_end": 91, "line": "            self.etcd.delete(self._absolute_key(key))\n"}]}, "char_changes": {"deleted": [{"char_start": 66, "char_end": 79, "chars": "os.path.join("}, {"char_start": 84, "char_end": 85, "chars": "n"}, {"char_start": 86, "char_end": 88, "chars": "me"}, {"char_start": 89, "char_end": 92, "chars": "pac"}, {"char_start": 93, "char_end": 95, "chars": ", "}], "added": [{"char_start": 71, "char_end": 72, "chars": "_"}, {"char_start": 73, "char_end": 79, "chars": "bsolut"}, {"char_start": 80, "char_end": 82, "chars": "_k"}, {"char_start": 83, "char_end": 85, "chars": "y("}]}, "commit_link": "github.com/latchset/custodia/commit/785fc87f38b4811bc4ce43a0a9b2267ee7d500b4", "file_name": "custodia/store/etcdstore.py", "vul_type": "cwe-022"}
{"func_name": "wiki_handle_http_request", "func_src_before": "wiki_handle_http_request(HttpRequest *req)\n{\n  HttpResponse *res      = http_response_new(req);\n  char         *page     = http_request_get_path_info(req); \n  char         *command  = http_request_get_query_string(req); \n  char         *wikitext = \"\";\n\n  util_dehttpize(page); \t/* remove any encoding on the requested\n\t\t\t\t   page name.                           */\n\n  if (!strcmp(page, \"/\"))\n    {\n      if (access(\"WikiHome\", R_OK) != 0)\n\twiki_redirect(res, \"/WikiHome?create\");\n      page = \"/WikiHome\";\n    }\n\n  if (!strcmp(page, \"/styles.css\"))\n    {\n      /*  Return CSS page */\n      http_response_set_content_type(res, \"text/css\");\n      http_response_printf(res, \"%s\", CssData);\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"/favicon.ico\"))\n    {\n      /*  Return favicon */\n      http_response_set_content_type(res, \"image/ico\");\n      http_response_set_data(res, FaviconData, FaviconDataLen);\n      http_response_send(res);\n      exit(0);\n    }\n\n\n  page = page + 1; \t\t/* skip slash */\n\n  if (!strncmp(page, \"api/\", 4))\n    {\n      char *p;\n\n      page += 4; \n      for (p=page; *p != '\\0'; p++)\n\tif (*p=='?') { *p ='\\0'; break; }\n      \n      wiki_handle_rest_call(req, res, page); \n      exit(0);\n    }\n\n  /* A little safety. issue a malformed request for any paths,\n   * There shouldn't need to be any..\n   */\n  if (strchr(page, '/'))\n    {\n      http_response_set_status(res, 404, \"Not Found\");\n      http_response_printf(res, \"<html><body>404 Not Found</body></html>\\n\");\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"Changes\"))\n    {\n      wiki_show_changes_page(res);\n    }\n  else if (!strcmp(page, \"ChangesRss\"))\n    {\n      wiki_show_changes_page_rss(res);\n    }\n  else if (!strcmp(page, \"Search\"))\n    {\n      wiki_show_search_results_page(res, http_request_param_get(req, \"expr\"));\n    }\n  else if (!strcmp(page, \"Create\"))\n    {\n      if ( (wikitext = http_request_param_get(req, \"title\")) != NULL)\n\t{\n\t  /* create page and redirect */\n\t  wiki_redirect(res, http_request_param_get(req, \"title\"));\n\t}\n      else\n\t{\n\t   /* show create page form  */\n\t  wiki_show_create_page(res);\n\t}\n    }\n  else\n    {\n      /* TODO: dont blindly write wikitext data to disk */\n      if ( (wikitext = http_request_param_get(req, \"wikitext\")) != NULL)\n\t{\n\t  file_write(page, wikitext);\t      \n\t}\n\n      if (access(page, R_OK) == 0) \t/* page exists */\n\t{\n\t  wikitext = file_read(page);\n\t  \n\t  if (!strcmp(command, \"edit\"))\n\t    {\n\t      /* print edit page */\n\t      wiki_show_edit_page(res, wikitext, page);\n\t    }\n\t  else\n\t    {\n\t      wiki_show_page(res, wikitext, page);\n\t    }\n\t}\n      else\n\t{\n\t  if (!strcmp(command, \"create\"))\n\t    {\n\t      wiki_show_edit_page(res, NULL, page);\n\t    }\n\t  else\n\t    {\n\t      char buf[1024];\n\t      snprintf(buf, 1024, \"%s?create\", page);\n\t      wiki_redirect(res, buf);\n\t    }\n\t}\n    }\n\n}", "func_src_after": "wiki_handle_http_request(HttpRequest *req)\n{\n  HttpResponse *res      = http_response_new(req);\n  char         *page     = http_request_get_path_info(req); \n  char         *command  = http_request_get_query_string(req); \n  char         *wikitext = \"\";\n\n  util_dehttpize(page); \t/* remove any encoding on the requested\n\t\t\t\t   page name.                           */\n\n  if (!strcmp(page, \"/\"))\n    {\n      if (access(\"WikiHome\", R_OK) != 0)\n\twiki_redirect(res, \"/WikiHome?create\");\n      page = \"/WikiHome\";\n    }\n\n  if (!strcmp(page, \"/styles.css\"))\n    {\n      /*  Return CSS page */\n      http_response_set_content_type(res, \"text/css\");\n      http_response_printf(res, \"%s\", CssData);\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"/favicon.ico\"))\n    {\n      /*  Return favicon */\n      http_response_set_content_type(res, \"image/ico\");\n      http_response_set_data(res, FaviconData, FaviconDataLen);\n      http_response_send(res);\n      exit(0);\n    }\n\n\n  page = page + 1; \t\t/* skip slash */\n\n  if (!strncmp(page, \"api/\", 4))\n    {\n      char *p;\n\n      page += 4; \n      for (p=page; *p != '\\0'; p++)\n\tif (*p=='?') { *p ='\\0'; break; }\n      \n      wiki_handle_rest_call(req, res, page); \n      exit(0);\n    }\n\n  /* A little safety. issue a malformed request for any paths,\n   * There shouldn't need to be any..\n   */\n  if (!page_name_is_good(page))\n    {\n      http_response_set_status(res, 404, \"Not Found\");\n      http_response_printf(res, \"<html><body>404 Not Found</body></html>\\n\");\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"Changes\"))\n    {\n      wiki_show_changes_page(res);\n    }\n  else if (!strcmp(page, \"ChangesRss\"))\n    {\n      wiki_show_changes_page_rss(res);\n    }\n  else if (!strcmp(page, \"Search\"))\n    {\n      wiki_show_search_results_page(res, http_request_param_get(req, \"expr\"));\n    }\n  else if (!strcmp(page, \"Create\"))\n    {\n      if ( (wikitext = http_request_param_get(req, \"title\")) != NULL)\n\t{\n\t  /* create page and redirect */\n\t  wiki_redirect(res, http_request_param_get(req, \"title\"));\n\t}\n      else\n\t{\n\t   /* show create page form  */\n\t  wiki_show_create_page(res);\n\t}\n    }\n  else\n    {\n      /* TODO: dont blindly write wikitext data to disk */\n      if ( (wikitext = http_request_param_get(req, \"wikitext\")) != NULL)\n\t{\n\t  file_write(page, wikitext);\t      \n\t}\n\n      if (access(page, R_OK) == 0) \t/* page exists */\n\t{\n\t  wikitext = file_read(page);\n\t  \n\t  if (!strcmp(command, \"edit\"))\n\t    {\n\t      /* print edit page */\n\t      wiki_show_edit_page(res, wikitext, page);\n\t    }\n\t  else\n\t    {\n\t      wiki_show_page(res, wikitext, page);\n\t    }\n\t}\n      else\n\t{\n\t  if (!strcmp(command, \"create\"))\n\t    {\n\t      wiki_show_edit_page(res, NULL, page);\n\t    }\n\t  else\n\t    {\n\t      char buf[1024];\n\t      snprintf(buf, 1024, \"%s?create\", page);\n\t      wiki_redirect(res, buf);\n\t    }\n\t}\n    }\n\n}", "line_changes": {"deleted": [{"line_no": 54, "char_start": 1350, "char_end": 1375, "line": "  if (strchr(page, '/'))\n"}], "added": [{"line_no": 54, "char_start": 1350, "char_end": 1382, "line": "  if (!page_name_is_good(page))\n"}]}, "char_changes": {"deleted": [{"char_start": 1357, "char_end": 1362, "chars": "trchr"}, {"char_start": 1367, "char_end": 1372, "chars": ", '/'"}], "added": [{"char_start": 1356, "char_end": 1368, "chars": "!page_name_i"}, {"char_start": 1369, "char_end": 1374, "chars": "_good"}]}, "commit_link": "github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea", "file_name": "src/wiki.c", "vul_type": "cwe-022"}
{"func_name": "candidate_paths_for_url", "func_src_before": "    def candidate_paths_for_url(self, url):\n        for root, prefix in self.directories:\n            if url.startswith(prefix):\n                yield os.path.join(root, url[len(prefix):])", "func_src_after": "    def candidate_paths_for_url(self, url):\n        for root, prefix in self.directories:\n            if url.startswith(prefix):\n                path = os.path.join(root, url[len(prefix):])\n                if os.path.commonprefix((root, path)) == root:\n                    yield path", "line_changes": {"deleted": [{"line_no": 4, "char_start": 129, "char_end": 188, "line": "                yield os.path.join(root, url[len(prefix):])\n"}], "added": [{"line_no": 4, "char_start": 129, "char_end": 190, "line": "                path = os.path.join(root, url[len(prefix):])\n"}, {"line_no": 5, "char_start": 190, "char_end": 253, "line": "                if os.path.commonprefix((root, path)) == root:\n"}, {"line_no": 6, "char_start": 253, "char_end": 283, "line": "                    yield path\n"}]}, "char_changes": {"deleted": [{"char_start": 145, "char_end": 150, "chars": "yield"}], "added": [{"char_start": 145, "char_end": 151, "chars": "path ="}, {"char_start": 189, "char_end": 283, "chars": "\n                if os.path.commonprefix((root, path)) == root:\n                    yield path"}]}, "commit_link": "github.com/evansd/whitenoise/commit/4d8a3ab1e97d7ddb18b3fa8b4909c92bad5529c6", "file_name": "whitenoise/base.py", "vul_type": "cwe-022"}
{"func_name": "updateKey", "func_src_before": "def updateKey(client):\n\t\"\"\"Updates the contents of a key that already exists in our system.\n\tReturns an error if the specified key doesn't exist for the specified user.\n\t\"\"\"\n\tglobal NOT_FOUND\n\tglobal CREATED\n\n\tvalidateClient(client)\n\n\tclient_pub_key = loadClientRSAKey(client)\n\ttoken_data = decodeRequestToken(request.data, client_pub_key)\n\tvalidateNewKeyData(token_data)\n\n\t# Use 'w' flag to replace existing key file with the new key data\n\tif os.path.isfile('keys/%s/%s.key' % (client, token_data['name'])):\n\t\twith open('keys/%s/%s.key' % (client, token_data['name']), 'w') as f:\n\t\t\tf.write(token_data['key'])\n\telse:\n\t\traise FoxlockError(NOT_FOUND, \"Key '%s' not found\" % token_data['name'])\n\n\treturn 'Key successfully updated', CREATED", "func_src_after": "def updateKey(client):\n\t\"\"\"Updates the contents of a key that already exists in our system.\n\tReturns an error if the specified key doesn't exist for the specified user.\n\t\"\"\"\n\tglobal NOT_FOUND\n\tglobal CREATED\n\n\tvalidateClient(client)\n\tclient_pub_key = loadClientRSAKey(client)\n\ttoken_data = decodeRequestToken(request.data, client_pub_key)\n\tvalidateNewKeyData(token_data)\n\tvalidateKeyName(token_data['name'])\n\n\t# Use 'w' flag to replace existing key file with the new key data\n\tif os.path.isfile('keys/%s/%s.key' % (client, token_data['name'])):\n\t\twith open('keys/%s/%s.key' % (client, token_data['name']), 'w') as f:\n\t\t\tf.write(token_data['key'])\n\telse:\n\t\traise FoxlockError(NOT_FOUND, \"Key '%s' not found\" % token_data['name'])\n\n\treturn 'Key successfully updated', CREATED", "line_changes": {"deleted": [{"line_no": 9, "char_start": 233, "char_end": 234, "line": "\n"}], "added": [{"line_no": 12, "char_start": 371, "char_end": 408, "line": "\tvalidateKeyName(token_data['name'])\n"}]}, "char_changes": {"deleted": [{"char_start": 233, "char_end": 234, "chars": "\n"}], "added": [{"char_start": 369, "char_end": 406, "chars": ")\n\tvalidateKeyName(token_data['name']"}]}, "commit_link": "github.com/Mimickal/FoxLock/commit/7c665e556987f4e2c1a75e143a1e80ae066ad833", "file_name": "impl.py", "vul_type": "cwe-022"}
{"func_name": "create_basename_core", "func_src_before": "def create_basename_core(basename):\n    try:\n        basename = basename.casefold()\n    except Exception:\n        basename = basename.lower()\n\n    basename = basename.replace(' ', '-')\n    basename = re.sub(r'<[^>]*>', r'', basename)\n    basename = re.sub(r'[^a-z0-9\\-]', r'', basename)\n    basename = re.sub(r'\\-\\-', r'-', basename)\n    basename = urllib.parse.quote_plus(basename)\n\n    return basename", "func_src_after": "def create_basename_core(basename):\n    try:\n        basename = basename.casefold()\n    except Exception:\n        basename = basename.lower()\n\n    basename = re.sub(r'[ \\./]', r'-', basename)\n    basename = re.sub(r'<[^>]*>', r'', basename)\n    basename = re.sub(r'[^a-z0-9\\-]', r'', basename)\n    basename = re.sub(r'\\-\\-', r'-', basename)\n    basename = urllib.parse.quote_plus(basename)\n\n    return basename", "line_changes": {"deleted": [{"line_no": 7, "char_start": 143, "char_end": 185, "line": "    basename = basename.replace(' ', '-')\n"}], "added": [{"line_no": 7, "char_start": 143, "char_end": 192, "line": "    basename = re.sub(r'[ \\./]', r'-', basename)\n"}]}, "char_changes": {"deleted": [{"char_start": 158, "char_end": 165, "chars": "basenam"}, {"char_start": 168, "char_end": 175, "chars": "eplace("}], "added": [{"char_start": 158, "char_end": 159, "chars": "r"}, {"char_start": 161, "char_end": 164, "chars": "sub"}, {"char_start": 165, "char_end": 166, "chars": "r"}, {"char_start": 167, "char_end": 168, "chars": "["}, {"char_start": 169, "char_end": 173, "chars": "\\./]"}, {"char_start": 176, "char_end": 177, "chars": "r"}, {"char_start": 180, "char_end": 190, "chars": ", basename"}]}, "commit_link": "github.com/syegulalp/mercury/commit/3f7c7442fa49aec37577dbdb47ce11a848e7bd03", "file_name": "MeTal/core/utils.py", "vul_type": "cwe-022"}
{"func_name": "get", "func_src_before": "    def get(self, key):\n        try:\n            result = self.etcd.get(os.path.join(self.namespace, key))\n        except etcd.EtcdException as err:\n            log_error(\"Error fetching key %s: [%r]\" % (key, repr(err)))\n            raise CSStoreError('Error occurred while trying to get key')\n        return result.value", "func_src_after": "    def get(self, key):\n        try:\n            result = self.etcd.get(self._absolute_key(key))\n        except etcd.EtcdException as err:\n            log_error(\"Error fetching key %s: [%r]\" % (key, repr(err)))\n            raise CSStoreError('Error occurred while trying to get key')\n        return result.value", "line_changes": {"deleted": [{"line_no": 3, "char_start": 37, "char_end": 107, "line": "            result = self.etcd.get(os.path.join(self.namespace, key))\n"}], "added": [{"line_no": 3, "char_start": 37, "char_end": 97, "line": "            result = self.etcd.get(self._absolute_key(key))\n"}]}, "char_changes": {"deleted": [{"char_start": 72, "char_end": 85, "chars": "os.path.join("}, {"char_start": 90, "char_end": 91, "chars": "n"}, {"char_start": 92, "char_end": 94, "chars": "me"}, {"char_start": 95, "char_end": 98, "chars": "pac"}, {"char_start": 99, "char_end": 101, "chars": ", "}], "added": [{"char_start": 77, "char_end": 78, "chars": "_"}, {"char_start": 79, "char_end": 85, "chars": "bsolut"}, {"char_start": 86, "char_end": 88, "chars": "_k"}, {"char_start": 89, "char_end": 91, "chars": "y("}]}, "commit_link": "github.com/latchset/custodia/commit/785fc87f38b4811bc4ce43a0a9b2267ee7d500b4", "file_name": "custodia/store/etcdstore.py", "vul_type": "cwe-022"}
{"func_name": "PHYSICALPATH_FUNC", "func_src_before": "PHYSICALPATH_FUNC(mod_alias_physical_handler) {\n\tplugin_data *p = p_d;\n\tint uri_len, basedir_len;\n\tchar *uri_ptr;\n\tsize_t k;\n\n\tif (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;\n\n\tmod_alias_patch_connection(srv, con, p);\n\n\t/* not to include the tailing slash */\n\tbasedir_len = buffer_string_length(con->physical.basedir);\n\tif ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;\n\turi_len = buffer_string_length(con->physical.path) - basedir_len;\n\turi_ptr = con->physical.path->ptr + basedir_len;\n\n\tfor (k = 0; k < p->conf.alias->used; k++) {\n\t\tdata_string *ds = (data_string *)p->conf.alias->data[k];\n\t\tint alias_len = buffer_string_length(ds->key);\n\n\t\tif (alias_len > uri_len) continue;\n\t\tif (buffer_is_empty(ds->key)) continue;\n\n\t\tif (0 == (con->conf.force_lowercase_filenames ?\n\t\t\t\t\tstrncasecmp(uri_ptr, ds->key->ptr, alias_len) :\n\t\t\t\t\tstrncmp(uri_ptr, ds->key->ptr, alias_len))) {\n\t\t\t/* matched */\n\n\t\t\tbuffer_copy_buffer(con->physical.basedir, ds->value);\n\t\t\tbuffer_copy_buffer(srv->tmp_buf, ds->value);\n\t\t\tbuffer_append_string(srv->tmp_buf, uri_ptr + alias_len);\n\t\t\tbuffer_copy_buffer(con->physical.path, srv->tmp_buf);\n\n\t\t\treturn HANDLER_GO_ON;\n\t\t}\n\t}\n\n\t/* not found */\n\treturn HANDLER_GO_ON;\n}", "func_src_after": "PHYSICALPATH_FUNC(mod_alias_physical_handler) {\n\tplugin_data *p = p_d;\n\tint uri_len, basedir_len;\n\tchar *uri_ptr;\n\tsize_t k;\n\n\tif (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;\n\n\tmod_alias_patch_connection(srv, con, p);\n\n\t/* not to include the tailing slash */\n\tbasedir_len = buffer_string_length(con->physical.basedir);\n\tif ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;\n\turi_len = buffer_string_length(con->physical.path) - basedir_len;\n\turi_ptr = con->physical.path->ptr + basedir_len;\n\n\tfor (k = 0; k < p->conf.alias->used; k++) {\n\t\tdata_string *ds = (data_string *)p->conf.alias->data[k];\n\t\tint alias_len = buffer_string_length(ds->key);\n\n\t\tif (alias_len > uri_len) continue;\n\t\tif (buffer_is_empty(ds->key)) continue;\n\n\t\tif (0 == (con->conf.force_lowercase_filenames ?\n\t\t\t\t\tstrncasecmp(uri_ptr, ds->key->ptr, alias_len) :\n\t\t\t\t\tstrncmp(uri_ptr, ds->key->ptr, alias_len))) {\n\t\t\t/* matched */\n\n\t\t\t/* check for path traversal in url-path following alias if key\n\t\t\t * does not end in slash, but replacement value ends in slash */\n\t\t\tif (uri_ptr[alias_len] == '.') {\n\t\t\t\tchar *s = uri_ptr + alias_len + 1;\n\t\t\t\tif (*s == '.') ++s;\n\t\t\t\tif (*s == '/' || *s == '\\0') {\n\t\t\t\t\tsize_t vlen = buffer_string_length(ds->value);\n\t\t\t\t\tif (0 != alias_len && ds->key->ptr[alias_len-1] != '/'\n\t\t\t\t\t    && 0 != vlen && ds->value->ptr[vlen-1] == '/') {\n\t\t\t\t\t\tcon->http_status = 403;\n\t\t\t\t\t\treturn HANDLER_FINISHED;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbuffer_copy_buffer(con->physical.basedir, ds->value);\n\t\t\tbuffer_copy_buffer(srv->tmp_buf, ds->value);\n\t\t\tbuffer_append_string(srv->tmp_buf, uri_ptr + alias_len);\n\t\t\tbuffer_copy_buffer(con->physical.path, srv->tmp_buf);\n\n\t\t\treturn HANDLER_GO_ON;\n\t\t}\n\t}\n\n\t/* not found */\n\treturn HANDLER_GO_ON;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 29, "char_start": 928, "char_end": 994, "line": "\t\t\t/* check for path traversal in url-path following alias if key\n"}, {"line_no": 30, "char_start": 994, "char_end": 1062, "line": "\t\t\t * does not end in slash, but replacement value ends in slash */\n"}, {"line_no": 31, "char_start": 1062, "char_end": 1098, "line": "\t\t\tif (uri_ptr[alias_len] == '.') {\n"}, {"line_no": 32, "char_start": 1098, "char_end": 1137, "line": "\t\t\t\tchar *s = uri_ptr + alias_len + 1;\n"}, {"line_no": 33, "char_start": 1137, "char_end": 1161, "line": "\t\t\t\tif (*s == '.') ++s;\n"}, {"line_no": 34, "char_start": 1161, "char_end": 1196, "line": "\t\t\t\tif (*s == '/' || *s == '\\0') {\n"}, {"line_no": 35, "char_start": 1196, "char_end": 1248, "line": "\t\t\t\t\tsize_t vlen = buffer_string_length(ds->value);\n"}, {"line_no": 36, "char_start": 1248, "char_end": 1308, "line": "\t\t\t\t\tif (0 != alias_len && ds->key->ptr[alias_len-1] != '/'\n"}, {"line_no": 37, "char_start": 1308, "char_end": 1366, "line": "\t\t\t\t\t    && 0 != vlen && ds->value->ptr[vlen-1] == '/') {\n"}, {"line_no": 38, "char_start": 1366, "char_end": 1396, "line": "\t\t\t\t\t\tcon->http_status = 403;\n"}, {"line_no": 39, "char_start": 1396, "char_end": 1427, "line": "\t\t\t\t\t\treturn HANDLER_FINISHED;\n"}, {"line_no": 40, "char_start": 1427, "char_end": 1434, "line": "\t\t\t\t\t}\n"}, {"line_no": 41, "char_start": 1434, "char_end": 1440, "line": "\t\t\t\t}\n"}, {"line_no": 42, "char_start": 1440, "char_end": 1445, "line": "\t\t\t}\n"}, {"line_no": 43, "char_start": 1445, "char_end": 1446, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 931, "char_end": 1449, "chars": "/* check for path traversal in url-path following alias if key\n\t\t\t * does not end in slash, but replacement value ends in slash */\n\t\t\tif (uri_ptr[alias_len] == '.') {\n\t\t\t\tchar *s = uri_ptr + alias_len + 1;\n\t\t\t\tif (*s == '.') ++s;\n\t\t\t\tif (*s == '/' || *s == '\\0') {\n\t\t\t\t\tsize_t vlen = buffer_string_length(ds->value);\n\t\t\t\t\tif (0 != alias_len && ds->key->ptr[alias_len-1] != '/'\n\t\t\t\t\t    && 0 != vlen && ds->value->ptr[vlen-1] == '/') {\n\t\t\t\t\t\tcon->http_status = 403;\n\t\t\t\t\t\treturn HANDLER_FINISHED;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t"}]}, "commit_link": "github.com/lighttpd/lighttpd1.4/commit/2105dae0f9d7a964375ce681e53cb165375f84c1", "file_name": "src/mod_alias.c", "vul_type": "cwe-022"}
{"func_name": "download_check_files", "func_src_before": "    def download_check_files(self, filelist):\n        # only admins and allowed users may download\n        if not cherrypy.session['admin']:\n            uo = self.useroptions.forUser(self.getUserId())\n            if not uo.getOptionValue('media.may_download'):\n                return 'not_permitted'\n        # make sure nobody tries to escape from basedir\n        for f in filelist:\n            if '/../' in f:\n                return 'invalid_file'\n        # make sure all files are smaller than maximum download size\n        size_limit = cherry.config['media.maximum_download_size']\n        try:\n            if self.model.file_size_within_limit(filelist, size_limit):\n                return 'ok'\n            else:\n                return 'too_big'\n        except OSError as e:        # use OSError for python2 compatibility\n            return str(e)", "func_src_after": "    def download_check_files(self, filelist):\n        # only admins and allowed users may download\n        if not cherrypy.session['admin']:\n            uo = self.useroptions.forUser(self.getUserId())\n            if not uo.getOptionValue('media.may_download'):\n                return 'not_permitted'\n        # make sure nobody tries to escape from basedir\n        for f in filelist:\n            # don't allow to traverse up in the file system\n            if '/../' in f or f.startswith('../'):\n                return 'invalid_file'\n            # CVE-2015-8309: do not allow absolute file paths\n            if os.path.isabs(f):\n                return 'invalid_file'\n        # make sure all files are smaller than maximum download size\n        size_limit = cherry.config['media.maximum_download_size']\n        try:\n            if self.model.file_size_within_limit(filelist, size_limit):\n                return 'ok'\n            else:\n                return 'too_big'\n        except OSError as e:        # use OSError for python2 compatibility\n            return str(e)", "line_changes": {"deleted": [{"line_no": 9, "char_start": 383, "char_end": 411, "line": "            if '/../' in f:\n"}], "added": [{"line_no": 10, "char_start": 443, "char_end": 494, "line": "            if '/../' in f or f.startswith('../'):\n"}, {"line_no": 11, "char_start": 494, "char_end": 532, "line": "                return 'invalid_file'\n"}, {"line_no": 13, "char_start": 594, "char_end": 627, "line": "            if os.path.isabs(f):\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 395, "char_end": 455, "chars": "# don't allow to traverse up in the file system\n            "}, {"char_start": 469, "char_end": 625, "chars": " or f.startswith('../'):\n                return 'invalid_file'\n            # CVE-2015-8309: do not allow absolute file paths\n            if os.path.isabs(f)"}]}, "commit_link": "github.com/devsnd/cherrymusic/commit/62dec34a1ea0741400dd6b6c660d303dcd651e86", "file_name": "cherrymusicserver/httphandler.py", "vul_type": "cwe-022"}
{"func_name": "get_files", "func_src_before": "    def get_files(self, submit_id, password=None, astree=False):\n        \"\"\"\n        Returns files from a submitted analysis.\n        @param password: The password to unlock container archives with\n        @param astree: sflock option; determines the format in which the files are returned\n        @return: A tree of files\n        \"\"\"\n        submit = Database().view_submit(submit_id)\n        files, duplicates = [], []\n\n        for data in submit.data[\"data\"]:\n            if data[\"type\"] == \"file\":\n                filename = Storage.get_filename_from_path(data[\"data\"])\n                filepath = os.path.join(submit.tmp_path, data[\"data\"])\n                filedata = open(filepath, \"rb\").read()\n\n                unpacked = sflock.unpack(\n                    filepath=filename, contents=filedata,\n                    password=password, duplicates=duplicates\n                )\n\n                if astree:\n                    unpacked = unpacked.astree()\n\n                files.append(unpacked)\n            elif data[\"type\"] == \"url\":\n                files.append({\n                    \"filename\": data[\"data\"],\n                    \"filepath\": \"\",\n                    \"relapath\": \"\",\n                    \"selected\": True,\n                    \"size\": 0,\n                    \"type\": \"url\",\n                    \"package\": \"ie\",\n                    \"extrpath\": [],\n                    \"duplicate\": False,\n                    \"children\": [],\n                    \"mime\": \"text/html\",\n                    \"finger\": {\n                        \"magic_human\": \"url\",\n                        \"magic\": \"url\"\n                    }\n                })\n            else:\n                raise RuntimeError(\n                    \"Unknown data entry type: %s\" % data[\"type\"]\n                )\n\n        return {\n            \"files\": files,\n            \"path\": submit.tmp_path,\n        }", "func_src_after": "    def get_files(self, submit_id, password=None, astree=False):\n        \"\"\"\n        Returns files from a submitted analysis.\n        @param password: The password to unlock container archives with\n        @param astree: sflock option; determines the format in which the files are returned\n        @return: A tree of files\n        \"\"\"\n        submit = Database().view_submit(submit_id)\n        files, duplicates = [], []\n\n        for data in submit.data[\"data\"]:\n            if data[\"type\"] == \"file\":\n                filename = Storage.get_filename_from_path(data[\"data\"])\n                filepath = os.path.join(submit.tmp_path, filename)\n\n                unpacked = sflock.unpack(\n                    filepath=filepath, password=password, duplicates=duplicates\n                )\n\n                if astree:\n                    unpacked = unpacked.astree(sanitize=True)\n\n                files.append(unpacked)\n            elif data[\"type\"] == \"url\":\n                files.append({\n                    \"filename\": data[\"data\"],\n                    \"filepath\": \"\",\n                    \"relapath\": \"\",\n                    \"selected\": True,\n                    \"size\": 0,\n                    \"type\": \"url\",\n                    \"package\": \"ie\",\n                    \"extrpath\": [],\n                    \"duplicate\": False,\n                    \"children\": [],\n                    \"mime\": \"text/html\",\n                    \"finger\": {\n                        \"magic_human\": \"url\",\n                        \"magic\": \"url\"\n                    }\n                })\n            else:\n                raise RuntimeError(\n                    \"Unknown data entry type: %s\" % data[\"type\"]\n                )\n\n        return files", "line_changes": {"deleted": [{"line_no": 14, "char_start": 574, "char_end": 645, "line": "                filepath = os.path.join(submit.tmp_path, data[\"data\"])\n"}, {"line_no": 15, "char_start": 645, "char_end": 700, "line": "                filedata = open(filepath, \"rb\").read()\n"}, {"line_no": 18, "char_start": 743, "char_end": 801, "line": "                    filepath=filename, contents=filedata,\n"}, {"line_no": 19, "char_start": 801, "char_end": 862, "line": "                    password=password, duplicates=duplicates\n"}, {"line_no": 23, "char_start": 908, "char_end": 957, "line": "                    unpacked = unpacked.astree()\n"}, {"line_no": 49, "char_start": 1776, "char_end": 1793, "line": "        return {\n"}, {"line_no": 50, "char_start": 1793, "char_end": 1821, "line": "            \"files\": files,\n"}, {"line_no": 51, "char_start": 1821, "char_end": 1858, "line": "            \"path\": submit.tmp_path,\n"}, {"line_no": 52, "char_start": 1858, "char_end": 1867, "line": "        }\n"}], "added": [{"line_no": 14, "char_start": 574, "char_end": 641, "line": "                filepath = os.path.join(submit.tmp_path, filename)\n"}, {"line_no": 17, "char_start": 684, "char_end": 764, "line": "                    filepath=filepath, password=password, duplicates=duplicates\n"}, {"line_no": 21, "char_start": 810, "char_end": 872, "line": "                    unpacked = unpacked.astree(sanitize=True)\n"}, {"line_no": 47, "char_start": 1691, "char_end": 1711, "line": "        return files\n"}]}, "char_changes": {"deleted": [{"char_start": 631, "char_end": 661, "chars": "data[\"data\"])\n                "}, {"char_start": 665, "char_end": 675, "chars": "data = ope"}, {"char_start": 676, "char_end": 682, "chars": "(filep"}, {"char_start": 683, "char_end": 694, "chars": "th, \"rb\").r"}, {"char_start": 695, "char_end": 698, "chars": "ad("}, {"char_start": 776, "char_end": 796, "chars": "name, contents=filed"}, {"char_start": 798, "char_end": 799, "chars": "a"}, {"char_start": 800, "char_end": 820, "chars": "\n                   "}, {"char_start": 1791, "char_end": 1806, "chars": "{\n            \""}, {"char_start": 1811, "char_end": 1867, "chars": "\": files,\n            \"path\": submit.tmp_path,\n        }"}], "added": [{"char_start": 637, "char_end": 638, "chars": "m"}, {"char_start": 717, "char_end": 718, "chars": "p"}, {"char_start": 720, "char_end": 721, "chars": "h"}, {"char_start": 857, "char_end": 870, "chars": "sanitize=True"}]}, "commit_link": "github.com/cuckoosandbox/cuckoo/commit/168cabf86730d56b7fa319278bf0f0034052666a", "file_name": "cuckoo/core/submit.py", "vul_type": "cwe-022"}
{"func_name": "handle", "func_src_before": "    def handle(self, keepalive=True, initial_timeout=None):\n        # we are requested to skip processing and keep the previous values\n        if self.skip:\n            return self.response.handle()\n\n        # default to no keepalive in case something happens while even trying ensure we have a request\n        self.keepalive = False\n\n        self.headers = HTTPHeaders()\n\n        # if initial_timeout is set, only wait that long for the initial request line\n        if initial_timeout:\n            self.connection.settimeout(initial_timeout)\n        else:\n            self.connection.settimeout(self.timeout)\n\n        # get request line\n        try:\n            # ignore empty lines waiting on request\n            request = '\\r\\n'\n            while request == '\\r\\n':\n                request = self.rfile.readline(max_line_size + 1).decode(http_encoding)\n        # if read hits timeout or has some other error, ignore the request\n        except Exception:\n            return True\n\n        # ignore empty requests\n        if not request:\n            return True\n\n        # we have a request, go back to normal timeout\n        if initial_timeout:\n            self.connection.settimeout(self.timeout)\n\n        # remove \\r\\n from the end\n        self.request_line = request[:-2]\n\n        # set some reasonable defaults in case the worst happens and we need to tell the client\n        self.method = ''\n        self.resource = '/'\n\n        try:\n            # HTTP Status 414\n            if len(request) > max_line_size:\n                raise HTTPError(414)\n\n            # HTTP Status 400\n            if request[-2:] != '\\r\\n':\n                raise HTTPError(400)\n\n            # try the request line and error out if can't parse it\n            try:\n                self.method, self.resource, self.request_http = self.request_line.split()\n            # HTTP Status 400\n            except ValueError:\n                raise HTTPError(400)\n\n            # HTTP Status 505\n            if self.request_http != http_version:\n                raise HTTPError(505)\n\n            # read and parse request headers\n            while True:\n                line = self.rfile.readline(max_line_size + 1).decode(http_encoding)\n\n                # hit end of headers\n                if line == '\\r\\n':\n                    break\n\n                self.headers.add(line)\n\n            # if we are requested to close the connection after we finish, do so\n            if self.headers.get('Connection') == 'close':\n                self.keepalive = False\n            # else since we are sure we have a request and have read all of the request data, keepalive for more later (if allowed)\n            else:\n                self.keepalive = keepalive\n\n            # find a matching regex to handle the request with\n            for regex, handler in self.server.routes.items():\n                match = regex.match(self.resource)\n                if match:\n                    # create a dictionary of groups\n                    groups = match.groupdict()\n                    values = groups.values()\n\n                    for idx, group in enumerate(match.groups()):\n                        if group not in values:\n                            groups[idx] = group\n\n                    # create handler\n                    self.handler = handler(self, self.response, groups)\n                    break\n            # HTTP Status 404\n            # if loop is not broken (handler is not found), raise a 404\n            else:\n                raise HTTPError(404)\n        # use DummyHandler so the error is raised again when ready for response\n        except Exception as error:\n            self.handler = DummyHandler(self, self.response, (), error)\n        finally:\n            # we finished listening and handling early errors and so let a response class now finish up the job of talking\n            return self.response.handle()", "func_src_after": "    def handle(self, keepalive=True, initial_timeout=None):\n        # we are requested to skip processing and keep the previous values\n        if self.skip:\n            return self.response.handle()\n\n        # default to no keepalive in case something happens while even trying ensure we have a request\n        self.keepalive = False\n\n        self.headers = HTTPHeaders()\n\n        # if initial_timeout is set, only wait that long for the initial request line\n        if initial_timeout:\n            self.connection.settimeout(initial_timeout)\n        else:\n            self.connection.settimeout(self.timeout)\n\n        # get request line\n        try:\n            # ignore empty lines waiting on request\n            request = '\\r\\n'\n            while request == '\\r\\n':\n                request = self.rfile.readline(max_line_size + 1).decode(http_encoding)\n        # if read hits timeout or has some other error, ignore the request\n        except Exception:\n            return True\n\n        # ignore empty requests\n        if not request:\n            return True\n\n        # we have a request, go back to normal timeout\n        if initial_timeout:\n            self.connection.settimeout(self.timeout)\n\n        # remove \\r\\n from the end\n        self.request_line = request[:-2]\n\n        # set some reasonable defaults in case the worst happens and we need to tell the client\n        self.method = ''\n        self.resource = '/'\n\n        try:\n            # HTTP Status 414\n            if len(request) > max_line_size:\n                raise HTTPError(414)\n\n            # HTTP Status 400\n            if request[-2:] != '\\r\\n':\n                raise HTTPError(400)\n\n            # try the request line and error out if can't parse it\n            try:\n                self.method, resource, self.request_http = self.request_line.split()\n                self.resource = urllib.parse.unquote(resource)\n            # HTTP Status 400\n            except ValueError:\n                raise HTTPError(400)\n\n            # HTTP Status 505\n            if self.request_http != http_version:\n                raise HTTPError(505)\n\n            # read and parse request headers\n            while True:\n                line = self.rfile.readline(max_line_size + 1).decode(http_encoding)\n\n                # hit end of headers\n                if line == '\\r\\n':\n                    break\n\n                self.headers.add(line)\n\n            # if we are requested to close the connection after we finish, do so\n            if self.headers.get('Connection') == 'close':\n                self.keepalive = False\n            # else since we are sure we have a request and have read all of the request data, keepalive for more later (if allowed)\n            else:\n                self.keepalive = keepalive\n\n            # find a matching regex to handle the request with\n            for regex, handler in self.server.routes.items():\n                match = regex.match(self.resource)\n                if match:\n                    # create a dictionary of groups\n                    groups = match.groupdict()\n                    values = groups.values()\n\n                    for idx, group in enumerate(match.groups()):\n                        if group not in values:\n                            groups[idx] = group\n\n                    # create handler\n                    self.handler = handler(self, self.response, groups)\n                    break\n            # HTTP Status 404\n            # if loop is not broken (handler is not found), raise a 404\n            else:\n                raise HTTPError(404)\n        # use DummyHandler so the error is raised again when ready for response\n        except Exception as error:\n            self.handler = DummyHandler(self, self.response, (), error)\n        finally:\n            # we finished listening and handling early errors and so let a response class now finish up the job of talking\n            return self.response.handle()", "line_changes": {"deleted": [{"line_no": 53, "char_start": 1744, "char_end": 1834, "line": "                self.method, self.resource, self.request_http = self.request_line.split()\n"}], "added": [{"line_no": 53, "char_start": 1744, "char_end": 1829, "line": "                self.method, resource, self.request_http = self.request_line.split()\n"}, {"line_no": 54, "char_start": 1829, "char_end": 1892, "line": "                self.resource = urllib.parse.unquote(resource)\n"}]}, "char_changes": {"deleted": [{"char_start": 1773, "char_end": 1778, "chars": "self."}], "added": [{"char_start": 1827, "char_end": 1890, "chars": ")\n                self.resource = urllib.parse.unquote(resource"}]}, "commit_link": "github.com/fkmclane/python-fooster-web/commit/80202a6d3788ad1212a162d19785c600025e6aa4", "file_name": "fooster/web/web.py", "vul_type": "cwe-022"}
{"func_name": "dd_delete_item", "func_src_before": "int dd_delete_item(struct dump_dir *dd, const char *name)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    char *path = concat_path_file(dd->dd_dirname, name);\n    int res = unlink(path);\n\n    if (res < 0)\n    {\n        if (errno == ENOENT)\n            errno = res = 0;\n        else\n            perror_msg(\"Can't delete file '%s'\", path);\n    }\n\n    free(path);\n    return res;\n}", "func_src_after": "int dd_delete_item(struct dump_dir *dd, const char *name)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot delete item. '%s' is not a valid file name\", name);\n\n    char *path = concat_path_file(dd->dd_dirname, name);\n    int res = unlink(path);\n\n    if (res < 0)\n    {\n        if (errno == ENOENT)\n            errno = res = 0;\n        else\n            perror_msg(\"Can't delete file '%s'\", path);\n    }\n\n    free(path);\n    return res;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 6, "char_start": 145, "char_end": 185, "line": "    if (!str_is_correct_filename(name))\n"}, {"line_no": 7, "char_start": 185, "char_end": 271, "line": "        error_msg_and_die(\"Cannot delete item. '%s' is not a valid file name\", name);\n"}, {"line_no": 8, "char_start": 271, "char_end": 272, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 149, "char_end": 276, "chars": "if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot delete item. '%s' is not a valid file name\", name);\n\n    "}]}, "commit_link": "github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277", "file_name": "src/lib/dump_dir.c", "vul_type": "cwe-022"}
{"func_name": "render", "func_src_before": "\tdef render(self, request):\n\t\taction = \"download\"\n\t\tif \"action\" in request.args:\n\t\t\taction = request.args[\"action\"][0]\n\n\t\tif \"file\" in request.args:\n\t\t\tfilename = request.args[\"file\"][0].decode('utf-8', 'ignore').encode('utf-8')\n\t\t\tfilename = re.sub(\"^/+\", \"/\", os.path.realpath(filename))\n\n\t\t\tif not os.path.exists(filename):\n\t\t\t\treturn \"File '%s' not found\" % (filename)\n\n\t\t\tif action == \"stream\":\n\t\t\t\tname = \"stream\"\n\t\t\t\tif \"name\" in request.args:\n\t\t\t\t\tname = request.args[\"name\"][0]\n\n\t\t\t\tport = config.OpenWebif.port.value\n\t\t\t\tproto = 'http'\n\t\t\t\tif request.isSecure():\n\t\t\t\t\tport = config.OpenWebif.https_port.value\n\t\t\t\t\tproto = 'https'\n\t\t\t\tourhost = request.getHeader('host')\n\t\t\t\tm = re.match('.+\\:(\\d+)$', ourhost)\n\t\t\t\tif m is not None:\n\t\t\t\t\tport = m.group(1)\n\n\t\t\t\tresponse = \"#EXTM3U\\n#EXTVLCOPT--http-reconnect=true\\n#EXTINF:-1,%s\\n%s://%s:%s/file?action=download&file=%s\" % (name, proto, request.getRequestHostname(), port, quote(filename))\n\t\t\t\trequest.setHeader(\"Content-Disposition\", 'attachment;filename=\"%s.m3u\"' % name)\n\t\t\t\trequest.setHeader(\"Content-Type\", \"application/x-mpegurl\")\n\t\t\t\treturn response\n\t\t\telif action == \"delete\":\n\t\t\t\trequest.setResponseCode(http.OK)\n\t\t\t\treturn \"TODO: DELETE FILE: %s\" % (filename)\n\t\t\telif action == \"download\":\n\t\t\t\trequest.setHeader(\"Content-Disposition\", \"attachment;filename=\\\"%s\\\"\" % (filename.split('/')[-1]))\n\t\t\t\trfile = static.File(filename, defaultType = \"application/octet-stream\")\n\t\t\t\treturn rfile.render(request)\n\t\t\telse: \n\t\t\t\treturn \"wrong action parameter\"\n\n\t\tif \"dir\" in request.args:\n\t\t\tpath = request.args[\"dir\"][0]\n\t\t\tpattern = '*'\n\t\t\tdata = []\n\t\t\tif \"pattern\" in request.args:\n\t\t\t\tpattern = request.args[\"pattern\"][0]\n\t\t\tdirectories = []\n\t\t\tfiles = []\n\t\t\tif fileExists(path):\n\t\t\t\ttry:\n\t\t\t\t\tfiles = glob.glob(path+'/'+pattern)\n\t\t\t\texcept:\n\t\t\t\t\tfiles = []\n\t\t\t\tfiles.sort()\n\t\t\t\ttmpfiles = files[:]\n\t\t\t\tfor x in tmpfiles:\n\t\t\t\t\tif os.path.isdir(x):\n\t\t\t\t\t\tdirectories.append(x + '/')\n\t\t\t\t\t\tfiles.remove(x)\n\t\t\t\tdata.append({\"result\": True,\"dirs\": directories,\"files\": files})\n\t\t\telse:\n\t\t\t\tdata.append({\"result\": False,\"message\": \"path %s not exits\" % (path)})\n\t\t\trequest.setHeader(\"content-type\", \"application/json; charset=utf-8\")\n\t\t\treturn json.dumps(data, indent=2)", "func_src_after": "\tdef render(self, request):\n\t\taction = \"download\"\n\t\tif \"action\" in request.args:\n\t\t\taction = request.args[\"action\"][0]\n\n\t\tif \"file\" in request.args:\n\t\t\tfilename = lenient_force_utf_8(request.args[\"file\"][0])\n\t\t\tfilename = sanitise_filename_slashes(os.path.realpath(filename))\n\n\t\t\tif not os.path.exists(filename):\n\t\t\t\treturn \"File '%s' not found\" % (filename)\n\n\t\t\tif action == \"stream\":\n\t\t\t\tname = \"stream\"\n\t\t\t\tif \"name\" in request.args:\n\t\t\t\t\tname = request.args[\"name\"][0]\n\n\t\t\t\tport = config.OpenWebif.port.value\n\t\t\t\tproto = 'http'\n\t\t\t\tif request.isSecure():\n\t\t\t\t\tport = config.OpenWebif.https_port.value\n\t\t\t\t\tproto = 'https'\n\t\t\t\tourhost = request.getHeader('host')\n\t\t\t\tm = re.match('.+\\:(\\d+)$', ourhost)\n\t\t\t\tif m is not None:\n\t\t\t\t\tport = m.group(1)\n\n\t\t\t\tresponse = \"#EXTM3U\\n#EXTVLCOPT--http-reconnect=true\\n#EXTINF:-1,%s\\n%s://%s:%s/file?action=download&file=%s\" % (name, proto, request.getRequestHostname(), port, quote(filename))\n\t\t\t\trequest.setHeader(\"Content-Disposition\", 'attachment;filename=\"%s.m3u\"' % name)\n\t\t\t\trequest.setHeader(\"Content-Type\", \"application/x-mpegurl\")\n\t\t\t\treturn response\n\t\t\telif action == \"delete\":\n\t\t\t\trequest.setResponseCode(http.OK)\n\t\t\t\treturn \"TODO: DELETE FILE: %s\" % (filename)\n\t\t\telif action == \"download\":\n\t\t\t\trequest.setHeader(\"Content-Disposition\", \"attachment;filename=\\\"%s\\\"\" % (filename.split('/')[-1]))\n\t\t\t\trfile = static.File(filename, defaultType = \"application/octet-stream\")\n\t\t\t\treturn rfile.render(request)\n\t\t\telse: \n\t\t\t\treturn \"wrong action parameter\"\n\n\t\tif \"dir\" in request.args:\n\t\t\tpath = request.args[\"dir\"][0]\n\t\t\tpattern = '*'\n\t\t\tdata = []\n\t\t\tif \"pattern\" in request.args:\n\t\t\t\tpattern = request.args[\"pattern\"][0]\n\t\t\tdirectories = []\n\t\t\tfiles = []\n\t\t\tif fileExists(path):\n\t\t\t\ttry:\n\t\t\t\t\tfiles = glob.glob(path+'/'+pattern)\n\t\t\t\texcept:\n\t\t\t\t\tfiles = []\n\t\t\t\tfiles.sort()\n\t\t\t\ttmpfiles = files[:]\n\t\t\t\tfor x in tmpfiles:\n\t\t\t\t\tif os.path.isdir(x):\n\t\t\t\t\t\tdirectories.append(x + '/')\n\t\t\t\t\t\tfiles.remove(x)\n\t\t\t\tdata.append({\"result\": True,\"dirs\": directories,\"files\": files})\n\t\t\telse:\n\t\t\t\tdata.append({\"result\": False,\"message\": \"path %s not exits\" % (path)})\n\t\t\trequest.setHeader(\"content-type\", \"application/json; charset=utf-8\")\n\t\t\treturn json.dumps(data, indent=2)", "line_changes": {"deleted": [{"line_no": 7, "char_start": 149, "char_end": 229, "line": "\t\t\tfilename = request.args[\"file\"][0].decode('utf-8', 'ignore').encode('utf-8')\n"}, {"line_no": 8, "char_start": 229, "char_end": 290, "line": "\t\t\tfilename = re.sub(\"^/+\", \"/\", os.path.realpath(filename))\n"}], "added": [{"line_no": 7, "char_start": 149, "char_end": 208, "line": "\t\t\tfilename = lenient_force_utf_8(request.args[\"file\"][0])\n"}, {"line_no": 8, "char_start": 208, "char_end": 276, "line": "\t\t\tfilename = sanitise_filename_slashes(os.path.realpath(filename))\n"}]}, "char_changes": {"deleted": [{"char_start": 186, "char_end": 227, "chars": ".decode('utf-8', 'ignore').encode('utf-8'"}, {"char_start": 243, "char_end": 244, "chars": "r"}, {"char_start": 245, "char_end": 246, "chars": "."}, {"char_start": 247, "char_end": 249, "chars": "ub"}, {"char_start": 250, "char_end": 262, "chars": "\"^/+\", \"/\", "}], "added": [{"char_start": 163, "char_end": 183, "chars": "lenient_force_utf_8("}, {"char_start": 222, "char_end": 238, "chars": "sanitise_filenam"}, {"char_start": 239, "char_end": 240, "chars": "_"}, {"char_start": 241, "char_end": 247, "chars": "lashes"}]}, "commit_link": "github.com/E2OpenPlugins/e2openplugin-OpenWebif/commit/a846b7664eda3a4c51a452e00638cf7337dc2013", "file_name": "plugin/controllers/file.py", "vul_type": "cwe-022"}
{"func_name": "_inject_net_into_fs", "func_src_before": "def _inject_net_into_fs(net, fs, execute=None):\n    \"\"\"Inject /etc/network/interfaces into the filesystem rooted at fs.\n\n    net is the contents of /etc/network/interfaces.\n    \"\"\"\n    netdir = os.path.join(os.path.join(fs, 'etc'), 'network')\n    utils.execute('mkdir', '-p', netdir, run_as_root=True)\n    utils.execute('chown', 'root:root', netdir, run_as_root=True)\n    utils.execute('chmod', 755, netdir, run_as_root=True)\n    netfile = os.path.join(netdir, 'interfaces')\n    utils.execute('tee', netfile, process_input=net, run_as_root=True)", "func_src_after": "def _inject_net_into_fs(net, fs, execute=None):\n    \"\"\"Inject /etc/network/interfaces into the filesystem rooted at fs.\n\n    net is the contents of /etc/network/interfaces.\n    \"\"\"\n    netdir = _join_and_check_path_within_fs(fs, 'etc', 'network')\n    utils.execute('mkdir', '-p', netdir, run_as_root=True)\n    utils.execute('chown', 'root:root', netdir, run_as_root=True)\n    utils.execute('chmod', 755, netdir, run_as_root=True)\n\n    netfile = os.path.join('etc', 'network', 'interfaces')\n    _inject_file_into_fs(fs, netfile, net)", "line_changes": {"deleted": [{"line_no": 6, "char_start": 181, "char_end": 243, "line": "    netdir = os.path.join(os.path.join(fs, 'etc'), 'network')\n"}, {"line_no": 10, "char_start": 426, "char_end": 475, "line": "    netfile = os.path.join(netdir, 'interfaces')\n"}, {"line_no": 11, "char_start": 475, "char_end": 545, "line": "    utils.execute('tee', netfile, process_input=net, run_as_root=True)\n"}], "added": [{"line_no": 6, "char_start": 181, "char_end": 247, "line": "    netdir = _join_and_check_path_within_fs(fs, 'etc', 'network')\n"}, {"line_no": 10, "char_start": 430, "char_end": 431, "line": "\n"}, {"line_no": 11, "char_start": 431, "char_end": 490, "line": "    netfile = os.path.join('etc', 'network', 'interfaces')\n"}, {"line_no": 12, "char_start": 490, "char_end": 532, "line": "    _inject_file_into_fs(fs, netfile, net)\n"}]}, "char_changes": {"deleted": [{"char_start": 194, "char_end": 202, "chars": "os.path."}, {"char_start": 206, "char_end": 210, "chars": "(os."}, {"char_start": 214, "char_end": 217, "chars": ".jo"}, {"char_start": 229, "char_end": 230, "chars": ")"}, {"char_start": 456, "char_end": 458, "chars": "di"}, {"char_start": 479, "char_end": 480, "chars": "u"}, {"char_start": 483, "char_end": 485, "chars": "s."}, {"char_start": 486, "char_end": 490, "chars": "xecu"}, {"char_start": 491, "char_end": 492, "chars": "e"}, {"char_start": 493, "char_end": 498, "chars": "'tee'"}, {"char_start": 509, "char_end": 523, "chars": "process_input="}, {"char_start": 526, "char_end": 544, "chars": ", run_as_root=True"}], "added": [{"char_start": 194, "char_end": 196, "chars": "_j"}, {"char_start": 197, "char_end": 210, "chars": "in_and_check_"}, {"char_start": 214, "char_end": 216, "chars": "_w"}, {"char_start": 221, "char_end": 224, "chars": "_fs"}, {"char_start": 430, "char_end": 431, "chars": "\n"}, {"char_start": 458, "char_end": 466, "chars": "'etc', '"}, {"char_start": 469, "char_end": 471, "chars": "wo"}, {"char_start": 472, "char_end": 474, "chars": "k'"}, {"char_start": 494, "char_end": 495, "chars": "_"}, {"char_start": 496, "char_end": 498, "chars": "nj"}, {"char_start": 501, "char_end": 505, "chars": "_fil"}, {"char_start": 506, "char_end": 509, "chars": "_in"}, {"char_start": 510, "char_end": 517, "chars": "o_fs(fs"}]}, "commit_link": "github.com/openstack/nova/commit/2427d4a99bed35baefd8f17ba422cb7aae8dcca7", "file_name": "nova/virt/disk/api.py", "vul_type": "cwe-022"}
{"func_name": "canonicalize", "func_src_before": "    def canonicalize(self):\n        \"\"\"::\n\n            path = path.canonicalize()\n\n        Canonicalize path. ::\n\n            # \"/foo/baz\"\n            Pyjo.Path.new('/foo/./bar/../baz').canonicalize()\n\n            # \"/../baz\"\n            Pyjo.Path.new('/foo/../bar/../../baz').canonicalize()\n        \"\"\"\n        parts = self.parts\n        i = 0\n        while i < len(parts):\n            if parts[i] == '.' or parts[i] == '':\n                parts.pop(i)\n            elif i < 1 or parts[i] != '..' or parts[i - 1] == '..':\n                i += 1\n            else:\n                i -= 1\n                parts.pop(i)\n                parts.pop(i)\n\n        if not parts:\n            self.trailing_slash = False\n\n        return self", "func_src_after": "    def canonicalize(self):\n        \"\"\"::\n\n            path = path.canonicalize()\n\n        Canonicalize path by resolving ``.`` and ``..``, in addition ``...`` will be\n        treated as ``.`` to protect from path traversal attacks.\n\n            # \"/foo/baz\"\n            Pyjo.Path.new('/foo/./bar/../baz').canonicalize()\n\n            # \"/../baz\"\n            Pyjo.Path.new('/foo/../bar/../../baz').canonicalize()\n\n            # \"/foo/bar\"\n            Pyjo.Path.new('/foo/.../bar').canonicalize()\n        \"\"\"\n        parts = self.parts\n        i = 0\n        while i < len(parts):\n            if parts[i] == '' or parts[i] == '.' or parts[i] == '...':\n                parts.pop(i)\n            elif i < 1 or parts[i] != '..' or parts[i - 1] == '..':\n                i += 1\n            else:\n                i -= 1\n                parts.pop(i)\n                parts.pop(i)\n\n        if not parts:\n            self.trailing_slash = False\n\n        return self", "line_changes": {"deleted": [{"line_no": 6, "char_start": 83, "char_end": 113, "line": "        Canonicalize path. ::\n"}, {"line_no": 17, "char_start": 375, "char_end": 425, "line": "            if parts[i] == '.' or parts[i] == '':\n"}], "added": [{"line_no": 6, "char_start": 83, "char_end": 168, "line": "        Canonicalize path by resolving ``.`` and ``..``, in addition ``...`` will be\n"}, {"line_no": 7, "char_start": 168, "char_end": 233, "line": "        treated as ``.`` to protect from path traversal attacks.\n"}, {"line_no": 14, "char_start": 412, "char_end": 413, "line": "\n"}, {"line_no": 16, "char_start": 438, "char_end": 495, "line": "            Pyjo.Path.new('/foo/.../bar').canonicalize()\n"}, {"line_no": 21, "char_start": 578, "char_end": 649, "line": "            if parts[i] == '' or parts[i] == '.' or parts[i] == '...':\n"}]}, "char_changes": {"deleted": [{"char_start": 110, "char_end": 112, "chars": "::"}], "added": [{"char_start": 108, "char_end": 124, "chars": " by resolving ``"}, {"char_start": 125, "char_end": 171, "chars": "`` and ``..``, in addition ``...`` will be\n   "}, {"char_start": 172, "char_end": 232, "chars": "    treated as ``.`` to protect from path traversal attacks."}, {"char_start": 411, "char_end": 494, "chars": "\n\n            # \"/foo/bar\"\n            Pyjo.Path.new('/foo/.../bar').canonicalize()"}, {"char_start": 606, "char_end": 624, "chars": "' or parts[i] == '"}, {"char_start": 643, "char_end": 646, "chars": "..."}]}, "commit_link": "github.com/dex4er/Pyjoyment/commit/e4b115bc80c41615b2133091af3a74ee5d995c2e", "file_name": "Pyjo/Path.py", "vul_type": "cwe-022"}
{"func_name": "CWebSock::GetSkinPath", "func_src_before": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n\n    return sRet + \"/\";\n}", "func_src_after": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    const CString sSkin = sSkinName.Replace_n(\"/\", \"_\").Replace_n(\".\", \"_\");\n\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkin;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkin;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkin;\n        }\n    }\n\n    return sRet + \"/\";\n}", "line_changes": {"deleted": [{"line_no": 2, "char_start": 58, "char_end": 130, "line": "    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n"}, {"line_no": 5, "char_start": 162, "char_end": 230, "line": "        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n"}, {"line_no": 8, "char_start": 266, "char_end": 323, "line": "            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n"}], "added": [{"line_no": 2, "char_start": 58, "char_end": 135, "line": "    const CString sSkin = sSkinName.Replace_n(\"/\", \"_\").Replace_n(\".\", \"_\");\n"}, {"line_no": 3, "char_start": 135, "char_end": 136, "line": "\n"}, {"line_no": 4, "char_start": 136, "char_end": 204, "line": "    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkin;\n"}, {"line_no": 7, "char_start": 236, "char_end": 300, "line": "        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkin;\n"}, {"line_no": 10, "char_start": 336, "char_end": 389, "line": "            sRet = CString(_SKINDIR_) + \"/\" + sSkin;\n"}]}, "char_changes": {"deleted": [{"char_start": 124, "char_end": 128, "chars": "Name"}, {"char_start": 224, "char_end": 228, "chars": "Name"}, {"char_start": 317, "char_end": 321, "chars": "Name"}], "added": [{"char_start": 62, "char_end": 140, "chars": "const CString sSkin = sSkinName.Replace_n(\"/\", \"_\").Replace_n(\".\", \"_\");\n\n    "}]}, "commit_link": "github.com/znc/znc/commit/a4a5aeeb17d32937d8c7d743dae9a4cc755ce773", "file_name": "src/WebModules.cpp", "vul_type": "cwe-022"}
{"func_name": "addKey", "func_src_before": "def addKey(client):\n\t\"\"\"Adds a new key with the specified name and contents.\n\tReturns an error if a key with the specified name already exists.\n\t\"\"\"\n\tglobal BAD_REQUEST\n\tglobal CREATED\n\n\tvalidateClient(client)\n\n\tclient_pub_key = loadClientRSAKey(client)\n\ttoken_data = decodeRequestToken(request.data, client_pub_key)\n\tvalidateNewKeyData(token_data)\n\n\t# Use 'x' flag so we can throw an error if a key with this name already exists\n\ttry:\n\t\twith open('keys/%s/%s.key' % (client, token_data['name']), 'x') as f:\n\t\t\tf.write(token_data['key'])\n\texcept FileExistsError:\n\t\traise FoxlockError(BAD_REQUEST, \"Key '%s' already exists\" % token_data['name'])\n\n\treturn 'Key successfully created', CREATED", "func_src_after": "def addKey(client):\n\t\"\"\"Adds a new key with the specified name and contents.\n\tReturns an error if a key with the specified name already exists.\n\t\"\"\"\n\tglobal BAD_REQUEST\n\tglobal CREATED\n\n\tvalidateClient(client)\n\tclient_pub_key = loadClientRSAKey(client)\n\ttoken_data = decodeRequestToken(request.data, client_pub_key)\n\tvalidateNewKeyData(token_data)\n\tvalidateKeyName(token_data['name'])\n\n\t# Use 'x' flag so we can throw an error if a key with this name already exists\n\ttry:\n\t\twith open('keys/%s/%s.key' % (client, token_data['name']), 'x') as f:\n\t\t\tf.write(token_data['key'])\n\texcept FileExistsError:\n\t\traise FoxlockError(BAD_REQUEST, \"Key '%s' already exists\" % token_data['name'])\n\n\treturn 'Key successfully created', CREATED", "line_changes": {"deleted": [{"line_no": 9, "char_start": 210, "char_end": 211, "line": "\n"}], "added": [{"line_no": 12, "char_start": 348, "char_end": 385, "line": "\tvalidateKeyName(token_data['name'])\n"}]}, "char_changes": {"deleted": [{"char_start": 210, "char_end": 211, "chars": "\n"}], "added": [{"char_start": 346, "char_end": 383, "chars": ")\n\tvalidateKeyName(token_data['name']"}]}, "commit_link": "github.com/Mimickal/FoxLock/commit/7c665e556987f4e2c1a75e143a1e80ae066ad833", "file_name": "impl.py", "vul_type": "cwe-022"}
{"func_name": "dd_save_text", "func_src_before": "void dd_save_text(struct dump_dir *dd, const char *name, const char *data)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}", "func_src_after": "void dd_save_text(struct dump_dir *dd, const char *name, const char *data)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}", "line_changes": {"deleted": [], "added": [{"line_no": 6, "char_start": 162, "char_end": 202, "line": "    if (!str_is_correct_filename(name))\n"}, {"line_no": 7, "char_start": 202, "char_end": 286, "line": "        error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);\n"}, {"line_no": 8, "char_start": 286, "char_end": 287, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 166, "char_end": 291, "chars": "if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);\n\n    "}]}, "commit_link": "github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277", "file_name": "src/lib/dump_dir.c", "vul_type": "cwe-022"}
{"func_name": "misc_file_checks", "func_src_before": "    def misc_file_checks(self):\n\n        print_header(\"MISC FILE CHECKS\")\n\n        #\n        # Check for recommended and mandatory files\n        #\n\n        filenames = (\"manifest.json\", \"LICENSE\", \"README.md\",\n                     \"scripts/install\", \"scripts/remove\",\n                     \"scripts/upgrade\",\n                     \"scripts/backup\", \"scripts/restore\")\n        non_mandatory = (\"script/backup\", \"script/restore\")\n\n        for filename in filenames:\n            if file_exists(self.path + \"/\" + filename):\n                continue\n            elif filename in non_mandatory:\n                print_warning(\"Consider adding a file %s\" % filename)\n            else:\n                print_error(\"File %s is mandatory\" % filename)\n\n        #\n        # Deprecated php-fpm.ini thing\n        #\n\n        if file_exists(self.path + \"/conf/php-fpm.ini\"):\n            print_warning(\n                \"Using a separate php-fpm.ini file is deprecated. \"\n                \"Please merge your php-fpm directives directly in the pool file. \"\n                \"(c.f. https://github.com/YunoHost-Apps/nextcloud_ynh/issues/138 )\"\n            )\n\n        #\n        # Deprecated usage of 'add_header' in nginx conf\n        #\n\n        for filename in os.listdir(self.path + \"/conf\"):\n            if not os.path.isfile(self.path + \"/conf/\" + filename):\n                continue\n            content = open(self.path + \"/conf/\" + filename).read()\n            if \"location\" in content and \"add_header\" in content:\n                print_warning(\n                    \"Do not use 'add_header' in the nginx conf. Use 'more_set_headers' instead. \"\n                    \"(See https://www.peterbe.com/plog/be-very-careful-with-your-add_header-in-nginx \"\n                    \"and https://github.com/openresty/headers-more-nginx-module#more_set_headers )\"\n                )", "func_src_after": "    def misc_file_checks(self):\n\n        print_header(\"MISC FILE CHECKS\")\n\n        #\n        # Check for recommended and mandatory files\n        #\n\n        filenames = (\"manifest.json\", \"LICENSE\", \"README.md\",\n                     \"scripts/install\", \"scripts/remove\",\n                     \"scripts/upgrade\",\n                     \"scripts/backup\", \"scripts/restore\")\n        non_mandatory = (\"script/backup\", \"script/restore\")\n\n        for filename in filenames:\n            if file_exists(self.path + \"/\" + filename):\n                continue\n            elif filename in non_mandatory:\n                print_warning(\"Consider adding a file %s\" % filename)\n            else:\n                print_error(\"File %s is mandatory\" % filename)\n\n        #\n        # Deprecated php-fpm.ini thing\n        #\n\n        if file_exists(self.path + \"/conf/php-fpm.ini\"):\n            print_warning(\n                \"Using a separate php-fpm.ini file is deprecated. \"\n                \"Please merge your php-fpm directives directly in the pool file. \"\n                \"(c.f. https://github.com/YunoHost-Apps/nextcloud_ynh/issues/138 )\"\n            )\n\n        #\n        # Analyze nginx conf\n        # - Deprecated usage of 'add_header' in nginx conf\n        # - Spot path traversal issue vulnerability\n        #\n\n        for filename in os.listdir(self.path + \"/conf\"):\n            # Ignore subdirs or filename not containing nginx in the name\n            if not os.path.isfile(self.path + \"/conf/\" + filename) or \"nginx\" not in filename:\n                continue\n\n            #\n            # 'add_header' usage\n            #\n            content = open(self.path + \"/conf/\" + filename).read()\n            if \"location\" in content and \"add_header\" in content:\n                print_warning(\n                    \"Do not use 'add_header' in the nginx conf. Use 'more_set_headers' instead. \"\n                    \"(See https://www.peterbe.com/plog/be-very-careful-with-your-add_header-in-nginx \"\n                    \"and https://github.com/openresty/headers-more-nginx-module#more_set_headers )\"\n                )\n\n            #\n            # Path traversal issues\n            #\n            lines = open(self.path + \"/conf/\" + filename).readlines()\n            lines = [line.strip() for line in lines if not line.strip().startswith(\"#\")]\n            # Let's find the first location line\n            location_line = None\n            path_traversal_vulnerable = False\n            lines_iter = lines.__iter__()\n            for line in lines_iter:\n                if line.startswith(\"location\"):\n                    location_line = line\n                    break\n            # Look at the next lines for an 'alias' directive\n            if location_line is not None:\n                for line in lines_iter:\n                    if line.startswith(\"location\"):\n                        # Entering a new location block ... abort here\n                        # and assume there's no alias block later...\n                        break\n                    if line.startswith(\"alias\"):\n                        # We should definitely check for path traversal issue\n                        # Does the location target ends with / ?\n                        target = location_line.split()[-2]\n                        if not target.endswith(\"/\"):\n                            path_traversal_vulnerable = True\n                        break\n            if path_traversal_vulnerable:\n                print_warning(\n                    \"The nginx configuration appears vulnerable to path traversal as explained in \"\n                    \"https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/\\n\"\n                    \"To fix it, look at the first lines of the nginx conf of the example app : \"\n                    \"https://github.com/YunoHost/example_ynh/blob/master/conf/nginx.conf\"\n                )", "line_changes": {"deleted": [{"line_no": 39, "char_start": 1268, "char_end": 1336, "line": "            if not os.path.isfile(self.path + \"/conf/\" + filename):\n"}], "added": [{"line_no": 42, "char_start": 1425, "char_end": 1520, "line": "            if not os.path.isfile(self.path + \"/conf/\" + filename) or \"nginx\" not in filename:\n"}, {"line_no": 44, "char_start": 1545, "char_end": 1546, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1153, "char_end": 1184, "chars": "Analyze nginx conf\n        # - "}, {"char_start": 1240, "char_end": 1292, "chars": " - Spot path traversal issue vulnerability\n        #"}, {"char_start": 1363, "char_end": 1437, "chars": "# Ignore subdirs or filename not containing nginx in the name\n            "}, {"char_start": 1491, "char_end": 1518, "chars": " or \"nginx\" not in filename"}, {"char_start": 1544, "char_end": 1606, "chars": "\n\n            #\n            # 'add_header' usage\n            #"}, {"char_start": 2089, "char_end": 3888, "chars": "\n\n            #\n            # Path traversal issues\n            #\n            lines = open(self.path + \"/conf/\" + filename).readlines()\n            lines = [line.strip() for line in lines if not line.strip().startswith(\"#\")]\n            # Let's find the first location line\n            location_line = None\n            path_traversal_vulnerable = False\n            lines_iter = lines.__iter__()\n            for line in lines_iter:\n                if line.startswith(\"location\"):\n                    location_line = line\n                    break\n            # Look at the next lines for an 'alias' directive\n            if location_line is not None:\n                for line in lines_iter:\n                    if line.startswith(\"location\"):\n                        # Entering a new location block ... abort here\n                        # and assume there's no alias block later...\n                        break\n                    if line.startswith(\"alias\"):\n                        # We should definitely check for path traversal issue\n                        # Does the location target ends with / ?\n                        target = location_line.split()[-2]\n                        if not target.endswith(\"/\"):\n                            path_traversal_vulnerable = True\n                        break\n            if path_traversal_vulnerable:\n                print_warning(\n                    \"The nginx configuration appears vulnerable to path traversal as explained in \"\n                    \"https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/\\n\"\n                    \"To fix it, look at the first lines of the nginx conf of the example app : \"\n                    \"https://github.com/YunoHost/example_ynh/blob/master/conf/nginx.conf\"\n                )"}]}, "commit_link": "github.com/YunoHost/package_linter/commit/f6e98894cfe841aedaa7efd590937f0255193913", "file_name": "package_linter.py", "vul_type": "cwe-022"}
{"func_name": "dd_save_binary", "func_src_before": "void dd_save_binary(struct dump_dir* dd, const char* name, const char* data, unsigned size)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}", "func_src_after": "void dd_save_binary(struct dump_dir* dd, const char* name, const char* data, unsigned size)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot save binary. '%s' is not a valid file name\", name);\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}", "line_changes": {"deleted": [], "added": [{"line_no": 6, "char_start": 179, "char_end": 219, "line": "    if (!str_is_correct_filename(name))\n"}, {"line_no": 7, "char_start": 219, "char_end": 305, "line": "        error_msg_and_die(\"Cannot save binary. '%s' is not a valid file name\", name);\n"}, {"line_no": 8, "char_start": 305, "char_end": 306, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 183, "char_end": 310, "chars": "if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot save binary. '%s' is not a valid file name\", name);\n\n    "}]}, "commit_link": "github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277", "file_name": "src/lib/dump_dir.c", "vul_type": "cwe-022"}
{"func_name": "pascal_case", "func_src_before": "def pascal_case(value: str) -> str:\n    return stringcase.pascalcase(value)", "func_src_after": "def pascal_case(value: str) -> str:\n    return stringcase.pascalcase(_sanitize(value))", "line_changes": {"deleted": [{"line_no": 2, "char_start": 36, "char_end": 75, "line": "    return stringcase.pascalcase(value)\n"}], "added": [{"line_no": 2, "char_start": 36, "char_end": 86, "line": "    return stringcase.pascalcase(_sanitize(value))\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 69, "char_end": 79, "chars": "_sanitize("}, {"char_start": 85, "char_end": 86, "chars": ")"}]}, "commit_link": "github.com/openapi-generators/openapi-python-client/commit/3e7dfae5d0b3685abf1ede1bc6c086a116ac4746", "file_name": "openapi_python_client/utils.py", "vul_type": "cwe-022"}
{"func_name": "cleanup_pathname", "func_src_before": "cleanup_pathname(struct archive_write_disk *a)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = a->name;\n\tif (*src == '\\0') {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\t/* Skip leading '/'. */\n\tif (*src == '/')\n\t\tseparator = *src++;\n\n\t/* Scan the pathname one element at a time. */\n\tfor (;;) {\n\t\t/* src points to first char after '/' */\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t/* Found '//', ignore second one. */\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t/* Ignore trailing '.' */\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t/* Skip './'. */\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t/* Conditionally warn about '..' */\n\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Note: Under no circumstances do we\n\t\t\t\t * remove '..' elements.  In\n\t\t\t\t * particular, restoring\n\t\t\t\t * '/foo/../bar/' should create the\n\t\t\t\t * 'foo' dir as a side-effect.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\t/* Copy current element, including leading '/'. */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t/* Skip '/' separator. */\n\t\tseparator = *src++;\n\t}\n\t/*\n\t * We've just copied zero or more path elements, not including the\n\t * final '/'.\n\t */\n\tif (dest == a->name) {\n\t\t/*\n\t\t * Nothing got copied.  The path must have been something\n\t\t * like '.' or '/' or './' or '/././././/./'.\n\t\t */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t/* Terminate the result. */\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}", "func_src_after": "cleanup_pathname(struct archive_write_disk *a)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = a->name;\n\tif (*src == '\\0') {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\t/* Skip leading '/'. */\n\tif (*src == '/') {\n\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t                  \"Path is absolute\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\tseparator = *src++;\n\t}\n\n\t/* Scan the pathname one element at a time. */\n\tfor (;;) {\n\t\t/* src points to first char after '/' */\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t/* Found '//', ignore second one. */\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t/* Ignore trailing '.' */\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t/* Skip './'. */\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t/* Conditionally warn about '..' */\n\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Note: Under no circumstances do we\n\t\t\t\t * remove '..' elements.  In\n\t\t\t\t * particular, restoring\n\t\t\t\t * '/foo/../bar/' should create the\n\t\t\t\t * 'foo' dir as a side-effect.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\t/* Copy current element, including leading '/'. */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t/* Skip '/' separator. */\n\t\tseparator = *src++;\n\t}\n\t/*\n\t * We've just copied zero or more path elements, not including the\n\t * final '/'.\n\t */\n\tif (dest == a->name) {\n\t\t/*\n\t\t * Nothing got copied.  The path must have been something\n\t\t * like '.' or '/' or './' or '/././././/./'.\n\t\t */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t/* Terminate the result. */\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}", "line_changes": {"deleted": [{"line_no": 17, "char_start": 336, "char_end": 354, "line": "\tif (*src == '/')\n"}], "added": [{"line_no": 17, "char_start": 336, "char_end": 356, "line": "\tif (*src == '/') {\n"}, {"line_no": 18, "char_start": 356, "char_end": 415, "line": "\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n"}, {"line_no": 19, "char_start": 415, "char_end": 469, "line": "\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n"}, {"line_no": 20, "char_start": 469, "char_end": 511, "line": "\t\t\t                  \"Path is absolute\");\n"}, {"line_no": 21, "char_start": 511, "char_end": 539, "line": "\t\t\treturn (ARCHIVE_FAILED);\n"}, {"line_no": 22, "char_start": 539, "char_end": 543, "line": "\t\t}\n"}, {"line_no": 23, "char_start": 543, "char_end": 544, "line": "\n"}, {"line_no": 25, "char_start": 566, "char_end": 569, "line": "\t}\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 353, "char_end": 543, "chars": " {\n\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t                  \"Path is absolute\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n"}, {"char_start": 565, "char_end": 568, "chars": "\n\t}"}]}, "commit_link": "github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526", "file_name": "libarchive/archive_write_disk_posix.c", "vul_type": "cwe-022"}
{"func_name": "create_dump_dir_from_problem_data", "func_src_before": "struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *problem_data, const char *base_dir_name)\n{\n    INITIALIZE_LIBREPORT();\n\n    char *type = problem_data_get_content_or_NULL(problem_data, FILENAME_ANALYZER);\n\n    if (!type)\n    {\n        error_msg(_(\"Missing required item: '%s'\"), FILENAME_ANALYZER);\n        return NULL;\n    }\n\n    uid_t uid = (uid_t)-1L;\n    char *uid_str = problem_data_get_content_or_NULL(problem_data, FILENAME_UID);\n\n    if (uid_str)\n    {\n        char *endptr;\n        errno = 0;\n        long val = strtol(uid_str, &endptr, 10);\n\n        if (errno != 0 || endptr == uid_str || *endptr != '\\0' || INT_MAX < val)\n        {\n            error_msg(_(\"uid value is not valid: '%s'\"), uid_str);\n            return NULL;\n        }\n\n        uid = (uid_t)val;\n    }\n\n    struct timeval tv;\n    if (gettimeofday(&tv, NULL) < 0)\n    {\n        perror_msg(\"gettimeofday()\");\n        return NULL;\n    }\n\n    char *problem_id = xasprintf(\"%s-%s.%ld-%lu\"NEW_PD_SUFFIX, type, iso_date_string(&(tv.tv_sec)), (long)tv.tv_usec, (long)getpid());\n\n    log_info(\"Saving to %s/%s with uid %d\", base_dir_name, problem_id, uid);\n\n    struct dump_dir *dd;\n    if (base_dir_name)\n        dd = try_dd_create(base_dir_name, problem_id, uid);\n    else\n    {\n        /* Try /var/run/abrt */\n        dd = try_dd_create(LOCALSTATEDIR\"/run/abrt\", problem_id, uid);\n        /* Try $HOME/tmp */\n        if (!dd)\n        {\n            char *home = getenv(\"HOME\");\n            if (home && home[0])\n            {\n                home = concat_path_file(home, \"tmp\");\n                /*mkdir(home, 0777); - do we want this? */\n                dd = try_dd_create(home, problem_id, uid);\n                free(home);\n            }\n        }\n//TODO: try user's home dir obtained by getpwuid(getuid())?\n        /* Try system temporary directory */\n        if (!dd)\n            dd = try_dd_create(LARGE_DATA_TMP_DIR, problem_id, uid);\n    }\n\n    if (!dd) /* try_dd_create() already emitted the error message */\n        goto ret;\n\n    GHashTableIter iter;\n    char *name;\n    struct problem_item *value;\n    g_hash_table_iter_init(&iter, problem_data);\n    while (g_hash_table_iter_next(&iter, (void**)&name, (void**)&value))\n    {\n        if (value->flags & CD_FLAG_BIN)\n        {\n            char *dest = concat_path_file(dd->dd_dirname, name);\n            log_info(\"copying '%s' to '%s'\", value->content, dest);\n            off_t copied = copy_file(value->content, dest, DEFAULT_DUMP_DIR_MODE | S_IROTH);\n            if (copied < 0)\n                error_msg(\"Can't copy %s to %s\", value->content, dest);\n            else\n                log_info(\"copied %li bytes\", (unsigned long)copied);\n            free(dest);\n\n            continue;\n        }\n\n        /* only files should contain '/' and those are handled earlier */\n        if (name[0] == '.' || strchr(name, '/'))\n        {\n            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n            continue;\n        }\n\n        dd_save_text(dd, name, value->content);\n    }\n\n    /* need to create basic files AFTER we save the pd to dump_dir\n     * otherwise we can't skip already created files like in case when\n     * reporting from anaconda where we can't read /etc/{system,redhat}-release\n     * and os_release is taken from anaconda\n     */\n    dd_create_basic_files(dd, uid, NULL);\n\n    problem_id[strlen(problem_id) - strlen(NEW_PD_SUFFIX)] = '\\0';\n    char* new_path = concat_path_file(base_dir_name, problem_id);\n    log_info(\"Renaming from '%s' to '%s'\", dd->dd_dirname, new_path);\n    dd_rename(dd, new_path);\n\n ret:\n    free(problem_id);\n    return dd;\n}", "func_src_after": "struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *problem_data, const char *base_dir_name)\n{\n    INITIALIZE_LIBREPORT();\n\n    char *type = problem_data_get_content_or_NULL(problem_data, FILENAME_ANALYZER);\n\n    if (!type)\n    {\n        error_msg(_(\"Missing required item: '%s'\"), FILENAME_ANALYZER);\n        return NULL;\n    }\n\n    if (!str_is_correct_filename(type))\n    {\n        error_msg(_(\"'%s' is not correct file name\"), FILENAME_ANALYZER);\n        return NULL;\n    }\n\n    uid_t uid = (uid_t)-1L;\n    char *uid_str = problem_data_get_content_or_NULL(problem_data, FILENAME_UID);\n\n    if (uid_str)\n    {\n        char *endptr;\n        errno = 0;\n        long val = strtol(uid_str, &endptr, 10);\n\n        if (errno != 0 || endptr == uid_str || *endptr != '\\0' || INT_MAX < val)\n        {\n            error_msg(_(\"uid value is not valid: '%s'\"), uid_str);\n            return NULL;\n        }\n\n        uid = (uid_t)val;\n    }\n\n    struct timeval tv;\n    if (gettimeofday(&tv, NULL) < 0)\n    {\n        perror_msg(\"gettimeofday()\");\n        return NULL;\n    }\n\n    char *problem_id = xasprintf(\"%s-%s.%ld-%lu\"NEW_PD_SUFFIX, type, iso_date_string(&(tv.tv_sec)), (long)tv.tv_usec, (long)getpid());\n\n    log_info(\"Saving to %s/%s with uid %d\", base_dir_name, problem_id, uid);\n\n    struct dump_dir *dd;\n    if (base_dir_name)\n        dd = try_dd_create(base_dir_name, problem_id, uid);\n    else\n    {\n        /* Try /var/run/abrt */\n        dd = try_dd_create(LOCALSTATEDIR\"/run/abrt\", problem_id, uid);\n        /* Try $HOME/tmp */\n        if (!dd)\n        {\n            char *home = getenv(\"HOME\");\n            if (home && home[0])\n            {\n                home = concat_path_file(home, \"tmp\");\n                /*mkdir(home, 0777); - do we want this? */\n                dd = try_dd_create(home, problem_id, uid);\n                free(home);\n            }\n        }\n//TODO: try user's home dir obtained by getpwuid(getuid())?\n        /* Try system temporary directory */\n        if (!dd)\n            dd = try_dd_create(LARGE_DATA_TMP_DIR, problem_id, uid);\n    }\n\n    if (!dd) /* try_dd_create() already emitted the error message */\n        goto ret;\n\n    GHashTableIter iter;\n    char *name;\n    struct problem_item *value;\n    g_hash_table_iter_init(&iter, problem_data);\n    while (g_hash_table_iter_next(&iter, (void**)&name, (void**)&value))\n    {\n        if (!str_is_correct_filename(name))\n        {\n            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n            continue;\n        }\n\n        if (value->flags & CD_FLAG_BIN)\n        {\n            char *dest = concat_path_file(dd->dd_dirname, name);\n            log_info(\"copying '%s' to '%s'\", value->content, dest);\n            off_t copied = copy_file(value->content, dest, DEFAULT_DUMP_DIR_MODE | S_IROTH);\n            if (copied < 0)\n                error_msg(\"Can't copy %s to %s\", value->content, dest);\n            else\n                log_info(\"copied %li bytes\", (unsigned long)copied);\n            free(dest);\n\n            continue;\n        }\n\n        dd_save_text(dd, name, value->content);\n    }\n\n    /* need to create basic files AFTER we save the pd to dump_dir\n     * otherwise we can't skip already created files like in case when\n     * reporting from anaconda where we can't read /etc/{system,redhat}-release\n     * and os_release is taken from anaconda\n     */\n    dd_create_basic_files(dd, uid, NULL);\n\n    problem_id[strlen(problem_id) - strlen(NEW_PD_SUFFIX)] = '\\0';\n    char* new_path = concat_path_file(base_dir_name, problem_id);\n    log_info(\"Renaming from '%s' to '%s'\", dd->dd_dirname, new_path);\n    dd_rename(dd, new_path);\n\n ret:\n    free(problem_id);\n    return dd;\n}", "line_changes": {"deleted": [{"line_no": 90, "char_start": 2743, "char_end": 2817, "line": "        /* only files should contain '/' and those are handled earlier */\n"}, {"line_no": 91, "char_start": 2817, "char_end": 2866, "line": "        if (name[0] == '.' || strchr(name, '/'))\n"}, {"line_no": 92, "char_start": 2866, "char_end": 2876, "line": "        {\n"}, {"line_no": 93, "char_start": 2876, "char_end": 2964, "line": "            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n"}, {"line_no": 94, "char_start": 2964, "char_end": 2986, "line": "            continue;\n"}, {"line_no": 95, "char_start": 2986, "char_end": 2996, "line": "        }\n"}, {"line_no": 96, "char_start": 2996, "char_end": 2997, "line": "\n"}], "added": [{"line_no": 13, "char_start": 345, "char_end": 385, "line": "    if (!str_is_correct_filename(type))\n"}, {"line_no": 14, "char_start": 385, "char_end": 391, "line": "    {\n"}, {"line_no": 15, "char_start": 391, "char_end": 465, "line": "        error_msg(_(\"'%s' is not correct file name\"), FILENAME_ANALYZER);\n"}, {"line_no": 16, "char_start": 465, "char_end": 486, "line": "        return NULL;\n"}, {"line_no": 17, "char_start": 486, "char_end": 492, "line": "    }\n"}, {"line_no": 18, "char_start": 492, "char_end": 493, "line": "\n"}, {"line_no": 82, "char_start": 2371, "char_end": 2415, "line": "        if (!str_is_correct_filename(name))\n"}, {"line_no": 83, "char_start": 2415, "char_end": 2425, "line": "        {\n"}, {"line_no": 84, "char_start": 2425, "char_end": 2513, "line": "            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n"}, {"line_no": 85, "char_start": 2513, "char_end": 2535, "line": "            continue;\n"}, {"line_no": 86, "char_start": 2535, "char_end": 2545, "line": "        }\n"}, {"line_no": 87, "char_start": 2545, "char_end": 2546, "line": "\n"}]}, "char_changes": {"deleted": [{"char_start": 2709, "char_end": 2963, "chars": "\n            continue;\n        }\n\n        /* only files should contain '/' and those are handled earlier */\n        if (name[0] == '.' || strchr(name, '/'))\n        {\n            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);"}], "added": [{"char_start": 349, "char_end": 497, "chars": "if (!str_is_correct_filename(type))\n    {\n        error_msg(_(\"'%s' is not correct file name\"), FILENAME_ANALYZER);\n        return NULL;\n    }\n\n    "}, {"char_start": 2383, "char_end": 2558, "chars": "!str_is_correct_filename(name))\n        {\n            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n            continue;\n        }\n\n        if ("}]}, "commit_link": "github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277", "file_name": "src/lib/create_dump_dir.c", "vul_type": "cwe-022"}
{"func_name": "list", "func_src_before": "    def list(self, keyfilter='/'):\n        path = os.path.join(self.namespace, keyfilter)\n        if path != '/':\n            path = path.rstrip('/')\n        try:\n            result = self.etcd.read(path, recursive=True)\n        except etcd.EtcdKeyNotFound:\n            return None\n        except etcd.EtcdException as err:\n            log_error(\"Error listing %s: [%r]\" % (keyfilter, repr(err)))\n            raise CSStoreError('Error occurred while trying to list keys')\n\n        value = set()\n        for entry in result.get_subtree():\n            if entry.key == path:\n                continue\n            name = entry.key[len(path):]\n            if entry.dir and not name.endswith('/'):\n                name += '/'\n            value.add(name.lstrip('/'))\n        return sorted(value)", "func_src_after": "    def list(self, keyfilter='/'):\n        path = self._absolute_key(keyfilter)\n        if path != '/':\n            path = path.rstrip('/')\n        try:\n            result = self.etcd.read(path, recursive=True)\n        except etcd.EtcdKeyNotFound:\n            return None\n        except etcd.EtcdException as err:\n            log_error(\"Error listing %s: [%r]\" % (keyfilter, repr(err)))\n            raise CSStoreError('Error occurred while trying to list keys')\n\n        value = set()\n        for entry in result.get_subtree():\n            if entry.key == path:\n                continue\n            name = entry.key[len(path):]\n            if entry.dir and not name.endswith('/'):\n                name += '/'\n            value.add(name.lstrip('/'))\n        return sorted(value)", "line_changes": {"deleted": [{"line_no": 2, "char_start": 35, "char_end": 90, "line": "        path = os.path.join(self.namespace, keyfilter)\n"}], "added": [{"line_no": 2, "char_start": 35, "char_end": 80, "line": "        path = self._absolute_key(keyfilter)\n"}]}, "char_changes": {"deleted": [{"char_start": 50, "char_end": 63, "chars": "os.path.join("}, {"char_start": 68, "char_end": 69, "chars": "n"}, {"char_start": 70, "char_end": 72, "chars": "me"}, {"char_start": 73, "char_end": 76, "chars": "pac"}, {"char_start": 77, "char_end": 79, "chars": ", "}], "added": [{"char_start": 55, "char_end": 56, "chars": "_"}, {"char_start": 57, "char_end": 63, "chars": "bsolut"}, {"char_start": 64, "char_end": 66, "chars": "_k"}, {"char_start": 67, "char_end": 69, "chars": "y("}]}, "commit_link": "github.com/latchset/custodia/commit/785fc87f38b4811bc4ce43a0a9b2267ee7d500b4", "file_name": "custodia/store/etcdstore.py", "vul_type": "cwe-022"}
{"func_name": "process", "func_src_before": "local void process(char *path)\n{\n    int method = -1;                /* get_header() return value */\n    size_t len;                     /* length of base name (minus suffix) */\n    struct stat st;                 /* to get file type and mod time */\n    /* all compressed suffixes for decoding search, in length order */\n    static char *sufs[] = {\".z\", \"-z\", \"_z\", \".Z\", \".gz\", \"-gz\", \".zz\", \"-zz\",\n                           \".zip\", \".ZIP\", \".tgz\", NULL};\n\n    /* open input file with name in, descriptor ind -- set name and mtime */\n    if (path == NULL) {\n        strcpy(g.inf, \"<stdin>\");\n        g.ind = 0;\n        g.name = NULL;\n        g.mtime = g.headis & 2 ?\n                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;\n        len = 0;\n    }\n    else {\n        /* set input file name (already set if recursed here) */\n        if (path != g.inf) {\n            strncpy(g.inf, path, sizeof(g.inf));\n            if (g.inf[sizeof(g.inf) - 1])\n                bail(\"name too long: \", path);\n        }\n        len = strlen(g.inf);\n\n        /* try to stat input file -- if not there and decoding, look for that\n           name with compressed suffixes */\n        if (lstat(g.inf, &st)) {\n            if (errno == ENOENT && (g.list || g.decode)) {\n                char **try = sufs;\n                do {\n                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))\n                        break;\n                    strcpy(g.inf + len, *try++);\n                    errno = 0;\n                } while (lstat(g.inf, &st) && errno == ENOENT);\n            }\n#ifdef EOVERFLOW\n            if (errno == EOVERFLOW || errno == EFBIG)\n                bail(g.inf,\n                    \" too large -- not compiled with large file support\");\n#endif\n            if (errno) {\n                g.inf[len] = 0;\n                complain(\"%s does not exist -- skipping\", g.inf);\n                return;\n            }\n            len = strlen(g.inf);\n        }\n\n        /* only process regular files, but allow symbolic links if -f,\n           recurse into directory if -r */\n        if ((st.st_mode & S_IFMT) != S_IFREG &&\n            (st.st_mode & S_IFMT) != S_IFLNK &&\n            (st.st_mode & S_IFMT) != S_IFDIR) {\n            complain(\"%s is a special file or device -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {\n            complain(\"%s is a symbolic link -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {\n            complain(\"%s is a directory -- skipping\", g.inf);\n            return;\n        }\n\n        /* recurse into directory (assumes Unix) */\n        if ((st.st_mode & S_IFMT) == S_IFDIR) {\n            char *roll, *item, *cut, *base, *bigger;\n            size_t len, hold;\n            DIR *here;\n            struct dirent *next;\n\n            /* accumulate list of entries (need to do this, since readdir()\n               behavior not defined if directory modified between calls) */\n            here = opendir(g.inf);\n            if (here == NULL)\n                return;\n            hold = 512;\n            roll = MALLOC(hold);\n            if (roll == NULL)\n                bail(\"not enough memory\", \"\");\n            *roll = 0;\n            item = roll;\n            while ((next = readdir(here)) != NULL) {\n                if (next->d_name[0] == 0 ||\n                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||\n                     (next->d_name[1] == '.' && next->d_name[2] == 0))))\n                    continue;\n                len = strlen(next->d_name) + 1;\n                if (item + len + 1 > roll + hold) {\n                    do {                    /* make roll bigger */\n                        hold <<= 1;\n                    } while (item + len + 1 > roll + hold);\n                    bigger = REALLOC(roll, hold);\n                    if (bigger == NULL) {\n                        FREE(roll);\n                        bail(\"not enough memory\", \"\");\n                    }\n                    item = bigger + (item - roll);\n                    roll = bigger;\n                }\n                strcpy(item, next->d_name);\n                item += len;\n                *item = 0;\n            }\n            closedir(here);\n\n            /* run process() for each entry in the directory */\n            cut = base = g.inf + strlen(g.inf);\n            if (base > g.inf && base[-1] != (unsigned char)'/') {\n                if ((size_t)(base - g.inf) >= sizeof(g.inf))\n                    bail(\"path too long\", g.inf);\n                *base++ = '/';\n            }\n            item = roll;\n            while (*item) {\n                strncpy(base, item, sizeof(g.inf) - (base - g.inf));\n                if (g.inf[sizeof(g.inf) - 1]) {\n                    strcpy(g.inf + (sizeof(g.inf) - 4), \"...\");\n                    bail(\"path too long: \", g.inf);\n                }\n                process(g.inf);\n                item += strlen(item) + 1;\n            }\n            *cut = 0;\n\n            /* release list of entries */\n            FREE(roll);\n            return;\n        }\n\n        /* don't compress .gz (or provided suffix) files, unless -f */\n        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&\n                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {\n            complain(\"%s ends with %s -- skipping\", g.inf, g.sufx);\n            return;\n        }\n\n        /* create output file only if input file has compressed suffix */\n        if (g.decode == 1 && !g.pipeout && !g.list) {\n            int suf = compressed_suffix(g.inf);\n            if (suf == 0) {\n                complain(\"%s does not have compressed suffix -- skipping\",\n                         g.inf);\n                return;\n            }\n            len -= suf;\n        }\n\n        /* open input file */\n        g.ind = open(g.inf, O_RDONLY, 0);\n        if (g.ind < 0)\n            bail(\"read error on \", g.inf);\n\n        /* prepare gzip header information for compression */\n        g.name = g.headis & 1 ? justname(g.inf) : NULL;\n        g.mtime = g.headis & 2 ? st.st_mtime : 0;\n    }\n    SET_BINARY_MODE(g.ind);\n\n    /* if decoding or testing, try to read gzip header */\n    g.hname = NULL;\n    if (g.decode) {\n        in_init();\n        method = get_header(1);\n        if (method != 8 && method != 257 &&\n                /* gzip -cdf acts like cat on uncompressed input */\n                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&\n                  !g.list)) {\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            if (method != -1)\n                complain(method < 0 ? \"%s is not compressed -- skipping\" :\n                         \"%s has unknown compression method -- skipping\",\n                         g.inf);\n            return;\n        }\n\n        /* if requested, test input file (possibly a special list) */\n        if (g.decode == 2) {\n            if (method == 8)\n                infchk();\n            else {\n                unlzw();\n                if (g.list) {\n                    g.in_tot -= 3;\n                    show_info(method, 0, g.out_tot, 0);\n                }\n            }\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n    }\n\n    /* if requested, just list information about input file */\n    if (g.list) {\n        list_info();\n        RELEASE(g.hname);\n        if (g.ind != 0)\n            close(g.ind);\n        return;\n    }\n\n    /* create output file out, descriptor outd */\n    if (path == NULL || g.pipeout) {\n        /* write to stdout */\n        g.outf = MALLOC(strlen(\"<stdout>\") + 1);\n        if (g.outf == NULL)\n            bail(\"not enough memory\", \"\");\n        strcpy(g.outf, \"<stdout>\");\n        g.outd = 1;\n        if (!g.decode && !g.force && isatty(g.outd))\n            bail(\"trying to write compressed data to a terminal\",\n                 \" (use -f to force)\");\n    }\n    else {\n        char *to, *repl;\n\n        /* use header name for output when decompressing with -N */\n        to = g.inf;\n        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {\n            to = g.hname;\n            len = strlen(g.hname);\n        }\n\n        /* replace .tgz with .tar when decoding */\n        repl = g.decode && strcmp(to + len, \".tgz\") ? \"\" : \".tar\";\n\n        /* create output file and open to write */\n        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);\n        if (g.outf == NULL)\n            bail(\"not enough memory\", \"\");\n        memcpy(g.outf, to, len);\n        strcpy(g.outf + len, g.decode ? repl : g.sufx);\n        g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |\n                             (g.force ? 0 : O_EXCL), 0600);\n\n        /* if exists and not -f, give user a chance to overwrite */\n        if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {\n            int ch, reply;\n\n            fprintf(stderr, \"%s exists -- overwrite (y/n)? \", g.outf);\n            fflush(stderr);\n            reply = -1;\n            do {\n                ch = getchar();\n                if (reply < 0 && ch != ' ' && ch != '\\t')\n                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;\n            } while (ch != EOF && ch != '\\n' && ch != '\\r');\n            if (reply == 1)\n                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,\n                              0600);\n        }\n\n        /* if exists and no overwrite, report and go on to next */\n        if (g.outd < 0 && errno == EEXIST) {\n            complain(\"%s exists -- skipping\", g.outf);\n            RELEASE(g.outf);\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n\n        /* if some other error, give up */\n        if (g.outd < 0)\n            bail(\"write error on \", g.outf);\n    }\n    SET_BINARY_MODE(g.outd);\n    RELEASE(g.hname);\n\n    /* process ind to outd */\n    if (g.verbosity > 1)\n        fprintf(stderr, \"%s to %s \", g.inf, g.outf);\n    if (g.decode) {\n        if (method == 8)\n            infchk();\n        else if (method == 257)\n            unlzw();\n        else\n            cat();\n    }\n#ifndef NOTHREAD\n    else if (g.procs > 1)\n        parallel_compress();\n#endif\n    else\n        single_compress(0);\n    if (g.verbosity > 1) {\n        putc('\\n', stderr);\n        fflush(stderr);\n    }\n\n    /* finish up, copy attributes, set times, delete original */\n    if (g.ind != 0)\n        close(g.ind);\n    if (g.outd != 1) {\n        if (close(g.outd))\n            bail(\"write error on \", g.outf);\n        g.outd = -1;            /* now prevent deletion on interrupt */\n        if (g.ind != 0) {\n            copymeta(g.inf, g.outf);\n            if (!g.keep)\n                unlink(g.inf);\n        }\n        if (g.decode && (g.headis & 2) != 0 && g.stamp)\n            touch(g.outf, g.stamp);\n    }\n    RELEASE(g.outf);\n}", "func_src_after": "local void process(char *path)\n{\n    int method = -1;                /* get_header() return value */\n    size_t len;                     /* length of base name (minus suffix) */\n    struct stat st;                 /* to get file type and mod time */\n    /* all compressed suffixes for decoding search, in length order */\n    static char *sufs[] = {\".z\", \"-z\", \"_z\", \".Z\", \".gz\", \"-gz\", \".zz\", \"-zz\",\n                           \".zip\", \".ZIP\", \".tgz\", NULL};\n\n    /* open input file with name in, descriptor ind -- set name and mtime */\n    if (path == NULL) {\n        strcpy(g.inf, \"<stdin>\");\n        g.ind = 0;\n        g.name = NULL;\n        g.mtime = g.headis & 2 ?\n                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;\n        len = 0;\n    }\n    else {\n        /* set input file name (already set if recursed here) */\n        if (path != g.inf) {\n            strncpy(g.inf, path, sizeof(g.inf));\n            if (g.inf[sizeof(g.inf) - 1])\n                bail(\"name too long: \", path);\n        }\n        len = strlen(g.inf);\n\n        /* try to stat input file -- if not there and decoding, look for that\n           name with compressed suffixes */\n        if (lstat(g.inf, &st)) {\n            if (errno == ENOENT && (g.list || g.decode)) {\n                char **try = sufs;\n                do {\n                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))\n                        break;\n                    strcpy(g.inf + len, *try++);\n                    errno = 0;\n                } while (lstat(g.inf, &st) && errno == ENOENT);\n            }\n#ifdef EOVERFLOW\n            if (errno == EOVERFLOW || errno == EFBIG)\n                bail(g.inf,\n                    \" too large -- not compiled with large file support\");\n#endif\n            if (errno) {\n                g.inf[len] = 0;\n                complain(\"%s does not exist -- skipping\", g.inf);\n                return;\n            }\n            len = strlen(g.inf);\n        }\n\n        /* only process regular files, but allow symbolic links if -f,\n           recurse into directory if -r */\n        if ((st.st_mode & S_IFMT) != S_IFREG &&\n            (st.st_mode & S_IFMT) != S_IFLNK &&\n            (st.st_mode & S_IFMT) != S_IFDIR) {\n            complain(\"%s is a special file or device -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {\n            complain(\"%s is a symbolic link -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {\n            complain(\"%s is a directory -- skipping\", g.inf);\n            return;\n        }\n\n        /* recurse into directory (assumes Unix) */\n        if ((st.st_mode & S_IFMT) == S_IFDIR) {\n            char *roll, *item, *cut, *base, *bigger;\n            size_t len, hold;\n            DIR *here;\n            struct dirent *next;\n\n            /* accumulate list of entries (need to do this, since readdir()\n               behavior not defined if directory modified between calls) */\n            here = opendir(g.inf);\n            if (here == NULL)\n                return;\n            hold = 512;\n            roll = MALLOC(hold);\n            if (roll == NULL)\n                bail(\"not enough memory\", \"\");\n            *roll = 0;\n            item = roll;\n            while ((next = readdir(here)) != NULL) {\n                if (next->d_name[0] == 0 ||\n                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||\n                     (next->d_name[1] == '.' && next->d_name[2] == 0))))\n                    continue;\n                len = strlen(next->d_name) + 1;\n                if (item + len + 1 > roll + hold) {\n                    do {                    /* make roll bigger */\n                        hold <<= 1;\n                    } while (item + len + 1 > roll + hold);\n                    bigger = REALLOC(roll, hold);\n                    if (bigger == NULL) {\n                        FREE(roll);\n                        bail(\"not enough memory\", \"\");\n                    }\n                    item = bigger + (item - roll);\n                    roll = bigger;\n                }\n                strcpy(item, next->d_name);\n                item += len;\n                *item = 0;\n            }\n            closedir(here);\n\n            /* run process() for each entry in the directory */\n            cut = base = g.inf + strlen(g.inf);\n            if (base > g.inf && base[-1] != (unsigned char)'/') {\n                if ((size_t)(base - g.inf) >= sizeof(g.inf))\n                    bail(\"path too long\", g.inf);\n                *base++ = '/';\n            }\n            item = roll;\n            while (*item) {\n                strncpy(base, item, sizeof(g.inf) - (base - g.inf));\n                if (g.inf[sizeof(g.inf) - 1]) {\n                    strcpy(g.inf + (sizeof(g.inf) - 4), \"...\");\n                    bail(\"path too long: \", g.inf);\n                }\n                process(g.inf);\n                item += strlen(item) + 1;\n            }\n            *cut = 0;\n\n            /* release list of entries */\n            FREE(roll);\n            return;\n        }\n\n        /* don't compress .gz (or provided suffix) files, unless -f */\n        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&\n                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {\n            complain(\"%s ends with %s -- skipping\", g.inf, g.sufx);\n            return;\n        }\n\n        /* create output file only if input file has compressed suffix */\n        if (g.decode == 1 && !g.pipeout && !g.list) {\n            int suf = compressed_suffix(g.inf);\n            if (suf == 0) {\n                complain(\"%s does not have compressed suffix -- skipping\",\n                         g.inf);\n                return;\n            }\n            len -= suf;\n        }\n\n        /* open input file */\n        g.ind = open(g.inf, O_RDONLY, 0);\n        if (g.ind < 0)\n            bail(\"read error on \", g.inf);\n\n        /* prepare gzip header information for compression */\n        g.name = g.headis & 1 ? justname(g.inf) : NULL;\n        g.mtime = g.headis & 2 ? st.st_mtime : 0;\n    }\n    SET_BINARY_MODE(g.ind);\n\n    /* if decoding or testing, try to read gzip header */\n    g.hname = NULL;\n    if (g.decode) {\n        in_init();\n        method = get_header(1);\n        if (method != 8 && method != 257 &&\n                /* gzip -cdf acts like cat on uncompressed input */\n                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&\n                  !g.list)) {\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            if (method != -1)\n                complain(method < 0 ? \"%s is not compressed -- skipping\" :\n                         \"%s has unknown compression method -- skipping\",\n                         g.inf);\n            return;\n        }\n\n        /* if requested, test input file (possibly a special list) */\n        if (g.decode == 2) {\n            if (method == 8)\n                infchk();\n            else {\n                unlzw();\n                if (g.list) {\n                    g.in_tot -= 3;\n                    show_info(method, 0, g.out_tot, 0);\n                }\n            }\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n    }\n\n    /* if requested, just list information about input file */\n    if (g.list) {\n        list_info();\n        RELEASE(g.hname);\n        if (g.ind != 0)\n            close(g.ind);\n        return;\n    }\n\n    /* create output file out, descriptor outd */\n    if (path == NULL || g.pipeout) {\n        /* write to stdout */\n        g.outf = MALLOC(strlen(\"<stdout>\") + 1);\n        if (g.outf == NULL)\n            bail(\"not enough memory\", \"\");\n        strcpy(g.outf, \"<stdout>\");\n        g.outd = 1;\n        if (!g.decode && !g.force && isatty(g.outd))\n            bail(\"trying to write compressed data to a terminal\",\n                 \" (use -f to force)\");\n    }\n    else {\n        char *to = g.inf, *sufx = \"\";\n        size_t pre = 0;\n\n        /* select parts of the output file name */\n        if (g.decode) {\n            /* for -dN or -dNT, use the path from the input file and the name\n               from the header, stripping any path in the header name */\n            if ((g.headis & 1) != 0 && g.hname != NULL) {\n                pre = justname(g.inf) - g.inf;\n                to = justname(g.hname);\n                len = strlen(to);\n            }\n            /* for -d or -dNn, replace abbreviated suffixes */\n            else if (strcmp(to + len, \".tgz\") == 0)\n                sufx = \".tar\";\n        }\n        else\n            /* add appropriate suffix when compressing */\n            sufx = g.sufx;\n\n        /* create output file and open to write */\n        g.outf = MALLOC(pre + len + strlen(sufx) + 1);\n        if (g.outf == NULL)\n            bail(\"not enough memory\", \"\");\n        memcpy(g.outf, g.inf, pre);\n        memcpy(g.outf + pre, to, len);\n        strcpy(g.outf + pre + len, sufx);\n        g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |\n                              (g.force ? 0 : O_EXCL), 0600);\n\n        /* if exists and not -f, give user a chance to overwrite */\n        if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {\n            int ch, reply;\n\n            fprintf(stderr, \"%s exists -- overwrite (y/n)? \", g.outf);\n            fflush(stderr);\n            reply = -1;\n            do {\n                ch = getchar();\n                if (reply < 0 && ch != ' ' && ch != '\\t')\n                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;\n            } while (ch != EOF && ch != '\\n' && ch != '\\r');\n            if (reply == 1)\n                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,\n                              0600);\n        }\n\n        /* if exists and no overwrite, report and go on to next */\n        if (g.outd < 0 && errno == EEXIST) {\n            complain(\"%s exists -- skipping\", g.outf);\n            RELEASE(g.outf);\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n\n        /* if some other error, give up */\n        if (g.outd < 0)\n            bail(\"write error on \", g.outf);\n    }\n    SET_BINARY_MODE(g.outd);\n    RELEASE(g.hname);\n\n    /* process ind to outd */\n    if (g.verbosity > 1)\n        fprintf(stderr, \"%s to %s \", g.inf, g.outf);\n    if (g.decode) {\n        if (method == 8)\n            infchk();\n        else if (method == 257)\n            unlzw();\n        else\n            cat();\n    }\n#ifndef NOTHREAD\n    else if (g.procs > 1)\n        parallel_compress();\n#endif\n    else\n        single_compress(0);\n    if (g.verbosity > 1) {\n        putc('\\n', stderr);\n        fflush(stderr);\n    }\n\n    /* finish up, copy attributes, set times, delete original */\n    if (g.ind != 0)\n        close(g.ind);\n    if (g.outd != 1) {\n        if (close(g.outd))\n            bail(\"write error on \", g.outf);\n        g.outd = -1;            /* now prevent deletion on interrupt */\n        if (g.ind != 0) {\n            copymeta(g.inf, g.outf);\n            if (!g.keep)\n                unlink(g.inf);\n        }\n        if (g.decode && (g.headis & 2) != 0 && g.stamp)\n            touch(g.outf, g.stamp);\n    }\n    RELEASE(g.outf);\n}", "line_changes": {"deleted": [{"line_no": 224, "char_start": 8033, "char_end": 8058, "line": "        char *to, *repl;\n"}, {"line_no": 225, "char_start": 8058, "char_end": 8059, "line": "\n"}, {"line_no": 226, "char_start": 8059, "char_end": 8127, "line": "        /* use header name for output when decompressing with -N */\n"}, {"line_no": 227, "char_start": 8127, "char_end": 8147, "line": "        to = g.inf;\n"}, {"line_no": 228, "char_start": 8147, "char_end": 8213, "line": "        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {\n"}, {"line_no": 229, "char_start": 8213, "char_end": 8239, "line": "            to = g.hname;\n"}, {"line_no": 230, "char_start": 8239, "char_end": 8274, "line": "            len = strlen(g.hname);\n"}, {"line_no": 232, "char_start": 8284, "char_end": 8285, "line": "\n"}, {"line_no": 233, "char_start": 8285, "char_end": 8336, "line": "        /* replace .tgz with .tar when decoding */\n"}, {"line_no": 234, "char_start": 8336, "char_end": 8403, "line": "        repl = g.decode && strcmp(to + len, \".tgz\") ? \"\" : \".tar\";\n"}, {"line_no": 237, "char_start": 8455, "char_end": 8534, "line": "        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);\n"}, {"line_no": 240, "char_start": 8605, "char_end": 8638, "line": "        memcpy(g.outf, to, len);\n"}, {"line_no": 241, "char_start": 8638, "char_end": 8694, "line": "        strcpy(g.outf + len, g.decode ? repl : g.sufx);\n"}, {"line_no": 243, "char_start": 8755, "char_end": 8815, "line": "                             (g.force ? 0 : O_EXCL), 0600);\n"}], "added": [{"line_no": 224, "char_start": 8033, "char_end": 8071, "line": "        char *to = g.inf, *sufx = \"\";\n"}, {"line_no": 225, "char_start": 8071, "char_end": 8095, "line": "        size_t pre = 0;\n"}, {"line_no": 226, "char_start": 8095, "char_end": 8096, "line": "\n"}, {"line_no": 227, "char_start": 8096, "char_end": 8147, "line": "        /* select parts of the output file name */\n"}, {"line_no": 228, "char_start": 8147, "char_end": 8171, "line": "        if (g.decode) {\n"}, {"line_no": 229, "char_start": 8171, "char_end": 8249, "line": "            /* for -dN or -dNT, use the path from the input file and the name\n"}, {"line_no": 230, "char_start": 8249, "char_end": 8322, "line": "               from the header, stripping any path in the header name */\n"}, {"line_no": 231, "char_start": 8322, "char_end": 8380, "line": "            if ((g.headis & 1) != 0 && g.hname != NULL) {\n"}, {"line_no": 232, "char_start": 8380, "char_end": 8427, "line": "                pre = justname(g.inf) - g.inf;\n"}, {"line_no": 233, "char_start": 8427, "char_end": 8467, "line": "                to = justname(g.hname);\n"}, {"line_no": 234, "char_start": 8467, "char_end": 8501, "line": "                len = strlen(to);\n"}, {"line_no": 235, "char_start": 8501, "char_end": 8515, "line": "            }\n"}, {"line_no": 236, "char_start": 8515, "char_end": 8578, "line": "            /* for -d or -dNn, replace abbreviated suffixes */\n"}, {"line_no": 237, "char_start": 8578, "char_end": 8630, "line": "            else if (strcmp(to + len, \".tgz\") == 0)\n"}, {"line_no": 238, "char_start": 8630, "char_end": 8661, "line": "                sufx = \".tar\";\n"}, {"line_no": 240, "char_start": 8671, "char_end": 8684, "line": "        else\n"}, {"line_no": 241, "char_start": 8684, "char_end": 8742, "line": "            /* add appropriate suffix when compressing */\n"}, {"line_no": 242, "char_start": 8742, "char_end": 8769, "line": "            sufx = g.sufx;\n"}, {"line_no": 245, "char_start": 8821, "char_end": 8876, "line": "        g.outf = MALLOC(pre + len + strlen(sufx) + 1);\n"}, {"line_no": 248, "char_start": 8947, "char_end": 8983, "line": "        memcpy(g.outf, g.inf, pre);\n"}, {"line_no": 249, "char_start": 8983, "char_end": 9022, "line": "        memcpy(g.outf + pre, to, len);\n"}, {"line_no": 250, "char_start": 9022, "char_end": 9064, "line": "        strcpy(g.outf + pre + len, sufx);\n"}, {"line_no": 252, "char_start": 9125, "char_end": 9186, "line": "                              (g.force ? 0 : O_EXCL), 0600);\n"}]}, "char_changes": {"deleted": [{"char_start": 8052, "char_end": 8053, "chars": "r"}, {"char_start": 8055, "char_end": 8056, "chars": "l"}, {"char_start": 8070, "char_end": 8071, "chars": "u"}, {"char_start": 8076, "char_end": 8078, "chars": "ad"}, {"char_start": 8079, "char_end": 8080, "chars": "r"}, {"char_start": 8094, "char_end": 8095, "chars": "u"}, {"char_start": 8096, "char_end": 8098, "chars": " w"}, {"char_start": 8099, "char_end": 8101, "chars": "en"}, {"char_start": 8102, "char_end": 8105, "chars": "dec"}, {"char_start": 8107, "char_end": 8109, "chars": "pr"}, {"char_start": 8110, "char_end": 8112, "chars": "ss"}, {"char_start": 8114, "char_end": 8115, "chars": "g"}, {"char_start": 8116, "char_end": 8117, "chars": "w"}, {"char_start": 8120, "char_end": 8123, "chars": " -N"}, {"char_start": 8124, "char_end": 8126, "chars": "*/"}, {"char_start": 8135, "char_end": 8136, "chars": "t"}, {"char_start": 8138, "char_end": 8139, "chars": "="}, {"char_start": 8141, "char_end": 8142, "chars": "."}, {"char_start": 8144, "char_end": 8146, "chars": "f;"}, {"char_start": 8159, "char_end": 8171, "chars": "g.decode && "}, {"char_start": 8264, "char_end": 8271, "chars": "g.hname"}, {"char_start": 8283, "char_end": 8284, "chars": "\n"}, {"char_start": 8304, "char_end": 8316, "chars": ".tgz with .t"}, {"char_start": 8318, "char_end": 8321, "chars": " wh"}, {"char_start": 8322, "char_end": 8325, "chars": "n d"}, {"char_start": 8326, "char_end": 8328, "chars": "co"}, {"char_start": 8330, "char_end": 8332, "chars": "ng"}, {"char_start": 8344, "char_end": 8348, "chars": "repl"}, {"char_start": 8349, "char_end": 8350, "chars": "="}, {"char_start": 8351, "char_end": 8354, "chars": "g.d"}, {"char_start": 8355, "char_end": 8358, "chars": "cod"}, {"char_start": 8360, "char_end": 8362, "chars": "&&"}, {"char_start": 8388, "char_end": 8389, "chars": "?"}, {"char_start": 8390, "char_end": 8392, "chars": "\"\""}, {"char_start": 8393, "char_end": 8394, "chars": ":"}, {"char_start": 8479, "char_end": 8480, "chars": "l"}, {"char_start": 8481, "char_end": 8482, "chars": "n"}, {"char_start": 8485, "char_end": 8500, "chars": "(g.decode ? str"}, {"char_start": 8503, "char_end": 8509, "chars": "(repl)"}, {"char_start": 8510, "char_end": 8511, "chars": ":"}, {"char_start": 8519, "char_end": 8521, "chars": "g."}, {"char_start": 8525, "char_end": 8526, "chars": ")"}, {"char_start": 8628, "char_end": 8630, "chars": "to"}, {"char_start": 8632, "char_end": 8633, "chars": "l"}, {"char_start": 8634, "char_end": 8635, "chars": "n"}, {"char_start": 8646, "char_end": 8649, "chars": "str"}, {"char_start": 8665, "char_end": 8666, "chars": ","}, {"char_start": 8669, "char_end": 8672, "chars": "dec"}, {"char_start": 8673, "char_end": 8675, "chars": "de"}, {"char_start": 8676, "char_end": 8677, "chars": "?"}, {"char_start": 8680, "char_end": 8682, "chars": "pl"}, {"char_start": 8683, "char_end": 8684, "chars": ":"}, {"char_start": 8685, "char_end": 8687, "chars": "g."}], "added": [{"char_start": 8049, "char_end": 8057, "chars": " = g.inf"}, {"char_start": 8060, "char_end": 8087, "chars": "sufx = \"\";\n        size_t p"}, {"char_start": 8089, "char_end": 8093, "chars": " = 0"}, {"char_start": 8109, "char_end": 8113, "chars": "lect"}, {"char_start": 8114, "char_end": 8124, "chars": "parts of t"}, {"char_start": 8126, "char_end": 8137, "chars": " output fil"}, {"char_start": 8144, "char_end": 8186, "chars": "*/\n        if (g.decode) {\n            /* "}, {"char_start": 8190, "char_end": 8194, "chars": "-dN "}, {"char_start": 8195, "char_end": 8203, "chars": "r -dNT, "}, {"char_start": 8204, "char_end": 8207, "chars": "se "}, {"char_start": 8208, "char_end": 8211, "chars": "he "}, {"char_start": 8212, "char_end": 8213, "chars": "a"}, {"char_start": 8216, "char_end": 8218, "chars": "fr"}, {"char_start": 8220, "char_end": 8223, "chars": " th"}, {"char_start": 8224, "char_end": 8225, "chars": " "}, {"char_start": 8227, "char_end": 8230, "chars": "put"}, {"char_start": 8231, "char_end": 8232, "chars": "f"}, {"char_start": 8233, "char_end": 8240, "chars": "le and "}, {"char_start": 8242, "char_end": 8250, "chars": "e name\n "}, {"char_start": 8259, "char_end": 8269, "chars": "     from "}, {"char_start": 8270, "char_end": 8272, "chars": "he"}, {"char_start": 8273, "char_end": 8280, "chars": "header,"}, {"char_start": 8281, "char_end": 8289, "chars": "strippin"}, {"char_start": 8290, "char_end": 8300, "chars": " any path "}, {"char_start": 8302, "char_end": 8321, "chars": " the header name */"}, {"char_start": 8322, "char_end": 8326, "chars": "    "}, {"char_start": 8392, "char_end": 8443, "chars": "    pre = justname(g.inf) - g.inf;\n                "}, {"char_start": 8448, "char_end": 8457, "chars": "justname("}, {"char_start": 8464, "char_end": 8465, "chars": ")"}, {"char_start": 8467, "char_end": 8471, "chars": "    "}, {"char_start": 8496, "char_end": 8498, "chars": "to"}, {"char_start": 8509, "char_end": 8513, "chars": "    "}, {"char_start": 8515, "char_end": 8519, "chars": "    "}, {"char_start": 8530, "char_end": 8546, "chars": "for -d or -dNn, "}, {"char_start": 8555, "char_end": 8557, "chars": "bb"}, {"char_start": 8559, "char_end": 8563, "chars": "viat"}, {"char_start": 8565, "char_end": 8570, "chars": " suff"}, {"char_start": 8571, "char_end": 8574, "chars": "xes"}, {"char_start": 8586, "char_end": 8588, "chars": "  "}, {"char_start": 8591, "char_end": 8593, "chars": "ls"}, {"char_start": 8595, "char_end": 8597, "chars": "if"}, {"char_start": 8598, "char_end": 8599, "chars": "("}, {"char_start": 8624, "char_end": 8645, "chars": "== 0)\n               "}, {"char_start": 8646, "char_end": 8650, "chars": "sufx"}, {"char_start": 8651, "char_end": 8652, "chars": "="}, {"char_start": 8661, "char_end": 8769, "chars": "        }\n        else\n            /* add appropriate suffix when compressing */\n            sufx = g.sufx;\n"}, {"char_start": 8845, "char_end": 8847, "chars": "pr"}, {"char_start": 8855, "char_end": 8856, "chars": "+"}, {"char_start": 8970, "char_end": 8975, "chars": "g.inf"}, {"char_start": 8977, "char_end": 8979, "chars": "pr"}, {"char_start": 8991, "char_end": 8994, "chars": "mem"}, {"char_start": 9006, "char_end": 9015, "chars": " pre, to,"}, {"char_start": 9019, "char_end": 9029, "chars": ");\n       "}, {"char_start": 9030, "char_end": 9037, "chars": "strcpy("}, {"char_start": 9040, "char_end": 9043, "chars": "utf"}, {"char_start": 9044, "char_end": 9045, "chars": "+"}, {"char_start": 9046, "char_end": 9047, "chars": "p"}, {"char_start": 9049, "char_end": 9052, "chars": " + "}, {"char_start": 9053, "char_end": 9056, "chars": "en,"}, {"char_start": 9125, "char_end": 9126, "chars": " "}]}, "commit_link": "github.com/madler/pigz/commit/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f", "file_name": "pigz.c", "vul_type": "cwe-022"}
{"func_name": "imap_hcache_open", "func_src_before": "header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}", "func_src_after": "header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n\n  if (strstr(mbox, \"/../\") || (strcmp(mbox, \"..\") == 0) || (strncmp(mbox, \"../\", 3) == 0))\n    return NULL;\n  size_t len = strlen(mbox);\n  if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))\n    return NULL;\n\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}", "line_changes": {"deleted": [], "added": [{"line_no": 19, "char_start": 413, "char_end": 504, "line": "  if (strstr(mbox, \"/../\") || (strcmp(mbox, \"..\") == 0) || (strncmp(mbox, \"../\", 3) == 0))\n"}, {"line_no": 20, "char_start": 504, "char_end": 521, "line": "    return NULL;\n"}, {"line_no": 21, "char_start": 521, "char_end": 550, "line": "  size_t len = strlen(mbox);\n"}, {"line_no": 22, "char_start": 550, "char_end": 607, "line": "  if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))\n"}, {"line_no": 23, "char_start": 607, "char_end": 624, "line": "    return NULL;\n"}, {"line_no": 24, "char_start": 624, "char_end": 625, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 415, "char_end": 627, "chars": "if (strstr(mbox, \"/../\") || (strcmp(mbox, \"..\") == 0) || (strncmp(mbox, \"../\", 3) == 0))\n    return NULL;\n  size_t len = strlen(mbox);\n  if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))\n    return NULL;\n\n  "}]}, "commit_link": "github.com/neomutt/neomutt/commit/57971dba06346b2d7179294f4528b8d4427a7c5d", "file_name": "imap/util.c", "vul_type": "cwe-022"}
{"func_name": "_normalize", "func_src_before": "    def _normalize(self, metaerrors):\n        \"\"\"Normalize output format to be usable by Anaconda's linting frontend\n        \"\"\"\n\n        errors = []\n        for error in metaerrors:\n            if self.filepath not in error.get('path', ''):\n                continue\n\n            error_type = error.get('severity', 'X').capitalize()[0]\n            if error_type == 'X':\n                continue\n            if error_type not in ['E', 'W']:\n                error_type = 'V'\n            errors.append({\n                'underline_range': True,\n                'lineno': error.get('line', 0),\n                'offset': error.get('col', 0),\n                'raw_message': error.get('message', ''),\n                'code': 0,\n                'level': error_type,\n                'message': '[{0}] {1} ({2}): {3}'.format(\n                    error_type,\n                    error.get('linter', 'none'),\n                    error.get('severity', 'none'),\n                    error.get('message')\n                )\n            })\n\n        return errors", "func_src_after": "    def _normalize(self, metaerrors):\n        \"\"\"Normalize output format to be usable by Anaconda's linting frontend\n        \"\"\"\n\n        errors = []\n        for error in metaerrors:\n            last_path = os.path.join(\n                os.path.basename(os.path.dirname(self.filepath)),\n                os.path.basename(self.filepath)\n            )\n            if last_path not in error.get('path', ''):\n                continue\n\n            error_type = error.get('severity', 'X').capitalize()[0]\n            if error_type == 'X':\n                continue\n            if error_type not in ['E', 'W']:\n                error_type = 'V'\n            errors.append({\n                'underline_range': True,\n                'lineno': error.get('line', 0),\n                'offset': error.get('col', 0),\n                'raw_message': error.get('message', ''),\n                'code': 0,\n                'level': error_type,\n                'message': '[{0}] {1} ({2}): {3}'.format(\n                    error_type,\n                    error.get('linter', 'none'),\n                    error.get('severity', 'none'),\n                    error.get('message')\n                )\n            })\n\n        return errors", "line_changes": {"deleted": [{"line_no": 7, "char_start": 183, "char_end": 242, "line": "            if self.filepath not in error.get('path', ''):\n"}], "added": [{"line_no": 7, "char_start": 183, "char_end": 221, "line": "            last_path = os.path.join(\n"}, {"line_no": 8, "char_start": 221, "char_end": 287, "line": "                os.path.basename(os.path.dirname(self.filepath)),\n"}, {"line_no": 9, "char_start": 287, "char_end": 335, "line": "                os.path.basename(self.filepath)\n"}, {"line_no": 10, "char_start": 335, "char_end": 349, "line": "            )\n"}, {"line_no": 11, "char_start": 349, "char_end": 404, "line": "            if last_path not in error.get('path', ''):\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 195, "char_end": 217, "chars": "last_path = os.path.jo"}, {"char_start": 218, "char_end": 273, "chars": "n(\n                os.path.basename(os.path.dirname(sel"}, {"char_start": 274, "char_end": 287, "chars": ".filepath)),\n"}, {"char_start": 288, "char_end": 320, "chars": "               os.path.basename("}, {"char_start": 329, "char_end": 369, "chars": "path)\n            )\n            if last_"}]}, "commit_link": "github.com/DamnWidget/anaconda_go/commit/d3db90bb8853d832927818699591b91f56f6413c", "file_name": "plugin/handlers_go/anagonda/context/gometalinter.py", "vul_type": "cwe-022"}
{"func_name": "dd_load_text_ext", "func_src_before": "char* dd_load_text_ext(const struct dump_dir *dd, const char *name, unsigned flags)\n{\n//    if (!dd->locked)\n//        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    /* Compat with old abrt dumps. Remove in abrt-2.1 */\n    if (strcmp(name, \"release\") == 0)\n        name = FILENAME_OS_RELEASE;\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    char *ret = load_text_file(full_path, flags);\n    free(full_path);\n\n    return ret;\n}", "func_src_after": "char* dd_load_text_ext(const struct dump_dir *dd, const char *name, unsigned flags)\n{\n//    if (!dd->locked)\n//        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    if (!str_is_correct_filename(name))\n    {\n        error_msg(\"Cannot load text. '%s' is not a valid file name\", name);\n        if (!(flags & DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE))\n            xfunc_die();\n    }\n\n    /* Compat with old abrt dumps. Remove in abrt-2.1 */\n    if (strcmp(name, \"release\") == 0)\n        name = FILENAME_OS_RELEASE;\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    char *ret = load_text_file(full_path, flags);\n    free(full_path);\n\n    return ret;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 6, "char_start": 175, "char_end": 215, "line": "    if (!str_is_correct_filename(name))\n"}, {"line_no": 7, "char_start": 215, "char_end": 221, "line": "    {\n"}, {"line_no": 8, "char_start": 221, "char_end": 297, "line": "        error_msg(\"Cannot load text. '%s' is not a valid file name\", name);\n"}, {"line_no": 9, "char_start": 297, "char_end": 357, "line": "        if (!(flags & DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE))\n"}, {"line_no": 10, "char_start": 357, "char_end": 382, "line": "            xfunc_die();\n"}, {"line_no": 11, "char_start": 382, "char_end": 388, "line": "    }\n"}, {"line_no": 12, "char_start": 388, "char_end": 389, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 179, "char_end": 393, "chars": "if (!str_is_correct_filename(name))\n    {\n        error_msg(\"Cannot load text. '%s' is not a valid file name\", name);\n        if (!(flags & DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE))\n            xfunc_die();\n    }\n\n    "}]}, "commit_link": "github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277", "file_name": "src/lib/dump_dir.c", "vul_type": "cwe-022"}
{"func_name": "_download_file", "func_src_before": "    @staticmethod\n    def _download_file(bucket, filename, local_dir):\n        key = bucket.get_key(filename)\n        local_filename = os.path.join(local_dir, filename)\n        key.get_contents_to_filename(local_filename)\n        return local_filename", "func_src_after": "    @staticmethod\n    def _download_file(bucket, filename, local_dir):\n        key = bucket.get_key(filename)\n        local_filename = os.path.join(local_dir, os.path.basename(filename))\n        key.get_contents_to_filename(local_filename)\n        return local_filename", "line_changes": {"deleted": [{"line_no": 4, "char_start": 110, "char_end": 169, "line": "        local_filename = os.path.join(local_dir, filename)\n"}], "added": [{"line_no": 4, "char_start": 110, "char_end": 187, "line": "        local_filename = os.path.join(local_dir, os.path.basename(filename))\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 159, "char_end": 176, "chars": "os.path.basename("}, {"char_start": 184, "char_end": 185, "chars": ")"}]}, "commit_link": "github.com/openstack/nova/commit/76363226bd8533256f7795bba358d7f4b8a6c9e6", "file_name": "nova/image/s3.py", "vul_type": "cwe-022"}
{"func_name": "Utility::UnZip", "func_src_before": "bool Utility::UnZip(const QString &zippath, const QString &destpath)\n{\n    int res = 0;\n    QDir dir(destpath);\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(zippath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(zippath).toUtf8().constData());\n#endif\n\n    if ((zfile == NULL) || (!IsFileReadable(zippath)) || (!dir.exists())) {\n        return false;\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                // Full file path in the temporary directory.\n                QString file_path = destpath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = destpath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        return false;\n    }\n\n    unzClose(zfile);\n    return true;\n}", "func_src_after": "bool Utility::UnZip(const QString &zippath, const QString &destpath)\n{\n    int res = 0;\n    QDir dir(destpath);\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(zippath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(zippath).toUtf8().constData());\n#endif\n\n    if ((zfile == NULL) || (!IsFileReadable(zippath)) || (!dir.exists())) {\n        return false;\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n\n\t        // for security reasons against maliciously crafted zip archives\n\t        // we need the file path to always be inside the target folder \n\t        // and not outside, so we will remove all illegal backslashes\n\t        // and all relative upward paths segments \"/../\" from the zip's local \n\t        // file name/path before prepending the target folder to create \n\t        // the final path\n\n\t        QString original_path = qfile_name;\n\t        bool evil_or_corrupt_epub = false;\n\n\t        if (qfile_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n\t        qfile_name = \"/\" + qfile_name.replace(\"\\\\\",\"\");\n\n\t        if (qfile_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        qfile_name = qfile_name.replace(\"/../\",\"/\");\n\n\t        while(qfile_name.startsWith(\"/\")) { \n\t\t  qfile_name = qfile_name.remove(0,1);\n\t        }\n                \n\t        if (cp437_file_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n\t        cp437_file_name = \"/\" + cp437_file_name.replace(\"\\\\\",\"\");\n\n\t        if (cp437_file_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        cp437_file_name = cp437_file_name.replace(\"/../\",\"/\");\n\n\t        while(cp437_file_name.startsWith(\"/\")) { \n\t\t  cp437_file_name = cp437_file_name.remove(0,1);\n\t        }\n\n\t        if (evil_or_corrupt_epub) {\n\t\t    unzCloseCurrentFile(zfile);\n\t\t    unzClose(zfile);\n\t\t    // throw (UNZIPLoadParseError(QString(QObject::tr(\"Possible evil or corrupt zip file name: %1\")).arg(original_path).toStdString()));\n                    return false;\n\t        }\n\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                // Full file path in the temporary directory.\n                QString file_path = destpath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = destpath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        return false;\n    }\n\n    unzClose(zfile);\n    return true;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 39, "char_start": 1400, "char_end": 1401, "line": "\n"}, {"line_no": 46, "char_start": 1800, "char_end": 1801, "line": "\n"}, {"line_no": 47, "char_start": 1801, "char_end": 1846, "line": "\t        QString original_path = qfile_name;\n"}, {"line_no": 48, "char_start": 1846, "char_end": 1890, "line": "\t        bool evil_or_corrupt_epub = false;\n"}, {"line_no": 49, "char_start": 1890, "char_end": 1891, "line": "\n"}, {"line_no": 50, "char_start": 1891, "char_end": 1961, "line": "\t        if (qfile_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n"}, {"line_no": 51, "char_start": 1961, "char_end": 2018, "line": "\t        qfile_name = \"/\" + qfile_name.replace(\"\\\\\",\"\");\n"}, {"line_no": 52, "char_start": 2018, "char_end": 2019, "line": "\n"}, {"line_no": 53, "char_start": 2019, "char_end": 2090, "line": "\t        if (qfile_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n"}, {"line_no": 54, "char_start": 2090, "char_end": 2144, "line": "\t        qfile_name = qfile_name.replace(\"/../\",\"/\");\n"}, {"line_no": 55, "char_start": 2144, "char_end": 2145, "line": "\n"}, {"line_no": 56, "char_start": 2145, "char_end": 2191, "line": "\t        while(qfile_name.startsWith(\"/\")) { \n"}, {"line_no": 57, "char_start": 2191, "char_end": 2232, "line": "\t\t  qfile_name = qfile_name.remove(0,1);\n"}, {"line_no": 58, "char_start": 2232, "char_end": 2243, "line": "\t        }\n"}, {"line_no": 59, "char_start": 2243, "char_end": 2260, "line": "                \n"}, {"line_no": 60, "char_start": 2260, "char_end": 2335, "line": "\t        if (cp437_file_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n"}, {"line_no": 61, "char_start": 2335, "char_end": 2402, "line": "\t        cp437_file_name = \"/\" + cp437_file_name.replace(\"\\\\\",\"\");\n"}, {"line_no": 62, "char_start": 2402, "char_end": 2403, "line": "\n"}, {"line_no": 63, "char_start": 2403, "char_end": 2479, "line": "\t        if (cp437_file_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n"}, {"line_no": 64, "char_start": 2479, "char_end": 2543, "line": "\t        cp437_file_name = cp437_file_name.replace(\"/../\",\"/\");\n"}, {"line_no": 65, "char_start": 2543, "char_end": 2544, "line": "\n"}, {"line_no": 66, "char_start": 2544, "char_end": 2595, "line": "\t        while(cp437_file_name.startsWith(\"/\")) { \n"}, {"line_no": 67, "char_start": 2595, "char_end": 2646, "line": "\t\t  cp437_file_name = cp437_file_name.remove(0,1);\n"}, {"line_no": 68, "char_start": 2646, "char_end": 2657, "line": "\t        }\n"}, {"line_no": 69, "char_start": 2657, "char_end": 2658, "line": "\n"}, {"line_no": 70, "char_start": 2658, "char_end": 2695, "line": "\t        if (evil_or_corrupt_epub) {\n"}, {"line_no": 71, "char_start": 2695, "char_end": 2729, "line": "\t\t    unzCloseCurrentFile(zfile);\n"}, {"line_no": 72, "char_start": 2729, "char_end": 2752, "line": "\t\t    unzClose(zfile);\n"}, {"line_no": 74, "char_start": 2891, "char_end": 2925, "line": "                    return false;\n"}, {"line_no": 75, "char_start": 2925, "char_end": 2936, "line": "\t        }\n"}, {"line_no": 76, "char_start": 2936, "char_end": 2937, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1400, "char_end": 2937, "chars": "\n\t        // for security reasons against maliciously crafted zip archives\n\t        // we need the file path to always be inside the target folder \n\t        // and not outside, so we will remove all illegal backslashes\n\t        // and all relative upward paths segments \"/../\" from the zip's local \n\t        // file name/path before prepending the target folder to create \n\t        // the final path\n\n\t        QString original_path = qfile_name;\n\t        bool evil_or_corrupt_epub = false;\n\n\t        if (qfile_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n\t        qfile_name = \"/\" + qfile_name.replace(\"\\\\\",\"\");\n\n\t        if (qfile_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        qfile_name = qfile_name.replace(\"/../\",\"/\");\n\n\t        while(qfile_name.startsWith(\"/\")) { \n\t\t  qfile_name = qfile_name.remove(0,1);\n\t        }\n                \n\t        if (cp437_file_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n\t        cp437_file_name = \"/\" + cp437_file_name.replace(\"\\\\\",\"\");\n\n\t        if (cp437_file_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        cp437_file_name = cp437_file_name.replace(\"/../\",\"/\");\n\n\t        while(cp437_file_name.startsWith(\"/\")) { \n\t\t  cp437_file_name = cp437_file_name.remove(0,1);\n\t        }\n\n\t        if (evil_or_corrupt_epub) {\n\t\t    unzCloseCurrentFile(zfile);\n\t\t    unzClose(zfile);\n\t\t    // throw (UNZIPLoadParseError(QString(QObject::tr(\"Possible evil or corrupt zip file name: %1\")).arg(original_path).toStdString()));\n                    return false;\n\t        }\n\n"}]}, "commit_link": "github.com/Sigil-Ebook/Sigil/commit/0979ba8d10c96ebca330715bfd4494ea0e019a8f", "file_name": "src/Misc/Utility.cpp", "vul_type": "cwe-022"}
{"func_name": "save", "func_src_before": "async def save(request):\n    # TODO csrf\n    data = await request.post()\n    item = Item(data['src'])\n\n    # Update name\n    new_src = data.get('new_src')\n    if new_src and new_src != data['src']:\n        # don't need to worry about html unquote\n        shutil.move(item.abspath, settings.STORAGE_DIR + new_src)\n        old_backup_abspath = item.backup_abspath\n        item = Item(new_src)\n        if os.path.isfile(old_backup_abspath):\n            shutil.move(old_backup_abspath, item.backup_abspath)\n\n    # Update meta\n    for field in item.FORM:\n        # TODO handle .repeatable (keywords)\n        item.meta[field] = [data.get(field, '')]\n\n    if settings.SAVE_ORIGINALS and not os.path.isfile(item.backup_abspath):\n        shutil.copyfile(item.abspath, item.backup_abspath)\n\n    # WISHLIST don't write() if nothing changed\n    item.meta.write()\n\n    return web.Response(\n        status=200,\n        body=json.dumps(item.get_form_fields()).encode('utf8'),\n        content_type='application/json',\n    )", "func_src_after": "async def save(request):\n    # TODO csrf\n    data = await request.post()\n    item = Item(data['src'])\n\n    # Update name\n    new_src = data.get('new_src')\n    if new_src:\n        new_abspath = os.path.abspath(settings.STORAGE_DIR + new_src)\n        if not new_abspath.startswith(settings.STORAGE_DIR):\n            return web.Response(status=400, body=b'Invalid Request')\n\n        if new_abspath != item.abspath:\n            shutil.move(item.abspath, new_abspath)\n            old_backup_abspath = item.backup_abspath\n            item = Item(new_src)\n            if os.path.isfile(old_backup_abspath):\n                shutil.move(old_backup_abspath, item.backup_abspath)\n\n    # Update meta\n    for field in item.FORM:\n        # TODO handle .repeatable (keywords)\n        item.meta[field] = [data.get(field, '')]\n\n    if settings.SAVE_ORIGINALS and not os.path.isfile(item.backup_abspath):\n        shutil.copyfile(item.abspath, item.backup_abspath)\n\n    # WISHLIST don't write() if nothing changed\n    item.meta.write()\n\n    return web.Response(\n        status=200,\n        body=json.dumps(item.get_form_fields()).encode('utf8'),\n        content_type='application/json',\n    )", "line_changes": {"deleted": [{"line_no": 8, "char_start": 155, "char_end": 198, "line": "    if new_src and new_src != data['src']:\n"}, {"line_no": 10, "char_start": 247, "char_end": 313, "line": "        shutil.move(item.abspath, settings.STORAGE_DIR + new_src)\n"}, {"line_no": 11, "char_start": 313, "char_end": 362, "line": "        old_backup_abspath = item.backup_abspath\n"}, {"line_no": 12, "char_start": 362, "char_end": 391, "line": "        item = Item(new_src)\n"}, {"line_no": 13, "char_start": 391, "char_end": 438, "line": "        if os.path.isfile(old_backup_abspath):\n"}, {"line_no": 14, "char_start": 438, "char_end": 503, "line": "            shutil.move(old_backup_abspath, item.backup_abspath)\n"}], "added": [{"line_no": 8, "char_start": 155, "char_end": 171, "line": "    if new_src:\n"}, {"line_no": 9, "char_start": 171, "char_end": 241, "line": "        new_abspath = os.path.abspath(settings.STORAGE_DIR + new_src)\n"}, {"line_no": 10, "char_start": 241, "char_end": 302, "line": "        if not new_abspath.startswith(settings.STORAGE_DIR):\n"}, {"line_no": 11, "char_start": 302, "char_end": 371, "line": "            return web.Response(status=400, body=b'Invalid Request')\n"}, {"line_no": 12, "char_start": 371, "char_end": 372, "line": "\n"}, {"line_no": 13, "char_start": 372, "char_end": 412, "line": "        if new_abspath != item.abspath:\n"}, {"line_no": 14, "char_start": 412, "char_end": 463, "line": "            shutil.move(item.abspath, new_abspath)\n"}, {"line_no": 15, "char_start": 463, "char_end": 516, "line": "            old_backup_abspath = item.backup_abspath\n"}, {"line_no": 16, "char_start": 516, "char_end": 549, "line": "            item = Item(new_src)\n"}, {"line_no": 17, "char_start": 549, "char_end": 600, "line": "            if os.path.isfile(old_backup_abspath):\n"}, {"line_no": 18, "char_start": 600, "char_end": 669, "line": "                shutil.move(old_backup_abspath, item.backup_abspath)\n"}]}, "char_changes": {"deleted": [{"char_start": 170, "char_end": 173, "chars": "and"}, {"char_start": 179, "char_end": 181, "chars": "rc"}, {"char_start": 182, "char_end": 183, "chars": "!"}, {"char_start": 185, "char_end": 186, "chars": "d"}, {"char_start": 189, "char_end": 191, "chars": "['"}, {"char_start": 194, "char_end": 197, "chars": "']:"}, {"char_start": 206, "char_end": 207, "chars": "#"}, {"char_start": 208, "char_end": 209, "chars": "d"}, {"char_start": 210, "char_end": 212, "chars": "n'"}, {"char_start": 217, "char_end": 218, "chars": "d"}, {"char_start": 219, "char_end": 221, "chars": "to"}, {"char_start": 222, "char_end": 224, "chars": "wo"}, {"char_start": 226, "char_end": 227, "chars": "y"}, {"char_start": 228, "char_end": 229, "chars": "a"}, {"char_start": 232, "char_end": 233, "chars": "t"}, {"char_start": 234, "char_end": 237, "chars": "htm"}, {"char_start": 239, "char_end": 241, "chars": "un"}, {"char_start": 243, "char_end": 244, "chars": "o"}, {"char_start": 281, "char_end": 304, "chars": "settings.STORAGE_DIR + "}, {"char_start": 309, "char_end": 311, "chars": "rc"}], "added": [{"char_start": 169, "char_end": 171, "chars": ":\n"}, {"char_start": 172, "char_end": 178, "chars": "      "}, {"char_start": 183, "char_end": 185, "chars": "ab"}, {"char_start": 186, "char_end": 190, "chars": "path"}, {"char_start": 193, "char_end": 197, "chars": "os.p"}, {"char_start": 199, "char_end": 201, "chars": "h."}, {"char_start": 202, "char_end": 236, "chars": "bspath(settings.STORAGE_DIR + new_"}, {"char_start": 239, "char_end": 240, "chars": ")"}, {"char_start": 249, "char_end": 251, "chars": "if"}, {"char_start": 253, "char_end": 254, "chars": "o"}, {"char_start": 258, "char_end": 280, "chars": "w_abspath.startswith(s"}, {"char_start": 281, "char_end": 305, "chars": "ttings.STORAGE_DIR):\n   "}, {"char_start": 306, "char_end": 316, "chars": "        re"}, {"char_start": 317, "char_end": 320, "chars": "urn"}, {"char_start": 322, "char_end": 329, "chars": "eb.Resp"}, {"char_start": 330, "char_end": 336, "chars": "nse(st"}, {"char_start": 337, "char_end": 346, "chars": "tus=400, "}, {"char_start": 348, "char_end": 364, "chars": "dy=b'Invalid Req"}, {"char_start": 365, "char_end": 367, "chars": "es"}, {"char_start": 368, "char_end": 379, "chars": "')\n\n       "}, {"char_start": 380, "char_end": 393, "chars": "if new_abspat"}, {"char_start": 394, "char_end": 399, "chars": " != i"}, {"char_start": 400, "char_end": 401, "chars": "e"}, {"char_start": 402, "char_end": 408, "chars": ".abspa"}, {"char_start": 409, "char_end": 411, "chars": "h:"}, {"char_start": 412, "char_end": 416, "chars": "    "}, {"char_start": 454, "char_end": 456, "chars": "ab"}, {"char_start": 457, "char_end": 461, "chars": "path"}, {"char_start": 463, "char_end": 467, "chars": "    "}, {"char_start": 516, "char_end": 520, "chars": "    "}, {"char_start": 557, "char_end": 561, "chars": "    "}, {"char_start": 600, "char_end": 604, "chars": "    "}]}, "commit_link": "github.com/crccheck/gallery-cms/commit/60dec5c580a779ae27824ed54cb113eca25afdc0", "file_name": "gallery/gallery.py", "vul_type": "cwe-022"}
{"func_name": "wiki_handle_rest_call", "func_src_before": "wiki_handle_rest_call(HttpRequest  *req, \n\t\t      HttpResponse *res,\n\t\t      char         *func)\n{\n\n  if (func != NULL && *func != '\\0')\n    {\n      if (!strcmp(func, \"page/get\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && (access(page, R_OK) == 0)) \n\t    {\n\t      http_response_printf(res, \"%s\", file_read(page));\n\t      http_response_send(res);\n\t      return;\n\t    }  \n\t}\n      else if (!strcmp(func, \"page/set\"))\n\t{\n\t  char *wikitext = NULL, *page = NULL;\n\t  if( ( (wikitext = http_request_param_get(req, \"text\")) != NULL)\n\t      && ( (page = http_request_param_get(req, \"page\")) != NULL))\n\t    {\n\t      file_write(page, wikitext);\t      \n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;\n\t    }\n\t}\n      else if (!strcmp(func, \"page/delete\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && (unlink(page) > 0))\n\t    {\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n      else if (!strcmp(func, \"page/exists\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && (access(page, R_OK) == 0)) \n\t    {\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n      else if (!strcmp(func, \"pages\") || !strcmp(func, \"search\"))\n\t{\n\t  WikiPageList **pages = NULL;\n\t  int            n_pages, i;\n\t  char          *expr = http_request_param_get(req, \"expr\");\n\n\t  if (expr == NULL)\n\t    expr = http_request_get_query_string(req);\n\t  \n\t  pages = wiki_get_pages(&n_pages, expr);\n\n\t  if (pages)\n\t    {\n\t      for (i=0; i<n_pages; i++)\n\t\t{\n\t\t  struct tm   *pTm;\n\t\t  char   datebuf[64];\n\t\t  \n\t\t  pTm = localtime(&pages[i]->mtime);\n\t\t  strftime(datebuf, sizeof(datebuf), \"%Y-%m-%d %H:%M\", pTm);\n\t\t  http_response_printf(res, \"%s\\t%s\\n\", pages[i]->name, datebuf);\n\t\t}\n\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n    }\n\n  http_response_set_status(res, 500, \"Error\");\n  http_response_printf(res, \"<html><body>Failed</body></html>\\n\");\n  http_response_send(res);\n\n  return;  \n}", "func_src_after": "wiki_handle_rest_call(HttpRequest  *req, \n\t\t      HttpResponse *res,\n\t\t      char         *func)\n{\n\n  if (func != NULL && *func != '\\0')\n    {\n      if (!strcmp(func, \"page/get\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))\n\t    {\n\t      http_response_printf(res, \"%s\", file_read(page));\n\t      http_response_send(res);\n\t      return;\n\t    }  \n\t}\n      else if (!strcmp(func, \"page/set\"))\n\t{\n\t  char *wikitext = NULL, *page = NULL;\n\t  if( ( (wikitext = http_request_param_get(req, \"text\")) != NULL)\n\t      && ( (page = http_request_param_get(req, \"page\")) != NULL))\n\t    {\n\t  if (page_name_is_good(page))\n\t    {\n\t      file_write(page, wikitext);\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;\n\t    }\n\t    }\n\t}\n      else if (!strcmp(func, \"page/delete\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && page_name_is_good(page) && (unlink(page) > 0))\n\t    {\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n      else if (!strcmp(func, \"page/exists\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))\n\t    {\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n      else if (!strcmp(func, \"pages\") || !strcmp(func, \"search\"))\n\t{\n\t  WikiPageList **pages = NULL;\n\t  int            n_pages, i;\n\t  char          *expr = http_request_param_get(req, \"expr\");\n\n\t  if (expr == NULL)\n\t    expr = http_request_get_query_string(req);\n\t  \n\t  pages = wiki_get_pages(&n_pages, expr);\n\n\t  if (pages)\n\t    {\n\t      for (i=0; i<n_pages; i++)\n\t\t{\n\t\t  struct tm   *pTm;\n\t\t  char   datebuf[64];\n\t\t  \n\t\t  pTm = localtime(&pages[i]->mtime);\n\t\t  strftime(datebuf, sizeof(datebuf), \"%Y-%m-%d %H:%M\", pTm);\n\t\t  http_response_printf(res, \"%s\\t%s\\n\", pages[i]->name, datebuf);\n\t\t}\n\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n    }\n\n  http_response_set_status(res, 500, \"Error\");\n  http_response_printf(res, \"<html><body>Failed</body></html>\\n\");\n  http_response_send(res);\n\n  return;  \n}", "line_changes": {"deleted": [{"line_no": 15, "char_start": 307, "char_end": 350, "line": "\t  if (page && (access(page, R_OK) == 0)) \n"}, {"line_no": 28, "char_start": 699, "char_end": 741, "line": "\t      file_write(page, wikitext);\t      \n"}, {"line_no": 41, "char_start": 1015, "char_end": 1050, "line": "\t  if (page && (unlink(page) > 0))\n"}, {"line_no": 55, "char_start": 1333, "char_end": 1376, "line": "\t  if (page && (access(page, R_OK) == 0)) \n"}], "added": [{"line_no": 15, "char_start": 307, "char_end": 376, "line": "\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))\n"}, {"line_no": 28, "char_start": 725, "char_end": 757, "line": "\t  if (page_name_is_good(page))\n"}, {"line_no": 29, "char_start": 757, "char_end": 764, "line": "\t    {\n"}, {"line_no": 30, "char_start": 764, "char_end": 799, "line": "\t      file_write(page, wikitext);\n"}, {"line_no": 35, "char_start": 898, "char_end": 905, "line": "\t    }\n"}, {"line_no": 44, "char_start": 1080, "char_end": 1142, "line": "\t  if (page && page_name_is_good(page) && (unlink(page) > 0))\n"}, {"line_no": 58, "char_start": 1425, "char_end": 1494, "line": "\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))\n"}]}, "char_changes": {"deleted": [{"char_start": 348, "char_end": 349, "chars": " "}, {"char_start": 733, "char_end": 740, "chars": "\t      "}, {"char_start": 1374, "char_end": 1375, "chars": " "}], "added": [{"char_start": 322, "char_end": 349, "chars": "page_name_is_good(page) && "}, {"char_start": 725, "char_end": 764, "chars": "\t  if (page_name_is_good(page))\n\t    {\n"}, {"char_start": 898, "char_end": 905, "chars": "\t    }\n"}, {"char_start": 1095, "char_end": 1122, "chars": "page_name_is_good(page) && "}, {"char_start": 1440, "char_end": 1467, "chars": "page_name_is_good(page) && "}]}, "commit_link": "github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea", "file_name": "src/wiki.c", "vul_type": "cwe-022"}
{"func_name": "handle_method_call", "func_src_before": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (element == NULL || element[0] == '\\0' || strlen(element) > 64)\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}", "func_src_after": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}", "line_changes": {"deleted": [{"line_no": 259, "char_start": 9073, "char_end": 9148, "line": "        if (element == NULL || element[0] == '\\0' || strlen(element) > 64)\n"}], "added": [{"line_no": 259, "char_start": 9073, "char_end": 9120, "line": "        if (!str_is_correct_filename(element))\n"}, {"line_no": 318, "char_start": 11559, "char_end": 11606, "line": "        if (!str_is_correct_filename(element))\n"}, {"line_no": 319, "char_start": 11606, "char_end": 11616, "line": "        {\n"}, {"line_no": 320, "char_start": 11616, "char_end": 11705, "line": "            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n"}, {"line_no": 321, "char_start": 11705, "char_end": 11790, "line": "            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n"}, {"line_no": 322, "char_start": 11790, "char_end": 11857, "line": "            g_dbus_method_invocation_return_dbus_error(invocation,\n"}, {"line_no": 323, "char_start": 11857, "char_end": 11946, "line": "                                              \"org.freedesktop.problems.InvalidElement\",\n"}, {"line_no": 324, "char_start": 11946, "char_end": 12000, "line": "                                              error);\n"}, {"line_no": 325, "char_start": 12000, "char_end": 12001, "line": "\n"}, {"line_no": 326, "char_start": 12001, "char_end": 12026, "line": "            free(error);\n"}, {"line_no": 327, "char_start": 12026, "char_end": 12046, "line": "            return;\n"}, {"line_no": 328, "char_start": 12046, "char_end": 12056, "line": "        }\n"}, {"line_no": 329, "char_start": 12056, "char_end": 12057, "line": "\n"}]}, "char_changes": {"deleted": [{"char_start": 9085, "char_end": 9126, "chars": "element == NULL || element[0] == '\\0' || "}, {"char_start": 9141, "char_end": 9146, "chars": " > 64"}], "added": [{"char_start": 9085, "char_end": 9097, "chars": "!str_is_corr"}, {"char_start": 9098, "char_end": 9103, "chars": "ct_fi"}, {"char_start": 9106, "char_end": 9107, "chars": "a"}, {"char_start": 11557, "char_end": 12055, "chars": "\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }"}]}, "commit_link": "github.com/abrt/abrt/commit/f3c2a6af3455b2882e28570e8a04f1c2d4500d5b", "file_name": "src/dbus/abrt-dbus.c", "vul_type": "cwe-022"}
{"func_name": "HPHP::extractFileTo", "func_src_before": "static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                          char* buf, size_t len) {\n  auto sep = file.rfind('/');\n  if (sep != std::string::npos) {\n    auto path = to + file.substr(0, sep);\n    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n      return false;\n    }\n\n    if (sep == file.length() - 1) {\n      return true;\n    }\n  }\n\n  to.append(file);\n  struct zip_stat zipStat;\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n\n  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n  FAIL_IF_INVALID_PTR(zipFile);\n\n  auto outFile = fopen(to.c_str(), \"wb\");\n  if (outFile == nullptr) {\n    zip_fclose(zipFile);\n    return false;\n  }\n\n  for (auto n = zip_fread(zipFile, buf, len); n != 0;\n       n = zip_fread(zipFile, buf, len)) {\n    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {\n      zip_fclose(zipFile);\n      fclose(outFile);\n      remove(to.c_str());\n      return false;\n    }\n  }\n\n  zip_fclose(zipFile);\n  if (fclose(outFile) != 0) {\n    return false;\n  }\n\n  return true;\n}", "func_src_after": "static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                          char* buf, size_t len) {\n\n  struct zip_stat zipStat;\n  // Verify the file to be extracted is actually in the zip file\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n\n  auto clean_file = file;\n  auto sep = std::string::npos;\n  // Normally would just use std::string::rfind here, but if we want to be\n  // consistent between Windows and Linux, even if techincally Linux won't use\n  // backslash for a separator, we are checking for both types.\n  int idx = file.length() - 1;\n  while (idx >= 0) {\n    if (FileUtil::isDirSeparator(file[idx])) {\n      sep = idx;\n      break;\n    }\n    idx--;\n  }\n  if (sep != std::string::npos) {\n    // make_relative_path so we do not try to put files or dirs in bad\n    // places. This securely \"cleans\" the file.\n    clean_file = make_relative_path(file);\n    std::string path = to + clean_file;\n    bool is_dir_only = true;\n    if (sep < file.length() - 1) { // not just a directory\n      auto clean_file_dir = HHVM_FN(dirname)(clean_file);\n      path = to + clean_file_dir.toCppString();\n      is_dir_only = false;\n    }\n\n    // Make sure the directory path to extract to exists or can be created\n    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n      return false;\n    }\n\n    // If we have a good directory to extract to above, we now check whether\n    // the \"file\" parameter passed in is a directory or actually a file.\n    if (is_dir_only) { // directory, like /usr/bin/\n      return true;\n    }\n    // otherwise file is actually a file, so we actually extract.\n  }\n\n  // We have ensured that clean_file will be added to a relative path by the\n  // time we get here.\n  to.append(clean_file);\n\n  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n  FAIL_IF_INVALID_PTR(zipFile);\n\n  auto outFile = fopen(to.c_str(), \"wb\");\n  if (outFile == nullptr) {\n    zip_fclose(zipFile);\n    return false;\n  }\n\n  for (auto n = zip_fread(zipFile, buf, len); n != 0;\n       n = zip_fread(zipFile, buf, len)) {\n    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {\n      zip_fclose(zipFile);\n      fclose(outFile);\n      remove(to.c_str());\n      return false;\n    }\n  }\n\n  zip_fclose(zipFile);\n  if (fclose(outFile) != 0) {\n    return false;\n  }\n\n  return true;\n}", "line_changes": {"deleted": [{"line_no": 3, "char_start": 129, "char_end": 159, "line": "  auto sep = file.rfind('/');\n"}, {"line_no": 5, "char_start": 193, "char_end": 235, "line": "    auto path = to + file.substr(0, sep);\n"}, {"line_no": 10, "char_start": 333, "char_end": 369, "line": "    if (sep == file.length() - 1) {\n"}, {"line_no": 15, "char_start": 399, "char_end": 418, "line": "  to.append(file);\n"}, {"line_no": 16, "char_start": 418, "char_end": 445, "line": "  struct zip_stat zipStat;\n"}, {"line_no": 17, "char_start": 445, "char_end": 500, "line": "  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n"}, {"line_no": 18, "char_start": 500, "char_end": 518, "line": "    return false;\n"}, {"line_no": 19, "char_start": 518, "char_end": 522, "line": "  }\n"}], "added": [{"line_no": 3, "char_start": 129, "char_end": 130, "line": "\n"}, {"line_no": 4, "char_start": 130, "char_end": 157, "line": "  struct zip_stat zipStat;\n"}, {"line_no": 6, "char_start": 222, "char_end": 277, "line": "  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n"}, {"line_no": 7, "char_start": 277, "char_end": 295, "line": "    return false;\n"}, {"line_no": 8, "char_start": 295, "char_end": 299, "line": "  }\n"}, {"line_no": 9, "char_start": 299, "char_end": 300, "line": "\n"}, {"line_no": 10, "char_start": 300, "char_end": 326, "line": "  auto clean_file = file;\n"}, {"line_no": 11, "char_start": 326, "char_end": 358, "line": "  auto sep = std::string::npos;\n"}, {"line_no": 15, "char_start": 576, "char_end": 607, "line": "  int idx = file.length() - 1;\n"}, {"line_no": 16, "char_start": 607, "char_end": 628, "line": "  while (idx >= 0) {\n"}, {"line_no": 17, "char_start": 628, "char_end": 675, "line": "    if (FileUtil::isDirSeparator(file[idx])) {\n"}, {"line_no": 18, "char_start": 675, "char_end": 692, "line": "      sep = idx;\n"}, {"line_no": 19, "char_start": 692, "char_end": 705, "line": "      break;\n"}, {"line_no": 20, "char_start": 705, "char_end": 711, "line": "    }\n"}, {"line_no": 21, "char_start": 711, "char_end": 722, "line": "    idx--;\n"}, {"line_no": 22, "char_start": 722, "char_end": 726, "line": "  }\n"}, {"line_no": 26, "char_start": 879, "char_end": 922, "line": "    clean_file = make_relative_path(file);\n"}, {"line_no": 27, "char_start": 922, "char_end": 962, "line": "    std::string path = to + clean_file;\n"}, {"line_no": 28, "char_start": 962, "char_end": 991, "line": "    bool is_dir_only = true;\n"}, {"line_no": 29, "char_start": 991, "char_end": 1050, "line": "    if (sep < file.length() - 1) { // not just a directory\n"}, {"line_no": 30, "char_start": 1050, "char_end": 1108, "line": "      auto clean_file_dir = HHVM_FN(dirname)(clean_file);\n"}, {"line_no": 31, "char_start": 1108, "char_end": 1156, "line": "      path = to + clean_file_dir.toCppString();\n"}, {"line_no": 32, "char_start": 1156, "char_end": 1183, "line": "      is_dir_only = false;\n"}, {"line_no": 33, "char_start": 1183, "char_end": 1189, "line": "    }\n"}, {"line_no": 34, "char_start": 1189, "char_end": 1190, "line": "\n"}, {"line_no": 42, "char_start": 1513, "char_end": 1565, "line": "    if (is_dir_only) { // directory, like /usr/bin/\n"}, {"line_no": 50, "char_start": 1761, "char_end": 1786, "line": "  to.append(clean_file);\n"}]}, "char_changes": {"deleted": [{"char_start": 132, "char_end": 133, "chars": "u"}, {"char_start": 140, "char_end": 141, "chars": "="}, {"char_start": 152, "char_end": 154, "chars": "('"}, {"char_start": 218, "char_end": 219, "chars": "."}, {"char_start": 221, "char_end": 222, "chars": "b"}, {"char_start": 224, "char_end": 225, "chars": "r"}, {"char_start": 226, "char_end": 228, "chars": "0,"}, {"char_start": 337, "char_end": 338, "chars": "i"}, {"char_start": 340, "char_end": 342, "chars": "(s"}, {"char_start": 343, "char_end": 344, "chars": "p"}, {"char_start": 345, "char_end": 347, "chars": "=="}, {"char_start": 352, "char_end": 354, "chars": ".l"}, {"char_start": 356, "char_end": 357, "chars": "g"}, {"char_start": 358, "char_end": 359, "chars": "h"}, {"char_start": 362, "char_end": 363, "chars": "-"}, {"char_start": 364, "char_end": 366, "chars": "1)"}, {"char_start": 367, "char_end": 368, "chars": "{"}, {"char_start": 396, "char_end": 399, "chars": "}\n\n"}, {"char_start": 402, "char_end": 407, "chars": "o.app"}, {"char_start": 408, "char_end": 411, "chars": "nd("}, {"char_start": 415, "char_end": 418, "chars": ");\n"}, {"char_start": 420, "char_end": 421, "chars": "s"}, {"char_start": 422, "char_end": 423, "chars": "r"}, {"char_start": 424, "char_end": 426, "chars": "ct"}, {"char_start": 427, "char_end": 428, "chars": "z"}, {"char_start": 429, "char_end": 431, "chars": "p_"}, {"char_start": 432, "char_end": 433, "chars": "t"}, {"char_start": 436, "char_end": 440, "chars": "zipS"}, {"char_start": 443, "char_end": 444, "chars": ";"}, {"char_start": 447, "char_end": 449, "chars": "if"}, {"char_start": 450, "char_end": 455, "chars": "(zip_"}, {"char_start": 459, "char_end": 464, "chars": "(zip,"}, {"char_start": 469, "char_end": 473, "chars": ".c_s"}, {"char_start": 474, "char_end": 478, "chars": "r(),"}, {"char_start": 479, "char_end": 481, "chars": "0,"}, {"char_start": 482, "char_end": 484, "chars": "&z"}, {"char_start": 486, "char_end": 488, "chars": "St"}, {"char_start": 490, "char_end": 491, "chars": ")"}, {"char_start": 492, "char_end": 494, "chars": "!="}, {"char_start": 495, "char_end": 499, "chars": "0) {"}, {"char_start": 507, "char_end": 509, "chars": "ur"}, {"char_start": 510, "char_end": 512, "chars": " f"}, {"char_start": 514, "char_end": 515, "chars": "s"}, {"char_start": 517, "char_end": 521, "chars": "\n  }"}], "added": [{"char_start": 129, "char_end": 326, "chars": "\n  struct zip_stat zipStat;\n  // Verify the file to be extracted is actually in the zip file\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n\n  auto clean_file = file;\n"}, {"char_start": 339, "char_end": 401, "chars": "std::string::npos;\n  // Normally would just use std::string::r"}, {"char_start": 403, "char_end": 492, "chars": "nd here, but if we want to be\n  // consistent between Windows and Linux, even if techinca"}, {"char_start": 493, "char_end": 510, "chars": "ly Linux won't us"}, {"char_start": 511, "char_end": 541, "chars": "\n  // backslash for a separato"}, {"char_start": 542, "char_end": 560, "chars": ", we are checking "}, {"char_start": 561, "char_end": 578, "chars": "or both types.\n  "}, {"char_start": 580, "char_end": 583, "chars": "t i"}, {"char_start": 584, "char_end": 599, "chars": "x = file.length"}, {"char_start": 601, "char_end": 605, "chars": " - 1"}, {"char_start": 609, "char_end": 728, "chars": "while (idx >= 0) {\n    if (FileUtil::isDirSeparator(file[idx])) {\n      sep = idx;\n      break;\n    }\n    idx--;\n  }\n  "}, {"char_start": 764, "char_end": 768, "chars": "// m"}, {"char_start": 769, "char_end": 807, "chars": "ke_relative_path so we do not try to p"}, {"char_start": 809, "char_end": 816, "chars": " files "}, {"char_start": 817, "char_end": 937, "chars": "r dirs in bad\n    // places. This securely \"cleans\" the file.\n    clean_file = make_relative_path(file);\n    std::string"}, {"char_start": 950, "char_end": 956, "chars": "clean_"}, {"char_start": 960, "char_end": 972, "chars": ";\n    bool i"}, {"char_start": 973, "char_end": 987, "chars": "_dir_only = tr"}, {"char_start": 988, "char_end": 999, "chars": "e;\n    if ("}, {"char_start": 1000, "char_end": 1014, "chars": "ep < file.leng"}, {"char_start": 1015, "char_end": 1042, "chars": "h() - 1) { // not just a di"}, {"char_start": 1043, "char_end": 1085, "chars": "ectory\n      auto clean_file_dir = HHVM_FN"}, {"char_start": 1086, "char_end": 1125, "chars": "dirname)(clean_file);\n      path = to +"}, {"char_start": 1126, "char_end": 1128, "chars": "cl"}, {"char_start": 1129, "char_end": 1144, "chars": "an_file_dir.toC"}, {"char_start": 1145, "char_end": 1153, "chars": "pString("}, {"char_start": 1156, "char_end": 1265, "chars": "      is_dir_only = false;\n    }\n\n    // Make sure the directory path to extract to exists or can be created\n"}, {"char_start": 1367, "char_end": 1389, "chars": "// If we have a good d"}, {"char_start": 1390, "char_end": 1431, "chars": "rectory to extract to above, we now check"}, {"char_start": 1432, "char_end": 1437, "chars": "wheth"}, {"char_start": 1438, "char_end": 1442, "chars": "r\n  "}, {"char_start": 1444, "char_end": 1452, "chars": "// the \""}, {"char_start": 1456, "char_end": 1463, "chars": "\" param"}, {"char_start": 1464, "char_end": 1476, "chars": "ter passed i"}, {"char_start": 1477, "char_end": 1488, "chars": " is a direc"}, {"char_start": 1489, "char_end": 1492, "chars": "ory"}, {"char_start": 1493, "char_end": 1495, "chars": "or"}, {"char_start": 1496, "char_end": 1532, "chars": "actually a file.\n    if (is_dir_only"}, {"char_start": 1535, "char_end": 1564, "chars": " // directory, like /usr/bin/"}, {"char_start": 1594, "char_end": 1598, "chars": "// o"}, {"char_start": 1599, "char_end": 1605, "chars": "herwis"}, {"char_start": 1606, "char_end": 1607, "chars": " "}, {"char_start": 1612, "char_end": 1614, "chars": "is"}, {"char_start": 1615, "char_end": 1617, "chars": "ac"}, {"char_start": 1619, "char_end": 1623, "chars": "ally"}, {"char_start": 1624, "char_end": 1627, "chars": "a f"}, {"char_start": 1628, "char_end": 1632, "chars": "le, "}, {"char_start": 1633, "char_end": 1640, "chars": "o we ac"}, {"char_start": 1641, "char_end": 1642, "chars": "u"}, {"char_start": 1643, "char_end": 1646, "chars": "lly"}, {"char_start": 1647, "char_end": 1649, "chars": "ex"}, {"char_start": 1650, "char_end": 1651, "chars": "r"}, {"char_start": 1652, "char_end": 1653, "chars": "c"}, {"char_start": 1654, "char_end": 1655, "chars": "."}, {"char_start": 1658, "char_end": 1661, "chars": "}\n\n"}, {"char_start": 1662, "char_end": 1676, "chars": " // We have en"}, {"char_start": 1677, "char_end": 1682, "chars": "ured "}, {"char_start": 1683, "char_end": 1684, "chars": "h"}, {"char_start": 1687, "char_end": 1693, "chars": "clean_"}, {"char_start": 1697, "char_end": 1712, "chars": " will be added "}, {"char_start": 1713, "char_end": 1714, "chars": "o"}, {"char_start": 1715, "char_end": 1716, "chars": "a"}, {"char_start": 1717, "char_end": 1722, "chars": "relat"}, {"char_start": 1723, "char_end": 1726, "chars": "ve "}, {"char_start": 1729, "char_end": 1730, "chars": "h"}, {"char_start": 1731, "char_end": 1733, "chars": "by"}, {"char_start": 1734, "char_end": 1739, "chars": "the\n "}, {"char_start": 1740, "char_end": 1742, "chars": "//"}, {"char_start": 1743, "char_end": 1747, "chars": "time"}, {"char_start": 1748, "char_end": 1750, "chars": "we"}, {"char_start": 1751, "char_end": 1754, "chars": "get"}, {"char_start": 1755, "char_end": 1757, "chars": "he"}, {"char_start": 1759, "char_end": 1763, "chars": ".\n  "}, {"char_start": 1764, "char_end": 1770, "chars": "o.appe"}, {"char_start": 1771, "char_end": 1779, "chars": "d(clean_"}, {"char_start": 1780, "char_end": 1781, "chars": "i"}, {"char_start": 1783, "char_end": 1784, "chars": ")"}]}, "commit_link": "github.com/facebook/hhvm/commit/65c95a01541dd2fbc9c978ac53bed235b5376686", "file_name": "hphp/runtime/ext/zip/ext_zip.cpp", "vul_type": "cwe-022"}
{"func_name": "new_goal", "func_src_before": "def new_goal():\n    \"\"\"\n    new goal\n    \"\"\"\n\n    goals_dir_check()\n\n    click.echo(chalk.blue('Input a single-word name of the goal:'))\n    goal_name = input().strip()\n\n    if goal_name_exists(goal_name):\n        click.echo(chalk.red(\n            'A goal with this name already exists. Please type \"yoda goals view\" to see a list of existing goals'))\n    else:\n        click.echo(chalk.blue('Input description of the goal:'))\n        text = input().strip()\n\n        click.echo(chalk.blue('Input due date for the goal (YYYY-MM-DD):'))\n        deadline = input().strip()\n\n        if os.path.isfile(GOALS_CONFIG_FILE_PATH):\n            setup_data = dict(\n                name=goal_name,\n                text=text,\n                deadline=deadline,\n                status=0\n            )\n            append_data_into_file(setup_data, GOALS_CONFIG_FILE_PATH)\n        else:\n            setup_data = dict(\n                entries=[\n                    dict(\n                        name=goal_name,\n                        text=text,\n                        deadline=deadline,\n                        status=0\n                    )\n                ]\n            )\n            input_data(setup_data, GOALS_CONFIG_FILE_PATH)\n\n        input_data(dict(entries=[]), get_goal_file_path(goal_name))", "func_src_after": "def new_goal():\n    \"\"\"\n    new goal\n    \"\"\"\n\n    goals_dir_check()\n\n    goal_name_not_ok = True\n\n    click.echo(chalk.blue('Input a single-word name of the goal:'))\n    while goal_name_not_ok:\n        goal_name = input().strip()\n        if goal_name.isalnum():\n            goal_name_not_ok = False\n        else:\n            click.echo(chalk.red('Only alphanumeric characters can be used! Please input the goal name:'))\n\n    if goal_name_exists(goal_name):\n        click.echo(chalk.red(\n            'A goal with this name already exists. Please type \"yoda goals view\" to see a list of existing goals'))\n    else:\n        click.echo(chalk.blue('Input description of the goal:'))\n        text = input().strip()\n\n        click.echo(chalk.blue('Input due date for the goal (YYYY-MM-DD):'))\n        incorrect_date_format = True\n        while incorrect_date_format:\n            deadline = input().strip()\n            try:\n                date_str = datetime.datetime.strptime(deadline, '%Y-%m-%d').strftime('%Y-%m-%d')\n                if date_str != deadline:\n                    raise ValueError\n                incorrect_date_format = False\n            except ValueError:\n                click.echo(chalk.red(\"Incorrect data format, should be YYYY-MM-DD. Please repeat:\"))\n\n        if os.path.isfile(GOALS_CONFIG_FILE_PATH):\n            setup_data = dict(\n                name=goal_name,\n                text=text,\n                deadline=deadline,\n                status=0\n            )\n            append_data_into_file(setup_data, GOALS_CONFIG_FILE_PATH)\n        else:\n            setup_data = dict(\n                entries=[\n                    dict(\n                        name=goal_name,\n                        text=text,\n                        deadline=deadline,\n                        status=0\n                    )\n                ]\n            )\n            input_data(setup_data, GOALS_CONFIG_FILE_PATH)\n\n        input_data(dict(entries=[]), get_goal_file_path(goal_name))", "line_changes": {"deleted": [{"line_no": 9, "char_start": 137, "char_end": 169, "line": "    goal_name = input().strip()\n"}, {"line_no": 19, "char_start": 535, "char_end": 570, "line": "        deadline = input().strip()\n"}], "added": [{"line_no": 8, "char_start": 69, "char_end": 97, "line": "    goal_name_not_ok = True\n"}, {"line_no": 9, "char_start": 97, "char_end": 98, "line": "\n"}, {"line_no": 11, "char_start": 166, "char_end": 194, "line": "    while goal_name_not_ok:\n"}, {"line_no": 12, "char_start": 194, "char_end": 230, "line": "        goal_name = input().strip()\n"}, {"line_no": 13, "char_start": 230, "char_end": 262, "line": "        if goal_name.isalnum():\n"}, {"line_no": 14, "char_start": 262, "char_end": 299, "line": "            goal_name_not_ok = False\n"}, {"line_no": 15, "char_start": 299, "char_end": 313, "line": "        else:\n"}, {"line_no": 16, "char_start": 313, "char_end": 420, "line": "            click.echo(chalk.red('Only alphanumeric characters can be used! Please input the goal name:'))\n"}, {"line_no": 26, "char_start": 786, "char_end": 823, "line": "        incorrect_date_format = True\n"}, {"line_no": 27, "char_start": 823, "char_end": 860, "line": "        while incorrect_date_format:\n"}, {"line_no": 28, "char_start": 860, "char_end": 899, "line": "            deadline = input().strip()\n"}, {"line_no": 29, "char_start": 899, "char_end": 916, "line": "            try:\n"}, {"line_no": 30, "char_start": 916, "char_end": 1013, "line": "                date_str = datetime.datetime.strptime(deadline, '%Y-%m-%d').strftime('%Y-%m-%d')\n"}, {"line_no": 31, "char_start": 1013, "char_end": 1054, "line": "                if date_str != deadline:\n"}, {"line_no": 32, "char_start": 1054, "char_end": 1091, "line": "                    raise ValueError\n"}, {"line_no": 33, "char_start": 1091, "char_end": 1137, "line": "                incorrect_date_format = False\n"}, {"line_no": 34, "char_start": 1137, "char_end": 1168, "line": "            except ValueError:\n"}, {"line_no": 35, "char_start": 1168, "char_end": 1269, "line": "                click.echo(chalk.red(\"Incorrect data format, should be YYYY-MM-DD. Please repeat:\"))\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 73, "char_end": 102, "chars": "goal_name_not_ok = True\n\n    "}, {"char_start": 170, "char_end": 202, "chars": "while goal_name_not_ok:\n        "}, {"char_start": 230, "char_end": 420, "chars": "        if goal_name.isalnum():\n            goal_name_not_ok = False\n        else:\n            click.echo(chalk.red('Only alphanumeric characters can be used! Please input the goal name:'))\n"}, {"char_start": 786, "char_end": 864, "chars": "        incorrect_date_format = True\n        while incorrect_date_format:\n    "}, {"char_start": 897, "char_end": 1267, "chars": ")\n            try:\n                date_str = datetime.datetime.strptime(deadline, '%Y-%m-%d').strftime('%Y-%m-%d')\n                if date_str != deadline:\n                    raise ValueError\n                incorrect_date_format = False\n            except ValueError:\n                click.echo(chalk.red(\"Incorrect data format, should be YYYY-MM-DD. Please repeat:\")"}]}, "commit_link": "github.com/yoda-pa/yoda/commit/263946316041601de75638ee303a892f2652cf40", "file_name": "modules/goals.py", "vul_type": "cwe-022"}
{"func_name": "_inject_admin_password_into_fs", "func_src_before": "def _inject_admin_password_into_fs(admin_passwd, fs, execute=None):\n    \"\"\"Set the root password to admin_passwd\n\n    admin_password is a root password\n    fs is the path to the base of the filesystem into which to inject\n    the key.\n\n    This method modifies the instance filesystem directly,\n    and does not require a guest agent running in the instance.\n\n    \"\"\"\n    # The approach used here is to copy the password and shadow\n    # files from the instance filesystem to local files, make any\n    # necessary changes, and then copy them back.\n\n    admin_user = 'root'\n\n    fd, tmp_passwd = tempfile.mkstemp()\n    os.close(fd)\n    fd, tmp_shadow = tempfile.mkstemp()\n    os.close(fd)\n\n    utils.execute('cp', os.path.join(fs, 'etc', 'passwd'), tmp_passwd,\n                  run_as_root=True)\n    utils.execute('cp', os.path.join(fs, 'etc', 'shadow'), tmp_shadow,\n                  run_as_root=True)\n    _set_passwd(admin_user, admin_passwd, tmp_passwd, tmp_shadow)\n    utils.execute('cp', tmp_passwd, os.path.join(fs, 'etc', 'passwd'),\n                  run_as_root=True)\n    os.unlink(tmp_passwd)\n    utils.execute('cp', tmp_shadow, os.path.join(fs, 'etc', 'shadow'),\n                  run_as_root=True)\n    os.unlink(tmp_shadow)", "func_src_after": "def _inject_admin_password_into_fs(admin_passwd, fs, execute=None):\n    \"\"\"Set the root password to admin_passwd\n\n    admin_password is a root password\n    fs is the path to the base of the filesystem into which to inject\n    the key.\n\n    This method modifies the instance filesystem directly,\n    and does not require a guest agent running in the instance.\n\n    \"\"\"\n    # The approach used here is to copy the password and shadow\n    # files from the instance filesystem to local files, make any\n    # necessary changes, and then copy them back.\n\n    admin_user = 'root'\n\n    fd, tmp_passwd = tempfile.mkstemp()\n    os.close(fd)\n    fd, tmp_shadow = tempfile.mkstemp()\n    os.close(fd)\n\n    passwd_path = _join_and_check_path_within_fs(fs, 'etc', 'passwd')\n    shadow_path = _join_and_check_path_within_fs(fs, 'etc', 'shadow')\n\n    utils.execute('cp', passwd_path, tmp_passwd, run_as_root=True)\n    utils.execute('cp', shadow_path, tmp_shadow, run_as_root=True)\n    _set_passwd(admin_user, admin_passwd, tmp_passwd, tmp_shadow)\n    utils.execute('cp', tmp_passwd, passwd_path, run_as_root=True)\n    os.unlink(tmp_passwd)\n    utils.execute('cp', tmp_shadow, shadow_path, run_as_root=True)\n    os.unlink(tmp_shadow)", "line_changes": {"deleted": [{"line_no": 23, "char_start": 689, "char_end": 760, "line": "    utils.execute('cp', os.path.join(fs, 'etc', 'passwd'), tmp_passwd,\n"}, {"line_no": 24, "char_start": 760, "char_end": 796, "line": "                  run_as_root=True)\n"}, {"line_no": 25, "char_start": 796, "char_end": 867, "line": "    utils.execute('cp', os.path.join(fs, 'etc', 'shadow'), tmp_shadow,\n"}, {"line_no": 26, "char_start": 867, "char_end": 903, "line": "                  run_as_root=True)\n"}, {"line_no": 28, "char_start": 969, "char_end": 1040, "line": "    utils.execute('cp', tmp_passwd, os.path.join(fs, 'etc', 'passwd'),\n"}, {"line_no": 29, "char_start": 1040, "char_end": 1076, "line": "                  run_as_root=True)\n"}, {"line_no": 31, "char_start": 1102, "char_end": 1173, "line": "    utils.execute('cp', tmp_shadow, os.path.join(fs, 'etc', 'shadow'),\n"}, {"line_no": 32, "char_start": 1173, "char_end": 1209, "line": "                  run_as_root=True)\n"}], "added": [{"line_no": 23, "char_start": 689, "char_end": 759, "line": "    passwd_path = _join_and_check_path_within_fs(fs, 'etc', 'passwd')\n"}, {"line_no": 24, "char_start": 759, "char_end": 829, "line": "    shadow_path = _join_and_check_path_within_fs(fs, 'etc', 'shadow')\n"}, {"line_no": 25, "char_start": 829, "char_end": 830, "line": "\n"}, {"line_no": 26, "char_start": 830, "char_end": 897, "line": "    utils.execute('cp', passwd_path, tmp_passwd, run_as_root=True)\n"}, {"line_no": 27, "char_start": 897, "char_end": 964, "line": "    utils.execute('cp', shadow_path, tmp_shadow, run_as_root=True)\n"}, {"line_no": 29, "char_start": 1030, "char_end": 1097, "line": "    utils.execute('cp', tmp_passwd, passwd_path, run_as_root=True)\n"}, {"line_no": 31, "char_start": 1123, "char_end": 1190, "line": "    utils.execute('cp', tmp_shadow, shadow_path, run_as_root=True)\n"}]}, "char_changes": {"deleted": [{"char_start": 693, "char_end": 694, "chars": "u"}, {"char_start": 696, "char_end": 701, "chars": "ls.ex"}, {"char_start": 703, "char_end": 704, "chars": "u"}, {"char_start": 705, "char_end": 706, "chars": "e"}, {"char_start": 711, "char_end": 712, "chars": ","}, {"char_start": 714, "char_end": 716, "chars": "s."}, {"char_start": 720, "char_end": 721, "chars": "."}, {"char_start": 744, "char_end": 746, "chars": "')"}, {"char_start": 759, "char_end": 777, "chars": "\n                 "}, {"char_start": 820, "char_end": 845, "chars": "os.path.join(fs, 'etc', '"}, {"char_start": 851, "char_end": 853, "chars": "')"}, {"char_start": 866, "char_end": 884, "chars": "\n                 "}, {"char_start": 1005, "char_end": 1030, "chars": "os.path.join(fs, 'etc', '"}, {"char_start": 1036, "char_end": 1038, "chars": "')"}, {"char_start": 1039, "char_end": 1057, "chars": "\n                 "}, {"char_start": 1138, "char_end": 1163, "chars": "os.path.join(fs, 'etc', '"}, {"char_start": 1169, "char_end": 1171, "chars": "')"}, {"char_start": 1172, "char_end": 1190, "chars": "\n                 "}], "added": [{"char_start": 693, "char_end": 702, "chars": "passwd_pa"}, {"char_start": 703, "char_end": 710, "chars": "h = _jo"}, {"char_start": 711, "char_end": 719, "chars": "n_and_ch"}, {"char_start": 721, "char_end": 725, "chars": "k_pa"}, {"char_start": 726, "char_end": 737, "chars": "h_within_fs"}, {"char_start": 738, "char_end": 742, "chars": "fs, "}, {"char_start": 743, "char_end": 745, "chars": "et"}, {"char_start": 749, "char_end": 752, "chars": "'pa"}, {"char_start": 753, "char_end": 770, "chars": "swd')\n    shadow_"}, {"char_start": 774, "char_end": 778, "chars": " = _"}, {"char_start": 782, "char_end": 807, "chars": "_and_check_path_within_fs"}, {"char_start": 820, "char_end": 854, "chars": "shadow')\n\n    utils.execute('cp', "}, {"char_start": 860, "char_end": 865, "chars": "_path"}, {"char_start": 927, "char_end": 932, "chars": "_path"}, {"char_start": 1072, "char_end": 1077, "chars": "_path"}, {"char_start": 1165, "char_end": 1170, "chars": "_path"}]}, "commit_link": "github.com/openstack/nova/commit/2427d4a99bed35baefd8f17ba422cb7aae8dcca7", "file_name": "nova/virt/disk/api.py", "vul_type": "cwe-022"}
{"func_name": "get_paths", "func_src_before": "def get_paths(base_path: pathlib.Path):\n    data_file = pathlib.Path(str(base_path) + \".data\")\n    metadata_file = pathlib.Path(str(base_path) + \".meta\")\n\n    return data_file, metadata_file", "func_src_after": "def get_paths(root: str, sub_path: str) \\\n        -> typing.Tuple[pathlib.Path, pathlib.Path]:\n    base_path = flask.safe_join(root, sub_path)\n    data_file = pathlib.Path(base_path + \".data\")\n    metadata_file = pathlib.Path(base_path + \".meta\")\n\n    return data_file, metadata_file", "line_changes": {"deleted": [{"line_no": 1, "char_start": 0, "char_end": 40, "line": "def get_paths(base_path: pathlib.Path):\n"}], "added": [{"line_no": 1, "char_start": 0, "char_end": 42, "line": "def get_paths(root: str, sub_path: str) \\\n"}, {"line_no": 2, "char_start": 42, "char_end": 95, "line": "        -> typing.Tuple[pathlib.Path, pathlib.Path]:\n"}, {"line_no": 3, "char_start": 95, "char_end": 143, "line": "    base_path = flask.safe_join(root, sub_path)\n"}, {"line_no": 4, "char_start": 143, "char_end": 193, "line": "    data_file = pathlib.Path(base_path + \".data\")\n"}, {"line_no": 5, "char_start": 193, "char_end": 247, "line": "    metadata_file = pathlib.Path(base_path + \".meta\")\n"}]}, "char_changes": {"deleted": [{"char_start": 18, "char_end": 19, "chars": "_"}, {"char_start": 23, "char_end": 24, "chars": ":"}, {"char_start": 38, "char_end": 39, "chars": ":"}, {"char_start": 69, "char_end": 73, "chars": "str("}, {"char_start": 82, "char_end": 83, "chars": ")"}, {"char_start": 128, "char_end": 132, "chars": "str("}, {"char_start": 141, "char_end": 142, "chars": ")"}], "added": [{"char_start": 14, "char_end": 27, "chars": "root: str, su"}, {"char_start": 28, "char_end": 30, "chars": "_p"}, {"char_start": 31, "char_end": 35, "chars": "th: "}, {"char_start": 36, "char_end": 64, "chars": "tr) \\\n        -> typing.Tupl"}, {"char_start": 65, "char_end": 66, "chars": "["}, {"char_start": 70, "char_end": 79, "chars": "lib.Path,"}, {"char_start": 92, "char_end": 93, "chars": "]"}, {"char_start": 99, "char_end": 147, "chars": "base_path = flask.safe_join(root, sub_path)\n    "}]}, "commit_link": "github.com/horazont/xmpp-http-upload/commit/82056540191e89f0cd697c81f57714c00962ed75", "file_name": "xhu.py", "vul_type": "cwe-022"}
{"func_name": "compose_path", "func_src_before": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\n\ncheck:\n\twhile ((ptr = strstr(dir, \"//\")))\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\n\t/*\n\t * Handle directories slightly differently, since dirname() on a\n\t * directory returns the parent directory.  So, just squash ..\n\t */\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Check realpath() of directory containing the file, a\n\t\t * STOR may want to save a new file.  Then append the\n\t\t * file and return it.\n\t\t */\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\n\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\n\treturn rpath;\n}", "func_src_after": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\n\ncheck:\n\twhile ((ptr = strstr(dir, \"//\")))\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\n\t/*\n\t * Handle directories slightly differently, since dirname() on a\n\t * directory returns the parent directory.  So, just squash ..\n\t */\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Check realpath() of directory containing the file, a\n\t\t * STOR may want to save a new file.  Then append the\n\t\t * file and return it.\n\t\t */\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\n\tif (!chrooted && strncmp(rpath, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\n\treturn rpath;\n}", "line_changes": {"deleted": [{"line_no": 63, "char_start": 1460, "char_end": 1514, "line": "\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n"}], "added": [{"line_no": 63, "char_start": 1460, "char_end": 1516, "line": "\tif (!chrooted && strncmp(rpath, home, strlen(home))) {\n"}]}, "char_changes": {"deleted": [{"char_start": 1486, "char_end": 1488, "chars": "di"}], "added": [{"char_start": 1487, "char_end": 1491, "chars": "path"}]}, "commit_link": "github.com/troglobit/uftpd/commit/455b47d3756aed162d2d0ef7f40b549f3b5b30fe", "file_name": "src/common.c", "vul_type": "cwe-022"}
{"func_name": "valid_id", "func_src_before": "def valid_id(opts, id_):\n    '''\n    Returns if the passed id is valid\n    '''\n    try:\n        return bool(clean_path(opts['pki_dir'], id_)) and clean_id(id_)\n    except (AttributeError, KeyError, TypeError) as e:\n        return False", "func_src_after": "def valid_id(opts, id_):\n    '''\n    Returns if the passed id is valid\n    '''\n    try:\n        if any(x in id_ for x in ('/', '\\\\', '\\0')):\n            return False\n        return bool(clean_path(opts['pki_dir'], id_))\n    except (AttributeError, KeyError, TypeError):\n        return False", "line_changes": {"deleted": [{"line_no": 6, "char_start": 88, "char_end": 160, "line": "        return bool(clean_path(opts['pki_dir'], id_)) and clean_id(id_)\n"}, {"line_no": 7, "char_start": 160, "char_end": 215, "line": "    except (AttributeError, KeyError, TypeError) as e:\n"}], "added": [{"line_no": 6, "char_start": 88, "char_end": 141, "line": "        if any(x in id_ for x in ('/', '\\\\', '\\0')):\n"}, {"line_no": 7, "char_start": 141, "char_end": 166, "line": "            return False\n"}, {"line_no": 8, "char_start": 166, "char_end": 220, "line": "        return bool(clean_path(opts['pki_dir'], id_))\n"}, {"line_no": 9, "char_start": 220, "char_end": 270, "line": "    except (AttributeError, KeyError, TypeError):\n"}]}, "char_changes": {"deleted": [{"char_start": 141, "char_end": 159, "chars": " and clean_id(id_)"}, {"char_start": 208, "char_end": 213, "chars": " as e"}], "added": [{"char_start": 96, "char_end": 174, "chars": "if any(x in id_ for x in ('/', '\\\\', '\\0')):\n            return False\n        "}]}, "commit_link": "github.com/saltstack/salt/commit/80d90307b07b3703428ecbb7c8bb468e28a9ae6d", "file_name": "salt/utils/verify.py", "vul_type": "cwe-022"}
{"func_name": "get", "func_src_before": "    def get(self, path):\n        return static_file(path, self.get_base_path())", "func_src_after": "    def get(self, path):\n        path = self.sanitize_path(path)\n        base_paths = self.get_base_paths()\n        if hasattr(base_paths, 'split'):\n            # String, so go simple\n            base_path = base_paths\n        else:\n            base_path = self.get_first_base(base_paths, path)\n        return static_file(path, base_path)", "line_changes": {"deleted": [{"line_no": 2, "char_start": 25, "char_end": 79, "line": "        return static_file(path, self.get_base_path())\n"}], "added": [{"line_no": 2, "char_start": 25, "char_end": 65, "line": "        path = self.sanitize_path(path)\n"}, {"line_no": 3, "char_start": 65, "char_end": 108, "line": "        base_paths = self.get_base_paths()\n"}, {"line_no": 4, "char_start": 108, "char_end": 149, "line": "        if hasattr(base_paths, 'split'):\n"}, {"line_no": 6, "char_start": 184, "char_end": 219, "line": "            base_path = base_paths\n"}, {"line_no": 7, "char_start": 219, "char_end": 233, "line": "        else:\n"}, {"line_no": 8, "char_start": 233, "char_end": 295, "line": "            base_path = self.get_first_base(base_paths, path)\n"}, {"line_no": 9, "char_start": 295, "char_end": 338, "line": "        return static_file(path, base_path)\n"}]}, "char_changes": {"deleted": [{"char_start": 36, "char_end": 37, "chars": "u"}, {"char_start": 44, "char_end": 49, "chars": "ic_fi"}, {"char_start": 51, "char_end": 52, "chars": "("}, {"char_start": 56, "char_end": 57, "chars": ","}, {"char_start": 77, "char_end": 78, "chars": ")"}], "added": [{"char_start": 33, "char_end": 76, "chars": "path = self.sanitize_path(path)\n        bas"}, {"char_start": 77, "char_end": 80, "chars": "_pa"}, {"char_start": 81, "char_end": 85, "chars": "hs ="}, {"char_start": 87, "char_end": 93, "chars": "elf.ge"}, {"char_start": 94, "char_end": 101, "chars": "_base_p"}, {"char_start": 103, "char_end": 116, "chars": "hs()\n        "}, {"char_start": 118, "char_end": 143, "chars": " hasattr(base_paths, 'spl"}, {"char_start": 144, "char_end": 181, "chars": "t'):\n            # String, so go simp"}, {"char_start": 183, "char_end": 250, "chars": "\n            base_path = base_paths\n        else:\n            base_"}, {"char_start": 254, "char_end": 256, "chars": " ="}, {"char_start": 266, "char_end": 277, "chars": "first_base("}, {"char_start": 286, "char_end": 293, "chars": "s, path"}, {"char_start": 294, "char_end": 337, "chars": "\n        return static_file(path, base_path"}]}, "commit_link": "github.com/foxbunny/seagull/commit/1fb790712fe0c1d1957b31e34a8e0e6593af87a7", "file_name": "seagull/routes/app.py", "vul_type": "cwe-022"}
{"func_name": "dd_exist", "func_src_before": "int dd_exist(const struct dump_dir *dd, const char *path)\n{\n    char *full_path = concat_path_file(dd->dd_dirname, path);\n    int ret = exist_file_dir(full_path);\n    free(full_path);\n    return ret;\n}", "func_src_after": "int dd_exist(const struct dump_dir *dd, const char *path)\n{\n    if (!str_is_correct_filename(path))\n        error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", path);\n\n    char *full_path = concat_path_file(dd->dd_dirname, path);\n    int ret = exist_file_dir(full_path);\n    free(full_path);\n    return ret;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 3, "char_start": 60, "char_end": 100, "line": "    if (!str_is_correct_filename(path))\n"}, {"line_no": 4, "char_start": 100, "char_end": 189, "line": "        error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", path);\n"}, {"line_no": 5, "char_start": 189, "char_end": 190, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 64, "char_end": 194, "chars": "if (!str_is_correct_filename(path))\n        error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", path);\n\n    "}]}, "commit_link": "github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277", "file_name": "src/lib/dump_dir.c", "vul_type": "cwe-022"}
{"func_name": "is_cgi", "func_src_before": "    def is_cgi(self):\n        \"\"\"Test whether self.path corresponds to a CGI script,\n        and return a boolean.\n\n        This function sets self.cgi_info to a tuple (dir, rest)\n        when it returns True, where dir is the directory part before\n        the CGI script name.  Note that rest begins with a\n        slash if it is not empty.\n\n        The default implementation tests whether the path\n        begins with one of the strings in the list\n        self.cgi_directories (and the next character is a '/'\n        or the end of the string).\n        \"\"\"\n\n        path = self.path\n\n        for x in self.cgi_directories:\n            i = len(x)\n            if path[:i] == x and (not path[i:] or path[i] == '/'):\n                self.cgi_info = path[:i], path[i+1:]\n                return True\n        return False", "func_src_after": "    def is_cgi(self):\n        \"\"\"Test whether self.path corresponds to a CGI script.\n\n        Returns True and updates the cgi_info attribute to the tuple\n        (dir, rest) if self.path requires running a CGI script.\n        Returns False otherwise.\n\n        The default implementation tests whether the normalized url\n        path begins with one of the strings in self.cgi_directories\n        (and the next character is a '/' or the end of the string).\n        \"\"\"\n        splitpath = _url_collapse_path_split(self.path)\n        if splitpath[0] in self.cgi_directories:\n            self.cgi_info = splitpath\n            return True\n        return False", "line_changes": {"deleted": [{"line_no": 2, "char_start": 22, "char_end": 85, "line": "        \"\"\"Test whether self.path corresponds to a CGI script,\n"}, {"line_no": 3, "char_start": 85, "char_end": 115, "line": "        and return a boolean.\n"}, {"line_no": 4, "char_start": 115, "char_end": 116, "line": "\n"}, {"line_no": 5, "char_start": 116, "char_end": 180, "line": "        This function sets self.cgi_info to a tuple (dir, rest)\n"}, {"line_no": 6, "char_start": 180, "char_end": 249, "line": "        when it returns True, where dir is the directory part before\n"}, {"line_no": 7, "char_start": 249, "char_end": 308, "line": "        the CGI script name.  Note that rest begins with a\n"}, {"line_no": 8, "char_start": 308, "char_end": 342, "line": "        slash if it is not empty.\n"}, {"line_no": 9, "char_start": 342, "char_end": 343, "line": "\n"}, {"line_no": 10, "char_start": 343, "char_end": 401, "line": "        The default implementation tests whether the path\n"}, {"line_no": 11, "char_start": 401, "char_end": 452, "line": "        begins with one of the strings in the list\n"}, {"line_no": 12, "char_start": 452, "char_end": 514, "line": "        self.cgi_directories (and the next character is a '/'\n"}, {"line_no": 13, "char_start": 514, "char_end": 549, "line": "        or the end of the string).\n"}, {"line_no": 14, "char_start": 549, "char_end": 561, "line": "        \"\"\"\n"}, {"line_no": 16, "char_start": 562, "char_end": 587, "line": "        path = self.path\n"}, {"line_no": 18, "char_start": 588, "char_end": 627, "line": "        for x in self.cgi_directories:\n"}, {"line_no": 19, "char_start": 627, "char_end": 650, "line": "            i = len(x)\n"}, {"line_no": 20, "char_start": 650, "char_end": 717, "line": "            if path[:i] == x and (not path[i:] or path[i] == '/'):\n"}, {"line_no": 21, "char_start": 717, "char_end": 770, "line": "                self.cgi_info = path[:i], path[i+1:]\n"}, {"line_no": 22, "char_start": 770, "char_end": 798, "line": "                return True\n"}], "added": [{"line_no": 2, "char_start": 22, "char_end": 85, "line": "        \"\"\"Test whether self.path corresponds to a CGI script.\n"}, {"line_no": 4, "char_start": 86, "char_end": 155, "line": "        Returns True and updates the cgi_info attribute to the tuple\n"}, {"line_no": 5, "char_start": 155, "char_end": 219, "line": "        (dir, rest) if self.path requires running a CGI script.\n"}, {"line_no": 6, "char_start": 219, "char_end": 252, "line": "        Returns False otherwise.\n"}, {"line_no": 8, "char_start": 253, "char_end": 321, "line": "        The default implementation tests whether the normalized url\n"}, {"line_no": 9, "char_start": 321, "char_end": 389, "line": "        path begins with one of the strings in self.cgi_directories\n"}, {"line_no": 10, "char_start": 389, "char_end": 457, "line": "        (and the next character is a '/' or the end of the string).\n"}, {"line_no": 11, "char_start": 457, "char_end": 469, "line": "        \"\"\"\n"}, {"line_no": 12, "char_start": 469, "char_end": 525, "line": "        splitpath = _url_collapse_path_split(self.path)\n"}, {"line_no": 13, "char_start": 525, "char_end": 574, "line": "        if splitpath[0] in self.cgi_directories:\n"}, {"line_no": 14, "char_start": 574, "char_end": 612, "line": "            self.cgi_info = splitpath\n"}, {"line_no": 15, "char_start": 612, "char_end": 636, "line": "            return True\n"}]}, "char_changes": {"deleted": [{"char_start": 83, "char_end": 84, "chars": ","}, {"char_start": 93, "char_end": 98, "chars": "and r"}, {"char_start": 104, "char_end": 110, "chars": "a bool"}, {"char_start": 113, "char_end": 120, "chars": ".\n\n    "}, {"char_start": 121, "char_end": 130, "chars": "   This f"}, {"char_start": 131, "char_end": 133, "chars": "nc"}, {"char_start": 134, "char_end": 139, "chars": "ion s"}, {"char_start": 140, "char_end": 141, "chars": "t"}, {"char_start": 143, "char_end": 144, "chars": "s"}, {"char_start": 145, "char_end": 148, "chars": "lf."}, {"char_start": 160, "char_end": 161, "chars": "a"}, {"char_start": 167, "char_end": 179, "chars": " (dir, rest)"}, {"char_start": 188, "char_end": 193, "chars": "when "}, {"char_start": 194, "char_end": 196, "chars": "t "}, {"char_start": 197, "char_end": 208, "chars": "eturns True"}, {"char_start": 210, "char_end": 213, "chars": "whe"}, {"char_start": 215, "char_end": 221, "chars": " dir i"}, {"char_start": 222, "char_end": 223, "chars": " "}, {"char_start": 224, "char_end": 226, "chars": "he"}, {"char_start": 227, "char_end": 228, "chars": "d"}, {"char_start": 229, "char_end": 236, "chars": "rectory"}, {"char_start": 239, "char_end": 240, "chars": "r"}, {"char_start": 242, "char_end": 243, "chars": "b"}, {"char_start": 244, "char_end": 246, "chars": "fo"}, {"char_start": 248, "char_end": 250, "chars": "\n "}, {"char_start": 251, "char_end": 255, "chars": "    "}, {"char_start": 256, "char_end": 260, "chars": " the"}, {"char_start": 271, "char_end": 276, "chars": " name"}, {"char_start": 277, "char_end": 307, "chars": "  Note that rest begins with a"}, {"char_start": 317, "char_end": 318, "chars": "l"}, {"char_start": 320, "char_end": 321, "chars": "h"}, {"char_start": 322, "char_end": 326, "chars": "if i"}, {"char_start": 327, "char_end": 328, "chars": " "}, {"char_start": 330, "char_end": 335, "chars": " not "}, {"char_start": 336, "char_end": 340, "chars": "mpty"}, {"char_start": 396, "char_end": 397, "chars": "p"}, {"char_start": 398, "char_end": 400, "chars": "th"}, {"char_start": 443, "char_end": 460, "chars": "the list\n        "}, {"char_start": 513, "char_end": 521, "chars": "\n       "}, {"char_start": 561, "char_end": 562, "chars": "\n"}, {"char_start": 586, "char_end": 587, "chars": "\n"}, {"char_start": 597, "char_end": 599, "chars": "or"}, {"char_start": 600, "char_end": 601, "chars": "x"}, {"char_start": 639, "char_end": 733, "chars": "i = len(x)\n            if path[:i] == x and (not path[i:] or path[i] == '/'):\n                "}, {"char_start": 750, "char_end": 755, "chars": "ath[:"}, {"char_start": 756, "char_end": 759, "chars": "], "}, {"char_start": 763, "char_end": 769, "chars": "[i+1:]"}, {"char_start": 770, "char_end": 774, "chars": "    "}], "added": [{"char_start": 83, "char_end": 85, "chars": ".\n"}, {"char_start": 94, "char_end": 95, "chars": "R"}, {"char_start": 100, "char_end": 101, "chars": "s"}, {"char_start": 102, "char_end": 106, "chars": "True"}, {"char_start": 109, "char_end": 110, "chars": "d"}, {"char_start": 112, "char_end": 115, "chars": "pda"}, {"char_start": 119, "char_end": 121, "chars": "th"}, {"char_start": 122, "char_end": 123, "chars": " "}, {"char_start": 132, "char_end": 142, "chars": "attribute "}, {"char_start": 145, "char_end": 148, "chars": "the"}, {"char_start": 163, "char_end": 165, "chars": "(d"}, {"char_start": 171, "char_end": 174, "chars": "st)"}, {"char_start": 176, "char_end": 177, "chars": "f"}, {"char_start": 180, "char_end": 183, "chars": "lf."}, {"char_start": 186, "char_end": 187, "chars": "h"}, {"char_start": 188, "char_end": 189, "chars": "r"}, {"char_start": 190, "char_end": 193, "chars": "qui"}, {"char_start": 195, "char_end": 196, "chars": "s"}, {"char_start": 197, "char_end": 204, "chars": "running"}, {"char_start": 205, "char_end": 206, "chars": "a"}, {"char_start": 217, "char_end": 219, "chars": ".\n"}, {"char_start": 220, "char_end": 223, "chars": "   "}, {"char_start": 227, "char_end": 228, "chars": "R"}, {"char_start": 230, "char_end": 232, "chars": "ur"}, {"char_start": 235, "char_end": 236, "chars": "F"}, {"char_start": 239, "char_end": 240, "chars": "e"}, {"char_start": 241, "char_end": 242, "chars": "o"}, {"char_start": 243, "char_end": 247, "chars": "herw"}, {"char_start": 306, "char_end": 310, "chars": "norm"}, {"char_start": 311, "char_end": 320, "chars": "lized url"}, {"char_start": 328, "char_end": 333, "chars": " path"}, {"char_start": 388, "char_end": 396, "chars": "\n       "}, {"char_start": 477, "char_end": 482, "chars": "split"}, {"char_start": 489, "char_end": 514, "chars": "_url_collapse_path_split("}, {"char_start": 523, "char_end": 524, "chars": ")"}, {"char_start": 533, "char_end": 534, "chars": "i"}, {"char_start": 536, "char_end": 548, "chars": "splitpath[0]"}, {"char_start": 602, "char_end": 603, "chars": "s"}, {"char_start": 604, "char_end": 605, "chars": "l"}, {"char_start": 606, "char_end": 607, "chars": "t"}]}, "commit_link": "github.com/Ricky-Wilson/Python/commit/c5abced949e6a4b001d1dee321593e74ecadecfe", "file_name": "Lib/CGIHTTPServer.py", "vul_type": "cwe-022"}
{"func_name": "deleteKey", "func_src_before": "def deleteKey(client):\n\t\"\"\"Deletes the specified key.\n\tReturns an error if the key doesn't exist\n\t\"\"\"\n\tglobal BAD_REQUEST\n\tglobal NOT_FOUND\n\n\tvalidateClient(client)\n\n\tclient_pub_key = loadClientRSAKey(client)\n\ttoken_data = decodeRequestToken(request.data, client_pub_key)\n\n\tif re.search('[^a-zA-Z0-9]', token_data['key']):\n\t\traise FoxlockError(BAD_REQUEST, 'Invalid key requested')\n\n\ttry:\n\t\tos.remove('keys/%s/%s.key' % (client, token_data['key']))\n\texcept FileNotFoundError:\n\t\traise FoxlockError(NOT_FOUND, \"Key '%s' not found\" % token_data['key'])\n\n\treturn \"Key '%s' successfully deleted\" % token_data['key']", "func_src_after": "def deleteKey(client):\n\t\"\"\"Deletes the specified key.\n\tReturns an error if the key doesn't exist\n\t\"\"\"\n\tglobal NOT_FOUND\n\n\tvalidateClient(client)\n\tclient_pub_key = loadClientRSAKey(client)\n\ttoken_data = decodeRequestToken(request.data, client_pub_key)\n\tvalidateKeyName(token_data['key'])\n\n\ttry:\n\t\tos.remove('keys/%s/%s.key' % (client, token_data['key']))\n\texcept FileNotFoundError:\n\t\traise FoxlockError(NOT_FOUND, \"Key '%s' not found\" % token_data['key'])\n\n\treturn \"Key '%s' successfully deleted\" % token_data['key']", "line_changes": {"deleted": [{"line_no": 5, "char_start": 102, "char_end": 122, "line": "\tglobal BAD_REQUEST\n"}, {"line_no": 9, "char_start": 165, "char_end": 166, "line": "\n"}, {"line_no": 12, "char_start": 272, "char_end": 273, "line": "\n"}, {"line_no": 13, "char_start": 273, "char_end": 323, "line": "\tif re.search('[^a-zA-Z0-9]', token_data['key']):\n"}, {"line_no": 14, "char_start": 323, "char_end": 382, "line": "\t\traise FoxlockError(BAD_REQUEST, 'Invalid key requested')\n"}], "added": [{"line_no": 10, "char_start": 251, "char_end": 287, "line": "\tvalidateKeyName(token_data['key'])\n"}]}, "char_changes": {"deleted": [{"char_start": 110, "char_end": 130, "chars": "BAD_REQUEST\n\tglobal "}, {"char_start": 165, "char_end": 166, "chars": "\n"}, {"char_start": 272, "char_end": 273, "chars": "\n"}, {"char_start": 275, "char_end": 278, "chars": "f r"}, {"char_start": 279, "char_end": 281, "chars": ".s"}, {"char_start": 283, "char_end": 286, "chars": "rch"}, {"char_start": 287, "char_end": 303, "chars": "'[^a-zA-Z0-9]', "}, {"char_start": 320, "char_end": 380, "chars": "):\n\t\traise FoxlockError(BAD_REQUEST, 'Invalid key requested'"}], "added": [{"char_start": 120, "char_end": 120, "chars": ""}, {"char_start": 252, "char_end": 255, "chars": "val"}, {"char_start": 256, "char_end": 259, "chars": "dat"}, {"char_start": 260, "char_end": 261, "chars": "K"}, {"char_start": 262, "char_end": 264, "chars": "yN"}, {"char_start": 265, "char_end": 267, "chars": "me"}]}, "commit_link": "github.com/Mimickal/FoxLock/commit/7c665e556987f4e2c1a75e143a1e80ae066ad833", "file_name": "impl.py", "vul_type": "cwe-022"}
{"func_name": "set", "func_src_before": "    def set(self, key, value, replace=False):\n        path = os.path.join(self.namespace, key)\n        try:\n            self.etcd.write(path, value, prevExist=replace)\n        except etcd.EtcdAlreadyExist as err:\n            raise CSStoreExists(str(err))\n        except etcd.EtcdException as err:\n            log_error(\"Error storing key %s: [%r]\" % (key, repr(err)))\n            raise CSStoreError('Error occurred while trying to store key')", "func_src_after": "    def set(self, key, value, replace=False):\n        path = self._absolute_key(key)\n        try:\n            self.etcd.write(path, value, prevExist=replace)\n        except etcd.EtcdAlreadyExist as err:\n            raise CSStoreExists(str(err))\n        except etcd.EtcdException as err:\n            log_error(\"Error storing key %s: [%r]\" % (key, repr(err)))\n            raise CSStoreError('Error occurred while trying to store key')", "line_changes": {"deleted": [{"line_no": 2, "char_start": 46, "char_end": 95, "line": "        path = os.path.join(self.namespace, key)\n"}], "added": [{"line_no": 2, "char_start": 46, "char_end": 85, "line": "        path = self._absolute_key(key)\n"}]}, "char_changes": {"deleted": [{"char_start": 61, "char_end": 74, "chars": "os.path.join("}, {"char_start": 79, "char_end": 80, "chars": "n"}, {"char_start": 81, "char_end": 83, "chars": "me"}, {"char_start": 84, "char_end": 87, "chars": "pac"}, {"char_start": 88, "char_end": 90, "chars": ", "}], "added": [{"char_start": 66, "char_end": 67, "chars": "_"}, {"char_start": 68, "char_end": 74, "chars": "bsolut"}, {"char_start": 75, "char_end": 77, "chars": "_k"}, {"char_start": 78, "char_end": 80, "chars": "y("}]}, "commit_link": "github.com/latchset/custodia/commit/785fc87f38b4811bc4ce43a0a9b2267ee7d500b4", "file_name": "custodia/store/etcdstore.py", "vul_type": "cwe-022"}
{"func_name": "_inject_key_into_fs", "func_src_before": "def _inject_key_into_fs(key, fs, execute=None):\n    \"\"\"Add the given public ssh key to root's authorized_keys.\n\n    key is an ssh key string.\n    fs is the path to the base of the filesystem into which to inject the key.\n    \"\"\"\n    sshdir = os.path.join(fs, 'root', '.ssh')\n    utils.execute('mkdir', '-p', sshdir, run_as_root=True)\n    utils.execute('chown', 'root', sshdir, run_as_root=True)\n    utils.execute('chmod', '700', sshdir, run_as_root=True)\n    keyfile = os.path.join(sshdir, 'authorized_keys')\n    key_data = [\n        '\\n',\n        '# The following ssh key was injected by Nova',\n        '\\n',\n        key.strip(),\n        '\\n',\n    ]\n    utils.execute('tee', '-a', keyfile,\n                  process_input=''.join(key_data), run_as_root=True)", "func_src_after": "def _inject_key_into_fs(key, fs, execute=None):\n    \"\"\"Add the given public ssh key to root's authorized_keys.\n\n    key is an ssh key string.\n    fs is the path to the base of the filesystem into which to inject the key.\n    \"\"\"\n    sshdir = _join_and_check_path_within_fs(fs, 'root', '.ssh')\n    utils.execute('mkdir', '-p', sshdir, run_as_root=True)\n    utils.execute('chown', 'root', sshdir, run_as_root=True)\n    utils.execute('chmod', '700', sshdir, run_as_root=True)\n\n    keyfile = os.path.join('root', '.ssh', 'authorized_keys')\n\n    key_data = ''.join([\n        '\\n',\n        '# The following ssh key was injected by Nova',\n        '\\n',\n        key.strip(),\n        '\\n',\n    ])\n\n    _inject_file_into_fs(fs, keyfile, key_data, append=True)", "line_changes": {"deleted": [{"line_no": 7, "char_start": 229, "char_end": 275, "line": "    sshdir = os.path.join(fs, 'root', '.ssh')\n"}, {"line_no": 11, "char_start": 455, "char_end": 509, "line": "    keyfile = os.path.join(sshdir, 'authorized_keys')\n"}, {"line_no": 12, "char_start": 509, "char_end": 526, "line": "    key_data = [\n"}, {"line_no": 18, "char_start": 645, "char_end": 651, "line": "    ]\n"}, {"line_no": 19, "char_start": 651, "char_end": 691, "line": "    utils.execute('tee', '-a', keyfile,\n"}, {"line_no": 20, "char_start": 691, "char_end": 759, "line": "                  process_input=''.join(key_data), run_as_root=True)\n"}], "added": [{"line_no": 7, "char_start": 229, "char_end": 293, "line": "    sshdir = _join_and_check_path_within_fs(fs, 'root', '.ssh')\n"}, {"line_no": 11, "char_start": 473, "char_end": 474, "line": "\n"}, {"line_no": 12, "char_start": 474, "char_end": 536, "line": "    keyfile = os.path.join('root', '.ssh', 'authorized_keys')\n"}, {"line_no": 13, "char_start": 536, "char_end": 537, "line": "\n"}, {"line_no": 14, "char_start": 537, "char_end": 562, "line": "    key_data = ''.join([\n"}, {"line_no": 20, "char_start": 681, "char_end": 688, "line": "    ])\n"}, {"line_no": 21, "char_start": 688, "char_end": 689, "line": "\n"}, {"line_no": 22, "char_start": 689, "char_end": 749, "line": "    _inject_file_into_fs(fs, keyfile, key_data, append=True)\n"}]}, "char_changes": {"deleted": [{"char_start": 243, "char_end": 245, "chars": "s."}, {"char_start": 249, "char_end": 252, "chars": ".jo"}, {"char_start": 485, "char_end": 488, "chars": "dir"}, {"char_start": 655, "char_end": 656, "chars": "u"}, {"char_start": 659, "char_end": 663, "chars": "s.ex"}, {"char_start": 664, "char_end": 666, "chars": "cu"}, {"char_start": 667, "char_end": 668, "chars": "e"}, {"char_start": 669, "char_end": 680, "chars": "'tee', '-a'"}, {"char_start": 690, "char_end": 699, "chars": "\n        "}, {"char_start": 700, "char_end": 731, "chars": "         process_input=''.join("}, {"char_start": 739, "char_end": 740, "chars": ")"}, {"char_start": 742, "char_end": 744, "chars": "ru"}, {"char_start": 745, "char_end": 753, "chars": "_as_root"}], "added": [{"char_start": 242, "char_end": 244, "chars": "_j"}, {"char_start": 245, "char_end": 258, "chars": "in_and_check_"}, {"char_start": 262, "char_end": 267, "chars": "_with"}, {"char_start": 269, "char_end": 272, "chars": "_fs"}, {"char_start": 473, "char_end": 474, "chars": "\n"}, {"char_start": 501, "char_end": 511, "chars": "'root', '."}, {"char_start": 514, "char_end": 515, "chars": "'"}, {"char_start": 536, "char_end": 537, "chars": "\n"}, {"char_start": 552, "char_end": 560, "chars": "''.join("}, {"char_start": 686, "char_end": 688, "chars": ")\n"}, {"char_start": 693, "char_end": 694, "chars": "_"}, {"char_start": 695, "char_end": 697, "chars": "nj"}, {"char_start": 700, "char_end": 704, "chars": "_fil"}, {"char_start": 705, "char_end": 708, "chars": "_in"}, {"char_start": 709, "char_end": 716, "chars": "o_fs(fs"}, {"char_start": 738, "char_end": 743, "chars": "ppend"}]}, "commit_link": "github.com/openstack/nova/commit/2427d4a99bed35baefd8f17ba422cb7aae8dcca7", "file_name": "nova/virt/disk/api.py", "vul_type": "cwe-022"}
