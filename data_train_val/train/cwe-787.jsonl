{"func_name": "rfbHandleAuthResult", "func_src_before": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        /* we have an error following */\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}", "func_src_after": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        /* we have an error following */\n        ReadReason(client);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}", "line_changes": {"deleted": [{"line_no": 3, "char_start": 41, "char_end": 81, "line": "    uint32_t authResult=0, reasonLen=0;\n"}, {"line_no": 4, "char_start": 81, "char_end": 104, "line": "    char *reason=NULL;\n"}, {"line_no": 19, "char_start": 489, "char_end": 566, "line": "        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n"}, {"line_no": 20, "char_start": 566, "char_end": 618, "line": "        reasonLen = rfbClientSwap32IfLE(reasonLen);\n"}, {"line_no": 21, "char_start": 618, "char_end": 666, "line": "        reason = malloc((uint64_t)reasonLen+1);\n"}, {"line_no": 22, "char_start": 666, "char_end": 757, "line": "        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n"}, {"line_no": 23, "char_start": 757, "char_end": 786, "line": "        reason[reasonLen]=0;\n"}, {"line_no": 24, "char_start": 786, "char_end": 846, "line": "        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n"}, {"line_no": 25, "char_start": 846, "char_end": 868, "line": "        free(reason);\n"}], "added": [{"line_no": 3, "char_start": 41, "char_end": 68, "line": "    uint32_t authResult=0;\n"}, {"line_no": 18, "char_start": 453, "char_end": 481, "line": "        ReadReason(client);\n"}]}, "char_changes": {"deleted": [{"char_start": 66, "char_end": 102, "chars": ", reasonLen=0;\n    char *reason=NULL"}, {"char_start": 497, "char_end": 502, "chars": "if (!"}, {"char_start": 506, "char_end": 510, "chars": "From"}, {"char_start": 511, "char_end": 538, "chars": "FBServer(client, (char *)&r"}, {"char_start": 543, "char_end": 696, "chars": "Len, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer"}, {"char_start": 703, "char_end": 865, "chars": ", reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason"}], "added": [{"char_start": 68, "char_end": 68, "chars": ""}]}, "commit_link": "github.com/LibVNC/libvncserver/commit/e34bcbb759ca5bef85809967a268fdf214c1ad2c", "file_name": "libvncclient/rfbproto.c", "vul_type": "cwe-787"}
{"func_name": "jbig2_image_compose", "func_src_before": "jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)\n{\n    uint32_t w, h;\n    uint32_t shift;\n    uint32_t leftbyte;\n    uint8_t *ss;\n    uint8_t *dd;\n    uint8_t leftmask, rightmask;\n    int early = x >= 0;\n    int late;\n    uint32_t bytewidth;\n    uint32_t syoffset = 0;\n\n    if (src == NULL)\n        return 0;\n\n    /* This code takes a src image and combines it onto dst at offset (x,y), with operation op. */\n\n    /* Data is packed msb first within a byte, so with bits numbered: 01234567.\n     * Second byte is: 89abcdef. So to combine into a run, we use:\n     *       (s[0]<<8) | s[1] == 0123456789abcdef.\n     * To read from src into dst at offset 3, we need to read:\n     *    read:      0123456789abcdef...\n     *    write:  0123456798abcdef...\n     * In general, to read from src and write into dst at offset x, we need to shift\n     * down by (x&7) bits to allow for bit alignment. So shift = x&7.\n     * So the 'central' part of our runs will see us doing:\n     *   *d++ op= ((s[0]<<8)|s[1])>>shift;\n     * with special cases on the left and right edges of the run to mask.\n     * With the left hand edge, we have to be careful not to 'underread' the start of\n     * the src image; this is what the early flag is about. Similarly we have to be\n     * careful not to read off the right hand edge; this is what the late flag is for.\n     */\n\n    /* clip */\n    w = src->width;\n    h = src->height;\n    shift = (x & 7);\n    ss = src->data - early;\n\n    if (x < 0) {\n        if (w < (uint32_t) -x)\n            w = 0;\n        else\n            w += x;\n        ss += (-x-1)>>3;\n        x = 0;\n    }\n    if (y < 0) {\n        if (h < (uint32_t) -y)\n            h = 0;\n        else\n            h += y;\n        syoffset = -y * src->stride;\n        y = 0;\n    }\n    if ((uint32_t)x + w > dst->width)\n    {\n        if (dst->width < (uint32_t)x)\n            w = 0;\n        else\n            w = dst->width - x;\n    }\n    if ((uint32_t)y + h > dst->height)\n    {\n        if (dst->height < (uint32_t)y)\n            h = 0;\n        else\n            h = dst->height - y;\n    }\n#ifdef JBIG2_DEBUG\n    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"compositing %dx%d at (%d, %d) after clipping\", w, h, x, y);\n#endif\n\n    /* check for zero clipping region */\n    if ((w <= 0) || (h <= 0)) {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"zero clipping region\");\n#endif\n        return 0;\n    }\n\n    leftbyte = (uint32_t) x >> 3;\n    dd = dst->data + y * dst->stride + leftbyte;\n    bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;\n    leftmask = 255>>(x&7);\n    rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));\n    if (bytewidth == 1)\n        leftmask &= rightmask;\n    late = (ss + bytewidth >= src->data + ((src->width+7)>>3));\n    ss += syoffset;\n\n    switch(op)\n    {\n    case JBIG2_COMPOSE_OR:\n        jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_AND:\n        jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XOR:\n        jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XNOR:\n        jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_REPLACE:\n        jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    }\n\n    return 0;\n}", "func_src_after": "jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)\n{\n    uint32_t w, h;\n    uint32_t shift;\n    uint32_t leftbyte;\n    uint8_t *ss;\n    uint8_t *dd;\n    uint8_t leftmask, rightmask;\n    int early = x >= 0;\n    int late;\n    uint32_t bytewidth;\n    uint32_t syoffset = 0;\n\n    if (src == NULL)\n        return 0;\n\n    if ((UINT32_MAX - src->width  < (x > 0 ? x : -x)) ||\n        (UINT32_MAX - src->height < (y > 0 ? y : -y)))\n    {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"overflow in compose_image\");\n#endif\n        return 0;\n    }\n\n    /* This code takes a src image and combines it onto dst at offset (x,y), with operation op. */\n\n    /* Data is packed msb first within a byte, so with bits numbered: 01234567.\n     * Second byte is: 89abcdef. So to combine into a run, we use:\n     *       (s[0]<<8) | s[1] == 0123456789abcdef.\n     * To read from src into dst at offset 3, we need to read:\n     *    read:      0123456789abcdef...\n     *    write:  0123456798abcdef...\n     * In general, to read from src and write into dst at offset x, we need to shift\n     * down by (x&7) bits to allow for bit alignment. So shift = x&7.\n     * So the 'central' part of our runs will see us doing:\n     *   *d++ op= ((s[0]<<8)|s[1])>>shift;\n     * with special cases on the left and right edges of the run to mask.\n     * With the left hand edge, we have to be careful not to 'underread' the start of\n     * the src image; this is what the early flag is about. Similarly we have to be\n     * careful not to read off the right hand edge; this is what the late flag is for.\n     */\n\n    /* clip */\n    w = src->width;\n    h = src->height;\n    shift = (x & 7);\n    ss = src->data - early;\n\n    if (x < 0) {\n        if (w < (uint32_t) -x)\n            w = 0;\n        else\n            w += x;\n        ss += (-x-1)>>3;\n        x = 0;\n    }\n    if (y < 0) {\n        if (h < (uint32_t) -y)\n            h = 0;\n        else\n            h += y;\n        syoffset = -y * src->stride;\n        y = 0;\n    }\n    if ((uint32_t)x + w > dst->width)\n    {\n        if (dst->width < (uint32_t)x)\n            w = 0;\n        else\n            w = dst->width - x;\n    }\n    if ((uint32_t)y + h > dst->height)\n    {\n        if (dst->height < (uint32_t)y)\n            h = 0;\n        else\n            h = dst->height - y;\n    }\n#ifdef JBIG2_DEBUG\n    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"compositing %dx%d at (%d, %d) after clipping\", w, h, x, y);\n#endif\n\n    /* check for zero clipping region */\n    if ((w <= 0) || (h <= 0)) {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"zero clipping region\");\n#endif\n        return 0;\n    }\n\n    leftbyte = (uint32_t) x >> 3;\n    dd = dst->data + y * dst->stride + leftbyte;\n    bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;\n    leftmask = 255>>(x&7);\n    rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));\n    if (bytewidth == 1)\n        leftmask &= rightmask;\n    late = (ss + bytewidth >= src->data + ((src->width+7)>>3));\n    ss += syoffset;\n\n    switch(op)\n    {\n    case JBIG2_COMPOSE_OR:\n        jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_AND:\n        jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XOR:\n        jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XNOR:\n        jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_REPLACE:\n        jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    }\n\n    return 0;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 17, "char_start": 363, "char_end": 420, "line": "    if ((UINT32_MAX - src->width  < (x > 0 ? x : -x)) ||\n"}, {"line_no": 18, "char_start": 420, "char_end": 475, "line": "        (UINT32_MAX - src->height < (y > 0 ? y : -y)))\n"}, {"line_no": 19, "char_start": 475, "char_end": 481, "line": "    {\n"}, {"line_no": 21, "char_start": 500, "char_end": 581, "line": "        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"overflow in compose_image\");\n"}, {"line_no": 23, "char_start": 588, "char_end": 606, "line": "        return 0;\n"}, {"line_no": 24, "char_start": 606, "char_end": 612, "line": "    }\n"}, {"line_no": 25, "char_start": 612, "char_end": 613, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 367, "char_end": 617, "chars": "if ((UINT32_MAX - src->width  < (x > 0 ? x : -x)) ||\n        (UINT32_MAX - src->height < (y > 0 ? y : -y)))\n    {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"overflow in compose_image\");\n#endif\n        return 0;\n    }\n\n    "}]}, "commit_link": "github.com/ArtifexSoftware/jbig2dec/commit/0726320a4b55078e9d8deb590e477d598b3da66e", "file_name": "jbig2_image.c", "vul_type": "cwe-787"}
{"func_name": "next_state_class", "func_src_before": "next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n\n  *state = CCS_VALUE;\n  *type  = CCV_CLASS;\n  return 0;\n}", "func_src_after": "next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n\n  if (*state != CCS_START)\n    *state = CCS_VALUE;\n\n  *type  = CCV_CLASS;\n  return 0;\n}", "line_changes": {"deleted": [{"line_no": 18, "char_start": 456, "char_end": 478, "line": "  *state = CCS_VALUE;\n"}], "added": [{"line_no": 18, "char_start": 456, "char_end": 483, "line": "  if (*state != CCS_START)\n"}, {"line_no": 19, "char_start": 483, "char_end": 507, "line": "    *state = CCS_VALUE;\n"}, {"line_no": 20, "char_start": 507, "char_end": 508, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 458, "char_end": 487, "chars": "if (*state != CCS_START)\n    "}, {"char_start": 506, "char_end": 507, "chars": "\n"}]}, "commit_link": "github.com/kkos/oniguruma/commit/3b63d12038c8d8fc278e81c942fa9bec7c704c8b", "file_name": "src/regparse.c", "vul_type": "cwe-787"}
{"func_name": "mpol_parse_str", "func_src_before": "int mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\n\tif (flags)\n\t\t*flags++ = '\\0';\t/* terminate mode string */\n\n\tif (nodelist) {\n\t\t/* NUL-terminate mode or flags string */\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * Insist on a nodelist of one node only\n\t\t */\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\t/*\n\t\t * Default to online nodes with memory if no nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\t/*\n\t\t * Don't allow a nodelist;  mpol_new() checks flags\n\t\t */\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\t/*\n\t\t * Insist on a empty nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\t/*\n\t\t * Insist on a nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\n\tmode_flags = 0;\n\tif (flags) {\n\t\t/*\n\t\t * Currently, we only support two mutually exclusive\n\t\t * mode flags.\n\t\t */\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\n\t/*\n\t * Save nodes for mpol_to_str() to show the tmpfs mount options\n\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.\n\t */\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\n\t/*\n\t * Save nodes for contextualization: this will be used to \"clone\"\n\t * the mempolicy in a specific context [cpuset] at a later time.\n\t */\n\tnew->w.user_nodemask = nodes;\n\n\terr = 0;\n\nout:\n\t/* Restore string for error message */\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}", "func_src_after": "int mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\n\tif (flags)\n\t\t*flags++ = '\\0';\t/* terminate mode string */\n\n\tif (nodelist) {\n\t\t/* NUL-terminate mode or flags string */\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * Insist on a nodelist of one node only, although later\n\t\t * we use first_node(nodes) to grab a single node, so here\n\t\t * nodelist (or nodes) cannot be empty.\n\t\t */\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t\tif (nodes_empty(nodes))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\t/*\n\t\t * Default to online nodes with memory if no nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\t/*\n\t\t * Don't allow a nodelist;  mpol_new() checks flags\n\t\t */\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\t/*\n\t\t * Insist on a empty nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\t/*\n\t\t * Insist on a nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\n\tmode_flags = 0;\n\tif (flags) {\n\t\t/*\n\t\t * Currently, we only support two mutually exclusive\n\t\t * mode flags.\n\t\t */\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\n\t/*\n\t * Save nodes for mpol_to_str() to show the tmpfs mount options\n\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.\n\t */\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\n\t/*\n\t * Save nodes for contextualization: this will be used to \"clone\"\n\t * the mempolicy in a specific context [cpuset] at a later time.\n\t */\n\tnew->w.user_nodemask = nodes;\n\n\terr = 0;\n\nout:\n\t/* Restore string for error message */\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}", "line_changes": {"deleted": [{"line_no": 30, "char_start": 637, "char_end": 680, "line": "\t\t * Insist on a nodelist of one node only\n"}], "added": [{"line_no": 30, "char_start": 637, "char_end": 696, "line": "\t\t * Insist on a nodelist of one node only, although later\n"}, {"line_no": 31, "char_start": 696, "char_end": 757, "line": "\t\t * we use first_node(nodes) to grab a single node, so here\n"}, {"line_no": 32, "char_start": 757, "char_end": 799, "line": "\t\t * nodelist (or nodes) cannot be empty.\n"}, {"line_no": 40, "char_start": 915, "char_end": 942, "line": "\t\t\tif (nodes_empty(nodes))\n"}, {"line_no": 41, "char_start": 942, "char_end": 956, "line": "\t\t\t\tgoto out;\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 679, "char_end": 798, "chars": ", although later\n\t\t * we use first_node(nodes) to grab a single node, so here\n\t\t * nodelist (or nodes) cannot be empty."}, {"char_start": 899, "char_end": 940, "chars": ")\n\t\t\t\tgoto out;\n\t\t\tif (nodes_empty(nodes)"}]}, "commit_link": "github.com/torvalds/linux/commit/aa9f7d5172fac9bf1f09e678c35e287a40a7b7dd", "file_name": "mm/mempolicy.c", "vul_type": "cwe-787"}
{"func_name": "keycompare_mb", "func_src_before": "keycompare_mb (const struct line *a, const struct line *b)\n{\n  struct keyfield *key = keylist;\n\n  /* For the first iteration only, the key positions have been\n     precomputed for us. */\n  char *texta = a->keybeg;\n  char *textb = b->keybeg;\n  char *lima = a->keylim;\n  char *limb = b->keylim;\n\n  size_t mblength_a, mblength_b;\n  wchar_t wc_a, wc_b;\n  mbstate_t state_a, state_b;\n\n  int diff = 0;\n\n  memset (&state_a, '\\0', sizeof(mbstate_t));\n  memset (&state_b, '\\0', sizeof(mbstate_t));\n  /* Ignore keys with start after end.  */\n  if (a->keybeg - a->keylim > 0)\n    return 0;\n\n\n              /* Ignore and/or translate chars before comparing.  */\n# define IGNORE_CHARS(NEW_LEN, LEN, TEXT, COPY, WC, MBLENGTH, STATE)        \\\n  do                                                                        \\\n    {                                                                        \\\n      wchar_t uwc;                                                        \\\n      char mbc[MB_LEN_MAX];                                                \\\n      mbstate_t state_wc;                                                \\\n                                                                        \\\n      for (NEW_LEN = i = 0; i < LEN;)                                        \\\n        {                                                                \\\n          mbstate_t state_bak;                                                \\\n                                                                        \\\n          state_bak = STATE;                                                \\\n          MBLENGTH = mbrtowc (&WC, TEXT + i, LEN - i, &STATE);                \\\n                                                                        \\\n          if (MBLENGTH == (size_t)-2 || MBLENGTH == (size_t)-1                \\\n              || MBLENGTH == 0)                                                \\\n            {                                                                \\\n              if (MBLENGTH == (size_t)-2 || MBLENGTH == (size_t)-1)        \\\n                STATE = state_bak;                                        \\\n              if (!ignore)                                                \\\n                COPY[NEW_LEN++] = TEXT[i];                                \\\n              i++;                                                         \\\n              continue;                                                        \\\n            }                                                                \\\n                                                                        \\\n          if (ignore)                                                        \\\n            {                                                                \\\n              if ((ignore == nonprinting && !iswprint (WC))                \\\n                   || (ignore == nondictionary                                \\\n                       && !iswalnum (WC) && !iswblank (WC)))                \\\n                {                                                        \\\n                  i += MBLENGTH;                                        \\\n                  continue;                                                \\\n                }                                                        \\\n            }                                                                \\\n                                                                        \\\n          if (translate)                                                \\\n            {                                                                \\\n                                                                        \\\n              uwc = towupper(WC);                                        \\\n              if (WC == uwc)                                                \\\n                {                                                        \\\n                  memcpy (mbc, TEXT + i, MBLENGTH);                        \\\n                  i += MBLENGTH;                                        \\\n                }                                                        \\\n              else                                                        \\\n                {                                                        \\\n                  i += MBLENGTH;                                        \\\n                  WC = uwc;                                                \\\n                  memset (&state_wc, '\\0', sizeof (mbstate_t));                \\\n                                                                        \\\n                  MBLENGTH = wcrtomb (mbc, WC, &state_wc);                \\\n                  assert (MBLENGTH != (size_t)-1 && MBLENGTH != 0);        \\\n                }                                                        \\\n                                                                        \\\n              for (j = 0; j < MBLENGTH; j++)                                \\\n                COPY[NEW_LEN++] = mbc[j];                                \\\n            }                                                                \\\n          else                                                                \\\n            for (j = 0; j < MBLENGTH; j++)                                \\\n              COPY[NEW_LEN++] = TEXT[i++];                                \\\n        }                                                                \\\n      COPY[NEW_LEN] = '\\0';                                                \\\n    }                                                                        \\\n  while (0)\n\n      /* Actually compare the fields. */\n\n  for (;;)\n    {\n      /* Find the lengths. */\n      size_t lena = lima <= texta ? 0 : lima - texta;\n      size_t lenb = limb <= textb ? 0 : limb - textb;\n\n      char enda IF_LINT (= 0);\n      char endb IF_LINT (= 0);\n\n      char const *translate = key->translate;\n      bool const *ignore = key->ignore;\n\n      if (ignore || translate)\n        {\n          char *copy_a = (char *) xmalloc (lena + 1 + lenb + 1);\n          char *copy_b = copy_a + lena + 1;\n          size_t new_len_a, new_len_b;\n          size_t i, j;\n\n          IGNORE_CHARS (new_len_a, lena, texta, copy_a,\n                        wc_a, mblength_a, state_a);\n          IGNORE_CHARS (new_len_b, lenb, textb, copy_b,\n                        wc_b, mblength_b, state_b);\n          texta = copy_a; textb = copy_b;\n          lena = new_len_a; lenb = new_len_b;\n        }\n      else\n        {\n          /* Use the keys in-place, temporarily null-terminated.  */\n          enda = texta[lena]; texta[lena] = '\\0';\n          endb = textb[lenb]; textb[lenb] = '\\0';\n        }\n\n      if (key->random)\n        diff = compare_random (texta, lena, textb, lenb);\n      else if (key->numeric | key->general_numeric | key->human_numeric)\n        {\n          char savea = *lima, saveb = *limb;\n\n          *lima = *limb = '\\0';\n          diff = (key->numeric ? numcompare (texta, textb)\n                  : key->general_numeric ? general_numcompare (texta, textb)\n                  : human_numcompare (texta, textb));\n          *lima = savea, *limb = saveb;\n        }\n      else if (key->version)\n        diff = filevercmp (texta, textb);\n      else if (key->month)\n        diff = getmonth (texta, lena, NULL) - getmonth (textb, lenb, NULL);\n      else if (lena == 0)\n        diff = - NONZERO (lenb);\n      else if (lenb == 0)\n        diff = 1;\n      else if (hard_LC_COLLATE && !folding)\n        {\n          diff = xmemcoll0 (texta, lena + 1, textb, lenb + 1);\n        }\n      else\n        {\n          diff = memcmp (texta, textb, MIN (lena, lenb));\n          if (diff == 0)\n            diff = lena < lenb ? -1 : lena != lenb;\n        }\n\n      if (ignore || translate)\n        free (texta);\n      else\n        {\n          texta[lena] = enda;\n          textb[lenb] = endb;\n        }\n\n      if (diff)\n        goto not_equal;\n\n      key = key->next;\n      if (! key)\n        break;\n\n      /* Find the beginning and limit of the next field.  */\n      if (key->eword != -1)\n        lima = limfield (a, key), limb = limfield (b, key);\n      else\n        lima = a->text + a->length - 1, limb = b->text + b->length - 1;\n\n      if (key->sword != -1)\n        texta = begfield (a, key), textb = begfield (b, key);\n      else\n        {\n          texta = a->text, textb = b->text;\n          if (key->skipsblanks)\n            {\n              while (texta < lima && ismbblank (texta, lima - texta, &mblength_a))\n                texta += mblength_a;\n              while (textb < limb && ismbblank (textb, limb - textb, &mblength_b))\n                textb += mblength_b;\n            }\n        }\n    }\n\nnot_equal:\n  if (key && key->reverse)\n    return -diff;\n  else\n    return diff;\n}", "func_src_after": "keycompare_mb (const struct line *a, const struct line *b)\n{\n  struct keyfield *key = keylist;\n\n  /* For the first iteration only, the key positions have been\n     precomputed for us. */\n  char *texta = a->keybeg;\n  char *textb = b->keybeg;\n  char *lima = a->keylim;\n  char *limb = b->keylim;\n\n  size_t mblength_a, mblength_b;\n  wchar_t wc_a, wc_b;\n  mbstate_t state_a, state_b;\n\n  int diff = 0;\n\n  memset (&state_a, '\\0', sizeof(mbstate_t));\n  memset (&state_b, '\\0', sizeof(mbstate_t));\n  /* Ignore keys with start after end.  */\n  if (a->keybeg - a->keylim > 0)\n    return 0;\n\n\n              /* Ignore and/or translate chars before comparing.  */\n# define IGNORE_CHARS(NEW_LEN, LEN, TEXT, COPY, WC, MBLENGTH, STATE)        \\\n  do                                                                        \\\n    {                                                                        \\\n      wchar_t uwc;                                                        \\\n      char mbc[MB_LEN_MAX];                                                \\\n      mbstate_t state_wc;                                                \\\n                                                                        \\\n      for (NEW_LEN = i = 0; i < LEN;)                                        \\\n        {                                                                \\\n          mbstate_t state_bak;                                                \\\n                                                                        \\\n          state_bak = STATE;                                                \\\n          MBLENGTH = mbrtowc (&WC, TEXT + i, LEN - i, &STATE);                \\\n                                                                        \\\n          if (MBLENGTH == (size_t)-2 || MBLENGTH == (size_t)-1                \\\n              || MBLENGTH == 0)                                                \\\n            {                                                                \\\n              if (MBLENGTH == (size_t)-2 || MBLENGTH == (size_t)-1)        \\\n                STATE = state_bak;                                        \\\n              if (!ignore)                                                \\\n                COPY[NEW_LEN++] = TEXT[i];                                \\\n              i++;                                                         \\\n              continue;                                                        \\\n            }                                                                \\\n                                                                        \\\n          if (ignore)                                                        \\\n            {                                                                \\\n              if ((ignore == nonprinting && !iswprint (WC))                \\\n                   || (ignore == nondictionary                                \\\n                       && !iswalnum (WC) && !iswblank (WC)))                \\\n                {                                                        \\\n                  i += MBLENGTH;                                        \\\n                  continue;                                                \\\n                }                                                        \\\n            }                                                                \\\n                                                                        \\\n          if (translate)                                                \\\n            {                                                                \\\n                                                                        \\\n              uwc = towupper(WC);                                        \\\n              if (WC == uwc)                                                \\\n                {                                                        \\\n                  memcpy (mbc, TEXT + i, MBLENGTH);                        \\\n                  i += MBLENGTH;                                        \\\n                }                                                        \\\n              else                                                        \\\n                {                                                        \\\n                  i += MBLENGTH;                                        \\\n                  WC = uwc;                                                \\\n                  memset (&state_wc, '\\0', sizeof (mbstate_t));                \\\n                                                                        \\\n                  MBLENGTH = wcrtomb (mbc, WC, &state_wc);                \\\n                  assert (MBLENGTH != (size_t)-1 && MBLENGTH != 0);        \\\n                }                                                        \\\n                                                                        \\\n              for (j = 0; j < MBLENGTH; j++)                                \\\n                COPY[NEW_LEN++] = mbc[j];                                \\\n            }                                                                \\\n          else                                                                \\\n            for (j = 0; j < MBLENGTH; j++)                                \\\n              COPY[NEW_LEN++] = TEXT[i++];                                \\\n        }                                                                \\\n      COPY[NEW_LEN] = '\\0';                                                \\\n    }                                                                        \\\n  while (0)\n\n      /* Actually compare the fields. */\n\n  for (;;)\n    {\n      /* Find the lengths. */\n      size_t lena = lima <= texta ? 0 : lima - texta;\n      size_t lenb = limb <= textb ? 0 : limb - textb;\n\n      char enda IF_LINT (= 0);\n      char endb IF_LINT (= 0);\n\n      char const *translate = key->translate;\n      bool const *ignore = key->ignore;\n\n      if (ignore || translate)\n        {\n          if (SIZE_MAX - lenb - 2 < lena)\n            xalloc_die ();\n          char *copy_a = (char *) xnmalloc (lena + lenb + 2, MB_CUR_MAX);\n          char *copy_b = copy_a + lena * MB_CUR_MAX + 1;\n          size_t new_len_a, new_len_b;\n          size_t i, j;\n\n          IGNORE_CHARS (new_len_a, lena, texta, copy_a,\n                        wc_a, mblength_a, state_a);\n          IGNORE_CHARS (new_len_b, lenb, textb, copy_b,\n                        wc_b, mblength_b, state_b);\n          texta = copy_a; textb = copy_b;\n          lena = new_len_a; lenb = new_len_b;\n        }\n      else\n        {\n          /* Use the keys in-place, temporarily null-terminated.  */\n          enda = texta[lena]; texta[lena] = '\\0';\n          endb = textb[lenb]; textb[lenb] = '\\0';\n        }\n\n      if (key->random)\n        diff = compare_random (texta, lena, textb, lenb);\n      else if (key->numeric | key->general_numeric | key->human_numeric)\n        {\n          char savea = *lima, saveb = *limb;\n\n          *lima = *limb = '\\0';\n          diff = (key->numeric ? numcompare (texta, textb)\n                  : key->general_numeric ? general_numcompare (texta, textb)\n                  : human_numcompare (texta, textb));\n          *lima = savea, *limb = saveb;\n        }\n      else if (key->version)\n        diff = filevercmp (texta, textb);\n      else if (key->month)\n        diff = getmonth (texta, lena, NULL) - getmonth (textb, lenb, NULL);\n      else if (lena == 0)\n        diff = - NONZERO (lenb);\n      else if (lenb == 0)\n        diff = 1;\n      else if (hard_LC_COLLATE && !folding)\n        {\n          diff = xmemcoll0 (texta, lena + 1, textb, lenb + 1);\n        }\n      else\n        {\n          diff = memcmp (texta, textb, MIN (lena, lenb));\n          if (diff == 0)\n            diff = lena < lenb ? -1 : lena != lenb;\n        }\n\n      if (ignore || translate)\n        free (texta);\n      else\n        {\n          texta[lena] = enda;\n          textb[lenb] = endb;\n        }\n\n      if (diff)\n        goto not_equal;\n\n      key = key->next;\n      if (! key)\n        break;\n\n      /* Find the beginning and limit of the next field.  */\n      if (key->eword != -1)\n        lima = limfield (a, key), limb = limfield (b, key);\n      else\n        lima = a->text + a->length - 1, limb = b->text + b->length - 1;\n\n      if (key->sword != -1)\n        texta = begfield (a, key), textb = begfield (b, key);\n      else\n        {\n          texta = a->text, textb = b->text;\n          if (key->skipsblanks)\n            {\n              while (texta < lima && ismbblank (texta, lima - texta, &mblength_a))\n                texta += mblength_a;\n              while (textb < limb && ismbblank (textb, limb - textb, &mblength_b))\n                textb += mblength_b;\n            }\n        }\n    }\n\nnot_equal:\n  if (key && key->reverse)\n    return -diff;\n  else\n    return diff;\n}", "line_changes": {"deleted": [{"line_no": 108, "char_start": 5967, "char_end": 6032, "line": "          char *copy_a = (char *) xmalloc (lena + 1 + lenb + 1);\n"}, {"line_no": 109, "char_start": 6032, "char_end": 6076, "line": "          char *copy_b = copy_a + lena + 1;\n"}], "added": [{"line_no": 108, "char_start": 5967, "char_end": 6009, "line": "          if (SIZE_MAX - lenb - 2 < lena)\n"}, {"line_no": 109, "char_start": 6009, "char_end": 6036, "line": "            xalloc_die ();\n"}, {"line_no": 110, "char_start": 6036, "char_end": 6110, "line": "          char *copy_a = (char *) xnmalloc (lena + lenb + 2, MB_CUR_MAX);\n"}, {"line_no": 111, "char_start": 6110, "char_end": 6167, "line": "          char *copy_b = copy_a + lena * MB_CUR_MAX + 1;\n"}]}, "char_changes": {"deleted": [{"char_start": 6017, "char_end": 6021, "chars": "1 + "}, {"char_start": 6028, "char_end": 6029, "chars": "1"}], "added": [{"char_start": 5977, "char_end": 6046, "chars": "if (SIZE_MAX - lenb - 2 < lena)\n            xalloc_die ();\n          "}, {"char_start": 6071, "char_end": 6072, "chars": "n"}, {"char_start": 6094, "char_end": 6107, "chars": "2, MB_CUR_MAX"}, {"char_start": 6148, "char_end": 6161, "chars": " * MB_CUR_MAX"}]}, "commit_link": "github.com/pixelb/coreutils/commit/bea5e36cc876ed627bb5e0eca36fdfaa6465e940", "file_name": "src/sort.c", "vul_type": "cwe-787"}
{"func_name": "next_state_val", "func_src_before": "next_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n\t       int* vs_israw, int v_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n    break;\n\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*vs > 0xff || v > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )v);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *vs, v);\n        if (r < 0) return r;\n      }\n    }\n    else {\n#if 0\n      if (intype == CCV_CODE_POINT && *type == CCV_SB) {\n#endif\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));\n        r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);\n        if (r < 0) return r;\n#if 0\n      }\n      else\n        return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;\n#endif\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n\n  default:\n    break;\n  }\n\n  *vs_israw = v_israw;\n  *vs       = v;\n  *type     = intype;\n  return 0;\n}", "func_src_after": "next_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n\t       int* vs_israw, int v_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      if (*vs > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n    break;\n\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*vs > 0xff || v > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )v);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *vs, v);\n        if (r < 0) return r;\n      }\n    }\n    else {\n#if 0\n      if (intype == CCV_CODE_POINT && *type == CCV_SB) {\n#endif\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));\n        r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);\n        if (r < 0) return r;\n#if 0\n      }\n      else\n        return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;\n#endif\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n\n  default:\n    break;\n  }\n\n  *vs_israw = v_israw;\n  *vs       = v;\n  *type     = intype;\n  return 0;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 11, "char_start": 276, "char_end": 298, "line": "      if (*vs > 0xff)\n"}, {"line_no": 12, "char_start": 298, "char_end": 349, "line": "          return ONIGERR_INVALID_CODE_POINT_VALUE;\n"}, {"line_no": 13, "char_start": 349, "char_end": 350, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 282, "char_end": 356, "chars": "if (*vs > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n      "}]}, "commit_link": "github.com/kkos/oniguruma/commit/b4bf968ad52afe14e60a2dc8a95d3555c543353a", "file_name": "src/regparse.c", "vul_type": "cwe-787"}
{"func_name": "cbs_jpeg_split_fragment", "func_src_before": "static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,\n                                   CodedBitstreamFragment *frag,\n                                   int header)\n{\n    AVBufferRef *data_ref;\n    uint8_t *data;\n    size_t data_size;\n    int unit, start, end, marker, next_start, next_marker;\n    int err, i, j, length;\n\n    if (frag->data_size < 4) {\n        // Definitely too short to be meaningful.\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);\n    if (i > 0) {\n        av_log(ctx->log_ctx, AV_LOG_WARNING, \"Discarding %d bytes at \"\n               \"beginning of image.\\n\", i);\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size && frag->data[i]) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no SOI marker found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    if (marker != JPEG_MARKER_SOI) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: first \"\n               \"marker is %02x, should be SOI.\\n\", marker);\n        return AVERROR_INVALIDDATA;\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no image content found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    start  = i + 1;\n\n    for (unit = 0;; unit++) {\n        if (marker == JPEG_MARKER_EOI) {\n            break;\n        } else if (marker == JPEG_MARKER_SOS) {\n            for (i = start; i + 1 < frag->data_size; i++) {\n                if (frag->data[i] != 0xff)\n                    continue;\n                end = i;\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    if (frag->data[i] == 0x00)\n                        continue;\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n                break;\n            }\n        } else {\n            i = start;\n            if (i + 2 > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            length = AV_RB16(frag->data + i);\n            if (i + length > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker segment.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            end = start + length;\n\n            i = end;\n            if (frag->data[i] != 0xff) {\n                next_marker = -1;\n            } else {\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n            }\n        }\n\n        if (marker == JPEG_MARKER_SOS) {\n            length = AV_RB16(frag->data + start);\n\n            data_ref = NULL;\n            data     = av_malloc(end - start +\n                                 AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!data)\n                return AVERROR(ENOMEM);\n\n            memcpy(data, frag->data + start, length);\n            for (i = start + length, j = length; i < end; i++, j++) {\n                if (frag->data[i] == 0xff) {\n                    while (frag->data[i] == 0xff)\n                        ++i;\n                    data[j] = 0xff;\n                } else {\n                    data[j] = frag->data[i];\n                }\n            }\n            data_size = j;\n\n            memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        } else {\n            data      = frag->data + start;\n            data_size = end - start;\n            data_ref  = frag->data_ref;\n        }\n\n        err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,\n                                      data, data_size, data_ref);\n        if (err < 0)\n            return err;\n\n        if (next_marker == -1)\n            break;\n        marker = next_marker;\n        start  = next_start;\n    }\n\n    return 0;\n}", "func_src_after": "static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,\n                                   CodedBitstreamFragment *frag,\n                                   int header)\n{\n    AVBufferRef *data_ref;\n    uint8_t *data;\n    size_t data_size;\n    int unit, start, end, marker, next_start, next_marker;\n    int err, i, j, length;\n\n    if (frag->data_size < 4) {\n        // Definitely too short to be meaningful.\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);\n    if (i > 0) {\n        av_log(ctx->log_ctx, AV_LOG_WARNING, \"Discarding %d bytes at \"\n               \"beginning of image.\\n\", i);\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size && frag->data[i]) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no SOI marker found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    if (marker != JPEG_MARKER_SOI) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: first \"\n               \"marker is %02x, should be SOI.\\n\", marker);\n        return AVERROR_INVALIDDATA;\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no image content found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    start  = i + 1;\n\n    for (unit = 0;; unit++) {\n        if (marker == JPEG_MARKER_EOI) {\n            break;\n        } else if (marker == JPEG_MARKER_SOS) {\n            for (i = start; i + 1 < frag->data_size; i++) {\n                if (frag->data[i] != 0xff)\n                    continue;\n                end = i;\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    if (frag->data[i] == 0x00)\n                        continue;\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n                break;\n            }\n        } else {\n            i = start;\n            if (i + 2 > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            length = AV_RB16(frag->data + i);\n            if (i + length > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker segment.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            end = start + length;\n\n            i = end;\n            if (frag->data[i] != 0xff) {\n                next_marker = -1;\n            } else {\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n            }\n        }\n\n        if (marker == JPEG_MARKER_SOS) {\n            length = AV_RB16(frag->data + start);\n\n            if (length > end - start)\n                return AVERROR_INVALIDDATA;\n\n            data_ref = NULL;\n            data     = av_malloc(end - start +\n                                 AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!data)\n                return AVERROR(ENOMEM);\n\n            memcpy(data, frag->data + start, length);\n            for (i = start + length, j = length; i < end; i++, j++) {\n                if (frag->data[i] == 0xff) {\n                    while (frag->data[i] == 0xff)\n                        ++i;\n                    data[j] = 0xff;\n                } else {\n                    data[j] = frag->data[i];\n                }\n            }\n            data_size = j;\n\n            memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        } else {\n            data      = frag->data + start;\n            data_size = end - start;\n            data_ref  = frag->data_ref;\n        }\n\n        err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,\n                                      data, data_size, data_ref);\n        if (err < 0)\n            return err;\n\n        if (next_marker == -1)\n            break;\n        marker = next_marker;\n        start  = next_start;\n    }\n\n    return 0;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 95, "char_start": 3398, "char_end": 3436, "line": "            if (length > end - start)\n"}, {"line_no": 96, "char_start": 3436, "char_end": 3480, "line": "                return AVERROR_INVALIDDATA;\n"}, {"line_no": 97, "char_start": 3480, "char_end": 3481, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 3410, "char_end": 3493, "chars": "if (length > end - start)\n                return AVERROR_INVALIDDATA;\n\n            "}]}, "commit_link": "github.com/FFmpeg/FFmpeg/commit/1812352d767ccf5431aa440123e2e260a4db2726", "file_name": "libavcodec/cbs_jpeg.c", "vul_type": "cwe-787"}
{"func_name": "avcodec_align_dimensions2", "func_src_before": "void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,\n                               int linesize_align[AV_NUM_DATA_POINTERS])\n{\n    int i;\n    int w_align = 1;\n    int h_align = 1;\n    AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);\n\n    if (desc) {\n        w_align = 1 << desc->log2_chroma_w;\n        h_align = 1 << desc->log2_chroma_h;\n    }\n\n    switch (s->pix_fmt) {\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUYV422:\n    case AV_PIX_FMT_YVYU422:\n    case AV_PIX_FMT_UYVY422:\n    case AV_PIX_FMT_YUV422P:\n    case AV_PIX_FMT_YUV440P:\n    case AV_PIX_FMT_YUV444P:\n    case AV_PIX_FMT_GBRP:\n    case AV_PIX_FMT_GBRAP:\n    case AV_PIX_FMT_GRAY8:\n    case AV_PIX_FMT_GRAY16BE:\n    case AV_PIX_FMT_GRAY16LE:\n    case AV_PIX_FMT_YUVJ420P:\n    case AV_PIX_FMT_YUVJ422P:\n    case AV_PIX_FMT_YUVJ440P:\n    case AV_PIX_FMT_YUVJ444P:\n    case AV_PIX_FMT_YUVA420P:\n    case AV_PIX_FMT_YUVA422P:\n    case AV_PIX_FMT_YUVA444P:\n    case AV_PIX_FMT_YUV420P9LE:\n    case AV_PIX_FMT_YUV420P9BE:\n    case AV_PIX_FMT_YUV420P10LE:\n    case AV_PIX_FMT_YUV420P10BE:\n    case AV_PIX_FMT_YUV420P12LE:\n    case AV_PIX_FMT_YUV420P12BE:\n    case AV_PIX_FMT_YUV420P14LE:\n    case AV_PIX_FMT_YUV420P14BE:\n    case AV_PIX_FMT_YUV420P16LE:\n    case AV_PIX_FMT_YUV420P16BE:\n    case AV_PIX_FMT_YUVA420P9LE:\n    case AV_PIX_FMT_YUVA420P9BE:\n    case AV_PIX_FMT_YUVA420P10LE:\n    case AV_PIX_FMT_YUVA420P10BE:\n    case AV_PIX_FMT_YUVA420P16LE:\n    case AV_PIX_FMT_YUVA420P16BE:\n    case AV_PIX_FMT_YUV422P9LE:\n    case AV_PIX_FMT_YUV422P9BE:\n    case AV_PIX_FMT_YUV422P10LE:\n    case AV_PIX_FMT_YUV422P10BE:\n    case AV_PIX_FMT_YUV422P12LE:\n    case AV_PIX_FMT_YUV422P12BE:\n    case AV_PIX_FMT_YUV422P14LE:\n    case AV_PIX_FMT_YUV422P14BE:\n    case AV_PIX_FMT_YUV422P16LE:\n    case AV_PIX_FMT_YUV422P16BE:\n    case AV_PIX_FMT_YUVA422P9LE:\n    case AV_PIX_FMT_YUVA422P9BE:\n    case AV_PIX_FMT_YUVA422P10LE:\n    case AV_PIX_FMT_YUVA422P10BE:\n    case AV_PIX_FMT_YUVA422P16LE:\n    case AV_PIX_FMT_YUVA422P16BE:\n    case AV_PIX_FMT_YUV440P10LE:\n    case AV_PIX_FMT_YUV440P10BE:\n    case AV_PIX_FMT_YUV440P12LE:\n    case AV_PIX_FMT_YUV440P12BE:\n    case AV_PIX_FMT_YUV444P9LE:\n    case AV_PIX_FMT_YUV444P9BE:\n    case AV_PIX_FMT_YUV444P10LE:\n    case AV_PIX_FMT_YUV444P10BE:\n    case AV_PIX_FMT_YUV444P12LE:\n    case AV_PIX_FMT_YUV444P12BE:\n    case AV_PIX_FMT_YUV444P14LE:\n    case AV_PIX_FMT_YUV444P14BE:\n    case AV_PIX_FMT_YUV444P16LE:\n    case AV_PIX_FMT_YUV444P16BE:\n    case AV_PIX_FMT_YUVA444P9LE:\n    case AV_PIX_FMT_YUVA444P9BE:\n    case AV_PIX_FMT_YUVA444P10LE:\n    case AV_PIX_FMT_YUVA444P10BE:\n    case AV_PIX_FMT_YUVA444P16LE:\n    case AV_PIX_FMT_YUVA444P16BE:\n    case AV_PIX_FMT_GBRP9LE:\n    case AV_PIX_FMT_GBRP9BE:\n    case AV_PIX_FMT_GBRP10LE:\n    case AV_PIX_FMT_GBRP10BE:\n    case AV_PIX_FMT_GBRP12LE:\n    case AV_PIX_FMT_GBRP12BE:\n    case AV_PIX_FMT_GBRP14LE:\n    case AV_PIX_FMT_GBRP14BE:\n    case AV_PIX_FMT_GBRP16LE:\n    case AV_PIX_FMT_GBRP16BE:\n    case AV_PIX_FMT_GBRAP12LE:\n    case AV_PIX_FMT_GBRAP12BE:\n    case AV_PIX_FMT_GBRAP16LE:\n    case AV_PIX_FMT_GBRAP16BE:\n        w_align = 16; //FIXME assume 16 pixel per macroblock\n        h_align = 16 * 2; // interlaced needs 2 macroblocks height\n        break;\n    case AV_PIX_FMT_YUV411P:\n    case AV_PIX_FMT_YUVJ411P:\n    case AV_PIX_FMT_UYYVYY411:\n        w_align = 32;\n        h_align = 16 * 2;\n        break;\n    case AV_PIX_FMT_YUV410P:\n        if (s->codec_id == AV_CODEC_ID_SVQ1) {\n            w_align = 64;\n            h_align = 64;\n        }\n        break;\n    case AV_PIX_FMT_RGB555:\n        if (s->codec_id == AV_CODEC_ID_RPZA) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    case AV_PIX_FMT_PAL8:\n    case AV_PIX_FMT_BGR8:\n    case AV_PIX_FMT_RGB8:\n        if (s->codec_id == AV_CODEC_ID_SMC ||\n            s->codec_id == AV_CODEC_ID_CINEPAK) {\n            w_align = 4;\n            h_align = 4;\n        }\n        if (s->codec_id == AV_CODEC_ID_JV) {\n            w_align = 8;\n            h_align = 8;\n        }\n        break;\n    case AV_PIX_FMT_BGR24:\n        if ((s->codec_id == AV_CODEC_ID_MSZH) ||\n            (s->codec_id == AV_CODEC_ID_ZLIB)) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    case AV_PIX_FMT_RGB24:\n        if (s->codec_id == AV_CODEC_ID_CINEPAK) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    default:\n        break;\n    }\n\n    if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {\n        w_align = FFMAX(w_align, 8);\n    }\n\n    *width  = FFALIGN(*width, w_align);\n    *height = FFALIGN(*height, h_align);\n    if (s->codec_id == AV_CODEC_ID_H264 || s->lowres) {\n        // some of the optimized chroma MC reads one line too much\n        // which is also done in mpeg decoders with lowres > 0\n        *height += 2;\n\n        // H.264 uses edge emulation for out of frame motion vectors, for this\n        // it requires a temporary area large enough to hold a 21x21 block,\n        // increasing witdth ensure that the temporary area is large enough,\n        // the next rounded up width is 32\n        *width = FFMAX(*width, 32);\n    }\n\n    for (i = 0; i < 4; i++)\n        linesize_align[i] = STRIDE_ALIGN;\n}", "func_src_after": "void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,\n                               int linesize_align[AV_NUM_DATA_POINTERS])\n{\n    int i;\n    int w_align = 1;\n    int h_align = 1;\n    AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);\n\n    if (desc) {\n        w_align = 1 << desc->log2_chroma_w;\n        h_align = 1 << desc->log2_chroma_h;\n    }\n\n    switch (s->pix_fmt) {\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUYV422:\n    case AV_PIX_FMT_YVYU422:\n    case AV_PIX_FMT_UYVY422:\n    case AV_PIX_FMT_YUV422P:\n    case AV_PIX_FMT_YUV440P:\n    case AV_PIX_FMT_YUV444P:\n    case AV_PIX_FMT_GBRP:\n    case AV_PIX_FMT_GBRAP:\n    case AV_PIX_FMT_GRAY8:\n    case AV_PIX_FMT_GRAY16BE:\n    case AV_PIX_FMT_GRAY16LE:\n    case AV_PIX_FMT_YUVJ420P:\n    case AV_PIX_FMT_YUVJ422P:\n    case AV_PIX_FMT_YUVJ440P:\n    case AV_PIX_FMT_YUVJ444P:\n    case AV_PIX_FMT_YUVA420P:\n    case AV_PIX_FMT_YUVA422P:\n    case AV_PIX_FMT_YUVA444P:\n    case AV_PIX_FMT_YUV420P9LE:\n    case AV_PIX_FMT_YUV420P9BE:\n    case AV_PIX_FMT_YUV420P10LE:\n    case AV_PIX_FMT_YUV420P10BE:\n    case AV_PIX_FMT_YUV420P12LE:\n    case AV_PIX_FMT_YUV420P12BE:\n    case AV_PIX_FMT_YUV420P14LE:\n    case AV_PIX_FMT_YUV420P14BE:\n    case AV_PIX_FMT_YUV420P16LE:\n    case AV_PIX_FMT_YUV420P16BE:\n    case AV_PIX_FMT_YUVA420P9LE:\n    case AV_PIX_FMT_YUVA420P9BE:\n    case AV_PIX_FMT_YUVA420P10LE:\n    case AV_PIX_FMT_YUVA420P10BE:\n    case AV_PIX_FMT_YUVA420P16LE:\n    case AV_PIX_FMT_YUVA420P16BE:\n    case AV_PIX_FMT_YUV422P9LE:\n    case AV_PIX_FMT_YUV422P9BE:\n    case AV_PIX_FMT_YUV422P10LE:\n    case AV_PIX_FMT_YUV422P10BE:\n    case AV_PIX_FMT_YUV422P12LE:\n    case AV_PIX_FMT_YUV422P12BE:\n    case AV_PIX_FMT_YUV422P14LE:\n    case AV_PIX_FMT_YUV422P14BE:\n    case AV_PIX_FMT_YUV422P16LE:\n    case AV_PIX_FMT_YUV422P16BE:\n    case AV_PIX_FMT_YUVA422P9LE:\n    case AV_PIX_FMT_YUVA422P9BE:\n    case AV_PIX_FMT_YUVA422P10LE:\n    case AV_PIX_FMT_YUVA422P10BE:\n    case AV_PIX_FMT_YUVA422P16LE:\n    case AV_PIX_FMT_YUVA422P16BE:\n    case AV_PIX_FMT_YUV440P10LE:\n    case AV_PIX_FMT_YUV440P10BE:\n    case AV_PIX_FMT_YUV440P12LE:\n    case AV_PIX_FMT_YUV440P12BE:\n    case AV_PIX_FMT_YUV444P9LE:\n    case AV_PIX_FMT_YUV444P9BE:\n    case AV_PIX_FMT_YUV444P10LE:\n    case AV_PIX_FMT_YUV444P10BE:\n    case AV_PIX_FMT_YUV444P12LE:\n    case AV_PIX_FMT_YUV444P12BE:\n    case AV_PIX_FMT_YUV444P14LE:\n    case AV_PIX_FMT_YUV444P14BE:\n    case AV_PIX_FMT_YUV444P16LE:\n    case AV_PIX_FMT_YUV444P16BE:\n    case AV_PIX_FMT_YUVA444P9LE:\n    case AV_PIX_FMT_YUVA444P9BE:\n    case AV_PIX_FMT_YUVA444P10LE:\n    case AV_PIX_FMT_YUVA444P10BE:\n    case AV_PIX_FMT_YUVA444P16LE:\n    case AV_PIX_FMT_YUVA444P16BE:\n    case AV_PIX_FMT_GBRP9LE:\n    case AV_PIX_FMT_GBRP9BE:\n    case AV_PIX_FMT_GBRP10LE:\n    case AV_PIX_FMT_GBRP10BE:\n    case AV_PIX_FMT_GBRP12LE:\n    case AV_PIX_FMT_GBRP12BE:\n    case AV_PIX_FMT_GBRP14LE:\n    case AV_PIX_FMT_GBRP14BE:\n    case AV_PIX_FMT_GBRP16LE:\n    case AV_PIX_FMT_GBRP16BE:\n    case AV_PIX_FMT_GBRAP12LE:\n    case AV_PIX_FMT_GBRAP12BE:\n    case AV_PIX_FMT_GBRAP16LE:\n    case AV_PIX_FMT_GBRAP16BE:\n        w_align = 16; //FIXME assume 16 pixel per macroblock\n        h_align = 16 * 2; // interlaced needs 2 macroblocks height\n        break;\n    case AV_PIX_FMT_YUV411P:\n    case AV_PIX_FMT_YUVJ411P:\n    case AV_PIX_FMT_UYYVYY411:\n        w_align = 32;\n        h_align = 16 * 2;\n        break;\n    case AV_PIX_FMT_YUV410P:\n        if (s->codec_id == AV_CODEC_ID_SVQ1) {\n            w_align = 64;\n            h_align = 64;\n        }\n        break;\n    case AV_PIX_FMT_RGB555:\n        if (s->codec_id == AV_CODEC_ID_RPZA) {\n            w_align = 4;\n            h_align = 4;\n        }\n        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {\n            w_align = 8;\n            h_align = 8;\n        }\n        break;\n    case AV_PIX_FMT_PAL8:\n    case AV_PIX_FMT_BGR8:\n    case AV_PIX_FMT_RGB8:\n        if (s->codec_id == AV_CODEC_ID_SMC ||\n            s->codec_id == AV_CODEC_ID_CINEPAK) {\n            w_align = 4;\n            h_align = 4;\n        }\n        if (s->codec_id == AV_CODEC_ID_JV ||\n            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {\n            w_align = 8;\n            h_align = 8;\n        }\n        break;\n    case AV_PIX_FMT_BGR24:\n        if ((s->codec_id == AV_CODEC_ID_MSZH) ||\n            (s->codec_id == AV_CODEC_ID_ZLIB)) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    case AV_PIX_FMT_RGB24:\n        if (s->codec_id == AV_CODEC_ID_CINEPAK) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    default:\n        break;\n    }\n\n    if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {\n        w_align = FFMAX(w_align, 8);\n    }\n\n    *width  = FFALIGN(*width, w_align);\n    *height = FFALIGN(*height, h_align);\n    if (s->codec_id == AV_CODEC_ID_H264 || s->lowres) {\n        // some of the optimized chroma MC reads one line too much\n        // which is also done in mpeg decoders with lowres > 0\n        *height += 2;\n\n        // H.264 uses edge emulation for out of frame motion vectors, for this\n        // it requires a temporary area large enough to hold a 21x21 block,\n        // increasing witdth ensure that the temporary area is large enough,\n        // the next rounded up width is 32\n        *width = FFMAX(*width, 32);\n    }\n\n    for (i = 0; i < 4; i++)\n        linesize_align[i] = STRIDE_ALIGN;\n}", "line_changes": {"deleted": [{"line_no": 129, "char_start": 3941, "char_end": 3986, "line": "        if (s->codec_id == AV_CODEC_ID_JV) {\n"}], "added": [{"line_no": 120, "char_start": 3692, "char_end": 3750, "line": "        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {\n"}, {"line_no": 121, "char_start": 3750, "char_end": 3775, "line": "            w_align = 8;\n"}, {"line_no": 122, "char_start": 3775, "char_end": 3800, "line": "            h_align = 8;\n"}, {"line_no": 123, "char_start": 3800, "char_end": 3810, "line": "        }\n"}, {"line_no": 133, "char_start": 4059, "char_end": 4104, "line": "        if (s->codec_id == AV_CODEC_ID_JV ||\n"}, {"line_no": 134, "char_start": 4104, "char_end": 4162, "line": "            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 3700, "char_end": 3818, "chars": "if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {\n            w_align = 8;\n            h_align = 8;\n        }\n        "}, {"char_start": 4100, "char_end": 4158, "chars": " ||\n            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO"}]}, "commit_link": "github.com/FFmpeg/FFmpeg/commit/2080bc33717955a0e4268e738acf8c1eeddbf8cb", "file_name": "libavcodec/utils.c", "vul_type": "cwe-787"}
{"func_name": "ContentLine_Analyzer::DoDeliverOnce", "func_src_before": "int ContentLine_Analyzer::DoDeliverOnce(int len, const u_char* data)\n\t{\n\tconst u_char* data_start = data;\n\n\tif ( len <= 0 )\n\t\treturn 0;\n\n\tfor ( ; len > 0; --len, ++data )\n\t\t{\n\t\tif ( offset >= buf_len )\n\t\t\tInitBuffer(buf_len * 2);\n\n\t\tint c = data[0];\n\n#define EMIT_LINE \\\n\t{ \\\n\tbuf[offset] = '\\0'; \\\n\tint seq_len = data + 1 - data_start; \\\n\tseq_delivered_in_lines = seq + seq_len; \\\n\tlast_char = c; \\\n\tForwardStream(offset, buf, IsOrig()); \\\n\toffset = 0; \\\n\treturn seq_len; \\\n\t}\n\n\t\tswitch ( c ) {\n\t\tcase '\\r':\n\t\t\t// Look ahead for '\\n'.\n\t\t\tif ( len > 1 && data[1] == '\\n' )\n\t\t\t\t{\n\t\t\t\t--len; ++data;\n\t\t\t\tlast_char = c;\n\t\t\t\tc = data[0];\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\n\t\t\telse if ( CR_LF_as_EOL & CR_as_EOL )\n\t\t\t\tEMIT_LINE\n\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\n\t\tcase '\\n':\n\t\t\tif ( last_char == '\\r' )\n\t\t\t\t{\n\t\t\t\t--offset; // remove '\\r'\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\n\t\t\telse if ( CR_LF_as_EOL & LF_as_EOL )\n\t\t\t\tEMIT_LINE\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_LF) )\n\t\t\t\t\tConn()->Weird(\"line_terminated_with_single_LF\");\n\t\t\t\tbuf[offset++] = c;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '\\0':\n\t\t\tif ( flag_NULs )\n\t\t\t\tCheckNUL();\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( last_char == '\\r' )\n\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_CR) )\n\t\t\t\tConn()->Weird(\"line_terminated_with_single_CR\");\n\n\t\tlast_char = c;\n\t\t}\n\n\treturn data - data_start;\n\t}", "func_src_after": "int ContentLine_Analyzer::DoDeliverOnce(int len, const u_char* data)\n\t{\n\tconst u_char* data_start = data;\n\n\tif ( len <= 0 )\n\t\treturn 0;\n\n\tfor ( ; len > 0; --len, ++data )\n\t\t{\n\t\tif ( offset >= buf_len )\n\t\t\tInitBuffer(buf_len * 2);\n\n\t\tint c = data[0];\n\n#define EMIT_LINE \\\n\t{ \\\n\tbuf[offset] = '\\0'; \\\n\tint seq_len = data + 1 - data_start; \\\n\tseq_delivered_in_lines = seq + seq_len; \\\n\tlast_char = c; \\\n\tForwardStream(offset, buf, IsOrig()); \\\n\toffset = 0; \\\n\treturn seq_len; \\\n\t}\n\n\t\tswitch ( c ) {\n\t\tcase '\\r':\n\t\t\t// Look ahead for '\\n'.\n\t\t\tif ( len > 1 && data[1] == '\\n' )\n\t\t\t\t{\n\t\t\t\t--len; ++data;\n\t\t\t\tlast_char = c;\n\t\t\t\tc = data[0];\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\n\t\t\telse if ( CR_LF_as_EOL & CR_as_EOL )\n\t\t\t\tEMIT_LINE\n\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\n\t\tcase '\\n':\n\t\t\tif ( last_char == '\\r' )\n\t\t\t\t{\n\t\t\t\t// Weird corner-case:\n\t\t\t\t// this can happen if we see a \\r at the end of a packet where crlf is\n\t\t\t\t// set to CR_as_EOL | LF_as_EOL, with the packet causing crlf to be set to\n\t\t\t\t// 0 and the next packet beginning with a \\n. In this case we just swallow\n\t\t\t\t// the character and re-set last_char.\n\t\t\t\tif ( offset == 0 )\n\t\t\t\t\t{\n\t\t\t\t\tlast_char = c;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t--offset; // remove '\\r'\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\n\t\t\telse if ( CR_LF_as_EOL & LF_as_EOL )\n\t\t\t\tEMIT_LINE\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_LF) )\n\t\t\t\t\tConn()->Weird(\"line_terminated_with_single_LF\");\n\t\t\t\tbuf[offset++] = c;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '\\0':\n\t\t\tif ( flag_NULs )\n\t\t\t\tCheckNUL();\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( last_char == '\\r' )\n\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_CR) )\n\t\t\t\tConn()->Weird(\"line_terminated_with_single_CR\");\n\n\t\tlast_char = c;\n\t\t}\n\n\treturn data - data_start;\n\t}", "line_changes": {"deleted": [], "added": [{"line_no": 52, "char_start": 1101, "char_end": 1124, "line": "\t\t\t\tif ( offset == 0 )\n"}, {"line_no": 53, "char_start": 1124, "char_end": 1131, "line": "\t\t\t\t\t{\n"}, {"line_no": 54, "char_start": 1131, "char_end": 1151, "line": "\t\t\t\t\tlast_char = c;\n"}, {"line_no": 55, "char_start": 1151, "char_end": 1163, "line": "\t\t\t\t\tbreak;\n"}, {"line_no": 56, "char_start": 1163, "char_end": 1170, "line": "\t\t\t\t\t}\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 803, "char_end": 1174, "chars": "// Weird corner-case:\n\t\t\t\t// this can happen if we see a \\r at the end of a packet where crlf is\n\t\t\t\t// set to CR_as_EOL | LF_as_EOL, with the packet causing crlf to be set to\n\t\t\t\t// 0 and the next packet beginning with a \\n. In this case we just swallow\n\t\t\t\t// the character and re-set last_char.\n\t\t\t\tif ( offset == 0 )\n\t\t\t\t\t{\n\t\t\t\t\tlast_char = c;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t"}]}, "commit_link": "github.com/bro/bro/commit/6c0f101a62489b1c5927b4ed63b0e1d37db40282", "file_name": "src/analyzer/protocol/tcp/ContentLine.cc", "vul_type": "cwe-787"}
{"func_name": "idn2_to_ascii_4i", "func_src_before": "idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      /* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       */\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n\n      free(output_u8);\n    }\n\n  return rc;\n}", "func_src_after": "idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      /* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       */\n      size_t len = strlen ((char *) output_u8);\n\n      if (len > 63)\n        {\n\t  free (output_u8);\n\t  return IDN2_TOO_BIG_DOMAIN;\n        }\n\n      if (output)\n\tstrcpy (output, (char *) output_u8);\n\n      free (output_u8);\n    }\n\n  return rc;\n}", "line_changes": {"deleted": [{"line_no": 41, "char_start": 933, "char_end": 977, "line": "\tstrcpy (output, (const char *) output_u8);\n"}, {"line_no": 43, "char_start": 978, "char_end": 1001, "line": "      free(output_u8);\n"}], "added": [{"line_no": 40, "char_start": 915, "char_end": 963, "line": "      size_t len = strlen ((char *) output_u8);\n"}, {"line_no": 41, "char_start": 963, "char_end": 964, "line": "\n"}, {"line_no": 42, "char_start": 964, "char_end": 984, "line": "      if (len > 63)\n"}, {"line_no": 43, "char_start": 984, "char_end": 994, "line": "        {\n"}, {"line_no": 44, "char_start": 994, "char_end": 1015, "line": "\t  free (output_u8);\n"}, {"line_no": 45, "char_start": 1015, "char_end": 1046, "line": "\t  return IDN2_TOO_BIG_DOMAIN;\n"}, {"line_no": 46, "char_start": 1046, "char_end": 1056, "line": "        }\n"}, {"line_no": 47, "char_start": 1056, "char_end": 1057, "line": "\n"}, {"line_no": 49, "char_start": 1075, "char_end": 1113, "line": "\tstrcpy (output, (char *) output_u8);\n"}, {"line_no": 51, "char_start": 1114, "char_end": 1138, "line": "      free (output_u8);\n"}]}, "char_changes": {"deleted": [{"char_start": 951, "char_end": 957, "chars": "const "}], "added": [{"char_start": 921, "char_end": 1063, "chars": "size_t len = strlen ((char *) output_u8);\n\n      if (len > 63)\n        {\n\t  free (output_u8);\n\t  return IDN2_TOO_BIG_DOMAIN;\n        }\n\n      "}, {"char_start": 1124, "char_end": 1125, "chars": " "}]}, "commit_link": "github.com/libidn/libidn2/commit/e4d1558aa2c1c04a05066ee8600f37603890ba8c", "file_name": "lib/lookup.c", "vul_type": "cwe-787"}
{"func_name": "blosc_c", "func_src_before": "static int blosc_c(struct thread_context* thread_context, int32_t bsize,\n                   int32_t leftoverblock, int32_t ntbytes, int32_t maxbytes,\n                   const uint8_t* src, const int32_t offset, uint8_t* dest,\n                   uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  int dont_split = (context->header_flags & 0x10) >> 4;\n  int dict_training = context->use_dict && context->dict_cdict == NULL;\n  int32_t j, neblock, nstreams;\n  int32_t cbytes;                   /* number of compressed bytes in split */\n  int32_t ctbytes = 0;              /* number of compressed bytes in block */\n  int64_t maxout;\n  int32_t typesize = context->typesize;\n  const char* compname;\n  int accel;\n  const uint8_t* _src;\n  uint8_t *_tmp = tmp, *_tmp2 = tmp2;\n  uint8_t *_tmp3 = thread_context->tmp4;\n  int last_filter_index = last_filter(context->filters, 'c');\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  if (last_filter_index >= 0 || context->prefilter != NULL) {\n    /* Apply the filter pipeline just for the prefilter */\n    if (memcpyed && context->prefilter != NULL) {\n      // We only need the prefilter output\n      _src = pipeline_c(thread_context, bsize, src, offset, dest, _tmp2, _tmp3);\n\n      if (_src == NULL) {\n        return -9;  // signals a problem with the filter pipeline\n      }\n      return bsize;\n    }\n    /* Apply regular filter pipeline */\n    _src = pipeline_c(thread_context, bsize, src, offset, _tmp, _tmp2, _tmp3);\n\n    if (_src == NULL) {\n      return -9;  // signals a problem with the filter pipeline\n    }\n  } else {\n    _src = src + offset;\n  }\n\n  assert(context->clevel > 0);\n\n  /* Calculate acceleration for different compressors */\n  accel = get_accel(context);\n\n  /* The number of compressed data streams for this block */\n  if (!dont_split && !leftoverblock && !dict_training) {\n    nstreams = (int32_t)typesize;\n  }\n  else {\n    nstreams = 1;\n  }\n  neblock = bsize / nstreams;\n  for (j = 0; j < nstreams; j++) {\n    if (!dict_training) {\n      dest += sizeof(int32_t);\n      ntbytes += sizeof(int32_t);\n      ctbytes += sizeof(int32_t);\n    }\n\n    // See if we have a run here\n    const uint8_t* ip = (uint8_t*)_src + j * neblock;\n    const uint8_t* ipbound = (uint8_t*)_src + (j + 1) * neblock;\n    if (get_run(ip, ipbound)) {\n      // A run.  Encode the repeated byte as a negative length in the length of the split.\n      int32_t value = _src[j * neblock];\n      _sw32(dest - 4, -value);\n      continue;\n    }\n\n    maxout = neblock;\n  #if defined(HAVE_SNAPPY)\n    if (context->compcode == BLOSC_SNAPPY) {\n      maxout = (int32_t)snappy_max_compressed_length((size_t)neblock);\n    }\n  #endif /*  HAVE_SNAPPY */\n    if (ntbytes + maxout > maxbytes) {\n      /* avoid buffer * overrun */\n      maxout = (int64_t)maxbytes - (int64_t)ntbytes;\n      if (maxout <= 0) {\n        return 0;                  /* non-compressible block */\n      }\n    }\n    if (dict_training) {\n      // We are in the build dict state, so don't compress\n      // TODO: copy only a percentage for sampling\n      memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n      cbytes = (int32_t)neblock;\n    }\n    else if (context->compcode == BLOSC_BLOSCLZ) {\n      cbytes = blosclz_compress(context->clevel, _src + j * neblock,\n                                (int)neblock, dest, (int)maxout);\n    }\n  #if defined(HAVE_LZ4)\n    else if (context->compcode == BLOSC_LZ4) {\n      void *hash_table = NULL;\n    #ifdef HAVE_IPP\n      hash_table = (void*)thread_context->lz4_hash_table;\n    #endif\n      cbytes = lz4_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                 (char*)dest, (size_t)maxout, accel, hash_table);\n    }\n    else if (context->compcode == BLOSC_LZ4HC) {\n      cbytes = lz4hc_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                   (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_LZ4 */\n  #if defined(HAVE_LIZARD)\n    else if (context->compcode == BLOSC_LIZARD) {\n      cbytes = lizard_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout, accel);\n    }\n  #endif /* HAVE_LIZARD */\n  #if defined(HAVE_SNAPPY)\n    else if (context->compcode == BLOSC_SNAPPY) {\n      cbytes = snappy_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout);\n    }\n  #endif /* HAVE_SNAPPY */\n  #if defined(HAVE_ZLIB)\n    else if (context->compcode == BLOSC_ZLIB) {\n      cbytes = zlib_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZLIB */\n  #if defined(HAVE_ZSTD)\n    else if (context->compcode == BLOSC_ZSTD) {\n      cbytes = zstd_wrap_compress(thread_context,\n                                  (char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZSTD */\n\n    else {\n      blosc_compcode_to_compname(context->compcode, &compname);\n      fprintf(stderr, \"Blosc has not been compiled with '%s' \", compname);\n      fprintf(stderr, \"compression support.  Please use one having it.\");\n      return -5;    /* signals no compression support */\n    }\n\n    if (cbytes > maxout) {\n      /* Buffer overrun caused by compression (should never happen) */\n      return -1;\n    }\n    if (cbytes < 0) {\n      /* cbytes should never be negative */\n      return -2;\n    }\n    if (!dict_training) {\n      if (cbytes == 0 || cbytes == neblock) {\n        /* The compressor has been unable to compress data at all. */\n        /* Before doing the copy, check that we are not running into a\n           buffer overflow. */\n        if ((ntbytes + neblock) > maxbytes) {\n          return 0;    /* Non-compressible data */\n        }\n        memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n        cbytes = neblock;\n      }\n      _sw32(dest - 4, cbytes);\n    }\n    dest += cbytes;\n    ntbytes += cbytes;\n    ctbytes += cbytes;\n  }  /* Closes j < nstreams */\n\n  //printf(\"c%d\", ctbytes);\n  return ctbytes;\n}", "func_src_after": "static int blosc_c(struct thread_context* thread_context, int32_t bsize,\n                   int32_t leftoverblock, int32_t ntbytes, int32_t destsize,\n                   const uint8_t* src, const int32_t offset, uint8_t* dest,\n                   uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  int dont_split = (context->header_flags & 0x10) >> 4;\n  int dict_training = context->use_dict && context->dict_cdict == NULL;\n  int32_t j, neblock, nstreams;\n  int32_t cbytes;                   /* number of compressed bytes in split */\n  int32_t ctbytes = 0;              /* number of compressed bytes in block */\n  int64_t maxout;\n  int32_t typesize = context->typesize;\n  const char* compname;\n  int accel;\n  const uint8_t* _src;\n  uint8_t *_tmp = tmp, *_tmp2 = tmp2;\n  uint8_t *_tmp3 = thread_context->tmp4;\n  int last_filter_index = last_filter(context->filters, 'c');\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  if (last_filter_index >= 0 || context->prefilter != NULL) {\n    /* Apply the filter pipeline just for the prefilter */\n    if (memcpyed && context->prefilter != NULL) {\n      // We only need the prefilter output\n      _src = pipeline_c(thread_context, bsize, src, offset, dest, _tmp2, _tmp3);\n\n      if (_src == NULL) {\n        return -9;  // signals a problem with the filter pipeline\n      }\n      return bsize;\n    }\n    /* Apply regular filter pipeline */\n    _src = pipeline_c(thread_context, bsize, src, offset, _tmp, _tmp2, _tmp3);\n\n    if (_src == NULL) {\n      return -9;  // signals a problem with the filter pipeline\n    }\n  } else {\n    _src = src + offset;\n  }\n\n  assert(context->clevel > 0);\n\n  /* Calculate acceleration for different compressors */\n  accel = get_accel(context);\n\n  /* The number of compressed data streams for this block */\n  if (!dont_split && !leftoverblock && !dict_training) {\n    nstreams = (int32_t)typesize;\n  }\n  else {\n    nstreams = 1;\n  }\n  neblock = bsize / nstreams;\n  for (j = 0; j < nstreams; j++) {\n    if (!dict_training) {\n      dest += sizeof(int32_t);\n      ntbytes += sizeof(int32_t);\n      ctbytes += sizeof(int32_t);\n    }\n\n    // See if we have a run here\n    const uint8_t* ip = (uint8_t*)_src + j * neblock;\n    const uint8_t* ipbound = (uint8_t*)_src + (j + 1) * neblock;\n    if (get_run(ip, ipbound)) {\n      // A run.  Encode the repeated byte as a negative length in the length of the split.\n      int32_t value = _src[j * neblock];\n      if (ntbytes > destsize) {\n        /* Not enough space to write out compressed block size */\n        return -1;\n      }\n      _sw32(dest - 4, -value);\n      continue;\n    }\n\n    maxout = neblock;\n  #if defined(HAVE_SNAPPY)\n    if (context->compcode == BLOSC_SNAPPY) {\n      maxout = (int32_t)snappy_max_compressed_length((size_t)neblock);\n    }\n  #endif /*  HAVE_SNAPPY */\n    if (ntbytes + maxout > destsize) {\n      /* avoid buffer * overrun */\n      maxout = (int64_t)destsize - (int64_t)ntbytes;\n      if (maxout <= 0) {\n        return 0;                  /* non-compressible block */\n      }\n    }\n    if (dict_training) {\n      // We are in the build dict state, so don't compress\n      // TODO: copy only a percentage for sampling\n      memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n      cbytes = (int32_t)neblock;\n    }\n    else if (context->compcode == BLOSC_BLOSCLZ) {\n      cbytes = blosclz_compress(context->clevel, _src + j * neblock,\n                                (int)neblock, dest, (int)maxout);\n    }\n  #if defined(HAVE_LZ4)\n    else if (context->compcode == BLOSC_LZ4) {\n      void *hash_table = NULL;\n    #ifdef HAVE_IPP\n      hash_table = (void*)thread_context->lz4_hash_table;\n    #endif\n      cbytes = lz4_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                 (char*)dest, (size_t)maxout, accel, hash_table);\n    }\n    else if (context->compcode == BLOSC_LZ4HC) {\n      cbytes = lz4hc_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                   (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_LZ4 */\n  #if defined(HAVE_LIZARD)\n    else if (context->compcode == BLOSC_LIZARD) {\n      cbytes = lizard_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout, accel);\n    }\n  #endif /* HAVE_LIZARD */\n  #if defined(HAVE_SNAPPY)\n    else if (context->compcode == BLOSC_SNAPPY) {\n      cbytes = snappy_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout);\n    }\n  #endif /* HAVE_SNAPPY */\n  #if defined(HAVE_ZLIB)\n    else if (context->compcode == BLOSC_ZLIB) {\n      cbytes = zlib_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZLIB */\n  #if defined(HAVE_ZSTD)\n    else if (context->compcode == BLOSC_ZSTD) {\n      cbytes = zstd_wrap_compress(thread_context,\n                                  (char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZSTD */\n\n    else {\n      blosc_compcode_to_compname(context->compcode, &compname);\n      fprintf(stderr, \"Blosc has not been compiled with '%s' \", compname);\n      fprintf(stderr, \"compression support.  Please use one having it.\");\n      return -5;    /* signals no compression support */\n    }\n\n    if (cbytes > maxout) {\n      /* Buffer overrun caused by compression (should never happen) */\n      return -1;\n    }\n    if (cbytes < 0) {\n      /* cbytes should never be negative */\n      return -2;\n    }\n    if (!dict_training) {\n      if (cbytes == 0 || cbytes == neblock) {\n        /* The compressor has been unable to compress data at all. */\n        /* Before doing the copy, check that we are not running into a\n           buffer overflow. */\n        if ((ntbytes + neblock) > destsize) {\n          return 0;    /* Non-compressible data */\n        }\n        memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n        cbytes = neblock;\n      }\n      _sw32(dest - 4, cbytes);\n    }\n    dest += cbytes;\n    ntbytes += cbytes;\n    ctbytes += cbytes;\n  }  /* Closes j < nstreams */\n\n  //printf(\"c%d\", ctbytes);\n  return ctbytes;\n}", "line_changes": {"deleted": [{"line_no": 2, "char_start": 73, "char_end": 150, "line": "                   int32_t leftoverblock, int32_t ntbytes, int32_t maxbytes,\n"}, {"line_no": 78, "char_start": 2729, "char_end": 2768, "line": "    if (ntbytes + maxout > maxbytes) {\n"}, {"line_no": 80, "char_start": 2803, "char_end": 2856, "line": "      maxout = (int64_t)maxbytes - (int64_t)ntbytes;\n"}, {"line_no": 155, "char_start": 5822, "char_end": 5868, "line": "        if ((ntbytes + neblock) > maxbytes) {\n"}], "added": [{"line_no": 2, "char_start": 73, "char_end": 150, "line": "                   int32_t leftoverblock, int32_t ntbytes, int32_t destsize,\n"}, {"line_no": 68, "char_start": 2476, "char_end": 2508, "line": "      if (ntbytes > destsize) {\n"}, {"line_no": 69, "char_start": 2508, "char_end": 2574, "line": "        /* Not enough space to write out compressed block size */\n"}, {"line_no": 70, "char_start": 2574, "char_end": 2593, "line": "        return -1;\n"}, {"line_no": 71, "char_start": 2593, "char_end": 2601, "line": "      }\n"}, {"line_no": 82, "char_start": 2854, "char_end": 2893, "line": "    if (ntbytes + maxout > destsize) {\n"}, {"line_no": 84, "char_start": 2928, "char_end": 2981, "line": "      maxout = (int64_t)destsize - (int64_t)ntbytes;\n"}, {"line_no": 159, "char_start": 5947, "char_end": 5993, "line": "        if ((ntbytes + neblock) > destsize) {\n"}]}, "char_changes": {"deleted": [{"char_start": 140, "char_end": 146, "chars": "maxbyt"}, {"char_start": 2756, "char_end": 2762, "chars": "maxbyt"}, {"char_start": 2827, "char_end": 2833, "chars": "maxbyt"}, {"char_start": 5856, "char_end": 5862, "chars": "maxbyt"}], "added": [{"char_start": 140, "char_end": 143, "chars": "des"}, {"char_start": 144, "char_end": 147, "chars": "siz"}, {"char_start": 2482, "char_end": 2607, "chars": "if (ntbytes > destsize) {\n        /* Not enough space to write out compressed block size */\n        return -1;\n      }\n      "}, {"char_start": 2881, "char_end": 2884, "chars": "des"}, {"char_start": 2885, "char_end": 2888, "chars": "siz"}, {"char_start": 2952, "char_end": 2955, "chars": "des"}, {"char_start": 2956, "char_end": 2959, "chars": "siz"}, {"char_start": 5981, "char_end": 5984, "chars": "des"}, {"char_start": 5985, "char_end": 5988, "chars": "siz"}]}, "commit_link": "github.com/Blosc/c-blosc2/commit/c4c6470e88210afc95262c8b9fcc27e30ca043ee", "file_name": "blosc/blosc2.c", "vul_type": "cwe-787"}
{"func_name": "re2c::Scanner::fill", "func_src_before": "bool Scanner::fill(size_t need)\n{\n    if (eof) return false;\n\n    pop_finished_files();\n\n    DASSERT(bot <= tok && tok <= lim);\n    size_t free = static_cast<size_t>(tok - bot);\n    size_t copy = static_cast<size_t>(lim - tok);\n\n    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - bot);\n        delete [] bot;\n        bot = buf;\n\n        free = BSIZE - copy;\n    }\n\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n\n    return true;\n}", "func_src_after": "bool Scanner::fill(size_t need)\n{\n    if (eof) return false;\n\n    pop_finished_files();\n\n    DASSERT(bot <= tok && tok <= lim);\n    size_t free = static_cast<size_t>(tok - bot);\n    size_t copy = static_cast<size_t>(lim - tok);\n\n    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - tok);\n        delete [] bot;\n        bot = buf;\n\n        free = BSIZE - copy;\n    }\n\n    DASSERT(lim + free <= bot + BSIZE);\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n\n    return true;\n}", "line_changes": {"deleted": [{"line_no": 21, "char_start": 529, "char_end": 569, "line": "        shift_ptrs_and_fpos(buf - bot);\n"}], "added": [{"line_no": 21, "char_start": 529, "char_end": 569, "line": "        shift_ptrs_and_fpos(buf - tok);\n"}, {"line_no": 28, "char_start": 648, "char_end": 688, "line": "    DASSERT(lim + free <= bot + BSIZE);\n"}]}, "char_changes": {"deleted": [{"char_start": 563, "char_end": 565, "chars": "bo"}], "added": [{"char_start": 563, "char_end": 564, "chars": "t"}, {"char_start": 565, "char_end": 566, "chars": "k"}, {"char_start": 647, "char_end": 687, "chars": "\n    DASSERT(lim + free <= bot + BSIZE);"}]}, "commit_link": "github.com/skvadrik/re2c/commit/c4603ba5ce229db83a2a4fb93e6d4b4e3ec3776a", "file_name": "src/parse/scanner.cc", "vul_type": "cwe-787"}
{"func_name": "input_csi_dispatch_sgr_colon", "func_src_before": "input_csi_dispatch_sgr_colon(struct input_ctx *ictx, u_int i)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tchar\t\t\t*s = ictx->param_list[i].str, *copy, *ptr, *out;\n\tint\t\t\t p[8];\n\tu_int\t\t\t n;\n\tconst char\t\t*errstr;\n\n\tfor (n = 0; n < nitems(p); n++)\n\t\tp[n] = -1;\n\tn = 0;\n\n\tptr = copy = xstrdup(s);\n\twhile ((out = strsep(&ptr, \":\")) != NULL) {\n\t\tif (*out != '\\0') {\n\t\t\tp[n++] = strtonum(out, 0, INT_MAX, &errstr);\n\t\t\tif (errstr != NULL || n == nitems(p)) {\n\t\t\t\tfree(copy);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else\n\t\t\tn++;\n\t\tlog_debug(\"%s: %u = %d\", __func__, n - 1, p[n - 1]);\n\t}\n\tfree(copy);\n\n\tif (n == 0)\n\t\treturn;\n\tif (p[0] == 4) {\n\t\tif (n != 2)\n\t\t\treturn;\n\t\tswitch (p[1]) {\n\t\tcase 0:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_4;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_5;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tif (n < 2 || (p[0] != 38 && p[0] != 48 && p[0] != 58))\n\t\treturn;\n\tswitch (p[1]) {\n\tcase 2:\n\t\tif (n < 3)\n\t\t\tbreak;\n\t\tif (n == 5)\n\t\t\ti = 2;\n\t\telse\n\t\t\ti = 3;\n\t\tif (n < i + 3)\n\t\t\tbreak;\n\t\tinput_csi_dispatch_sgr_rgb_do(ictx, p[0], p[i], p[i + 1],\n\t\t    p[i + 2]);\n\t\tbreak;\n\tcase 5:\n\t\tif (n < 3)\n\t\t\tbreak;\n\t\tinput_csi_dispatch_sgr_256_do(ictx, p[0], p[2]);\n\t\tbreak;\n\t}\n}", "func_src_after": "input_csi_dispatch_sgr_colon(struct input_ctx *ictx, u_int i)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tchar\t\t\t*s = ictx->param_list[i].str, *copy, *ptr, *out;\n\tint\t\t\t p[8];\n\tu_int\t\t\t n;\n\tconst char\t\t*errstr;\n\n\tfor (n = 0; n < nitems(p); n++)\n\t\tp[n] = -1;\n\tn = 0;\n\n\tptr = copy = xstrdup(s);\n\twhile ((out = strsep(&ptr, \":\")) != NULL) {\n\t\tif (*out != '\\0') {\n\t\t\tp[n++] = strtonum(out, 0, INT_MAX, &errstr);\n\t\t\tif (errstr != NULL || n == nitems(p)) {\n\t\t\t\tfree(copy);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tn++;\n\t\t\tif (n == nitems(p)) {\n\t\t\t\tfree(copy);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tlog_debug(\"%s: %u = %d\", __func__, n - 1, p[n - 1]);\n\t}\n\tfree(copy);\n\n\tif (n == 0)\n\t\treturn;\n\tif (p[0] == 4) {\n\t\tif (n != 2)\n\t\t\treturn;\n\t\tswitch (p[1]) {\n\t\tcase 0:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_4;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_5;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tif (n < 2 || (p[0] != 38 && p[0] != 48 && p[0] != 58))\n\t\treturn;\n\tswitch (p[1]) {\n\tcase 2:\n\t\tif (n < 3)\n\t\t\tbreak;\n\t\tif (n == 5)\n\t\t\ti = 2;\n\t\telse\n\t\t\ti = 3;\n\t\tif (n < i + 3)\n\t\t\tbreak;\n\t\tinput_csi_dispatch_sgr_rgb_do(ictx, p[0], p[i], p[i + 1],\n\t\t    p[i + 2]);\n\t\tbreak;\n\tcase 5:\n\t\tif (n < 3)\n\t\t\tbreak;\n\t\tinput_csi_dispatch_sgr_256_do(ictx, p[0], p[2]);\n\t\tbreak;\n\t}\n}", "line_changes": {"deleted": [{"line_no": 21, "char_start": 485, "char_end": 494, "line": "\t\t} else\n"}], "added": [{"line_no": 21, "char_start": 485, "char_end": 496, "line": "\t\t} else {\n"}, {"line_no": 23, "char_start": 504, "char_end": 529, "line": "\t\t\tif (n == nitems(p)) {\n"}, {"line_no": 24, "char_start": 529, "char_end": 545, "line": "\t\t\t\tfree(copy);\n"}, {"line_no": 25, "char_start": 545, "char_end": 557, "line": "\t\t\t\treturn;\n"}, {"line_no": 26, "char_start": 557, "char_end": 562, "line": "\t\t\t}\n"}, {"line_no": 27, "char_start": 562, "char_end": 566, "line": "\t\t}\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 493, "char_end": 495, "chars": " {"}, {"char_start": 503, "char_end": 565, "chars": "\n\t\t\tif (n == nitems(p)) {\n\t\t\t\tfree(copy);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}"}]}, "commit_link": "github.com/tmux/tmux/commit/a868bacb46e3c900530bed47a1c6f85b0fbe701c", "file_name": "input.c", "vul_type": "cwe-787"}
{"func_name": "enl_ipc_get", "func_src_before": "char *enl_ipc_get(const char *msg_data)\n{\n\n\tstatic char *message = NULL;\n\tstatic unsigned short len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}", "func_src_after": "char *enl_ipc_get(const char *msg_data)\n{\n\n\tstatic char *message = NULL;\n\tstatic size_t len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}", "line_changes": {"deleted": [{"line_no": 5, "char_start": 73, "char_end": 105, "line": "\tstatic unsigned short len = 0;\n"}], "added": [{"line_no": 5, "char_start": 73, "char_end": 97, "line": "\tstatic size_t len = 0;\n"}]}, "char_changes": {"deleted": [{"char_start": 81, "char_end": 83, "chars": "un"}, {"char_start": 85, "char_end": 87, "chars": "gn"}, {"char_start": 88, "char_end": 94, "chars": "d shor"}], "added": [{"char_start": 83, "char_end": 84, "chars": "z"}, {"char_start": 85, "char_end": 86, "chars": "_"}]}, "commit_link": "github.com/derf/feh/commit/f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d", "file_name": "src/wallpaper.c", "vul_type": "cwe-787"}
{"func_name": "xdp_umem_reg", "func_src_before": "static int xdp_umem_reg(struct xdp_umem *umem, struct xdp_umem_reg *mr)\n{\n\tbool unaligned_chunks = mr->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;\n\tu32 chunk_size = mr->chunk_size, headroom = mr->headroom;\n\tunsigned int chunks, chunks_per_page;\n\tu64 addr = mr->addr, size = mr->len;\n\tint size_chk, err;\n\n\tif (chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE) {\n\t\t/* Strictly speaking we could support this, if:\n\t\t * - huge pages, or*\n\t\t * - using an IOMMU, or\n\t\t * - making sure the memory area is consecutive\n\t\t * but for now, we simply say \"computer says no\".\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif (mr->flags & ~(XDP_UMEM_UNALIGNED_CHUNK_FLAG |\n\t\t\tXDP_UMEM_USES_NEED_WAKEUP))\n\t\treturn -EINVAL;\n\n\tif (!unaligned_chunks && !is_power_of_2(chunk_size))\n\t\treturn -EINVAL;\n\n\tif (!PAGE_ALIGNED(addr)) {\n\t\t/* Memory area has to be page size aligned. For\n\t\t * simplicity, this might change.\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif ((addr + size) < addr)\n\t\treturn -EINVAL;\n\n\tchunks = (unsigned int)div_u64(size, chunk_size);\n\tif (chunks == 0)\n\t\treturn -EINVAL;\n\n\tif (!unaligned_chunks) {\n\t\tchunks_per_page = PAGE_SIZE / chunk_size;\n\t\tif (chunks < chunks_per_page || chunks % chunks_per_page)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsize_chk = chunk_size - headroom - XDP_PACKET_HEADROOM;\n\tif (size_chk < 0)\n\t\treturn -EINVAL;\n\n\tumem->address = (unsigned long)addr;\n\tumem->chunk_mask = unaligned_chunks ? XSK_UNALIGNED_BUF_ADDR_MASK\n\t\t\t\t\t    : ~((u64)chunk_size - 1);\n\tumem->size = size;\n\tumem->headroom = headroom;\n\tumem->chunk_size_nohr = chunk_size - headroom;\n\tumem->npgs = size / PAGE_SIZE;\n\tumem->pgs = NULL;\n\tumem->user = NULL;\n\tumem->flags = mr->flags;\n\tINIT_LIST_HEAD(&umem->xsk_list);\n\tspin_lock_init(&umem->xsk_list_lock);\n\n\trefcount_set(&umem->users, 1);\n\n\terr = xdp_umem_account_pages(umem);\n\tif (err)\n\t\treturn err;\n\n\terr = xdp_umem_pin_pages(umem);\n\tif (err)\n\t\tgoto out_account;\n\n\tumem->pages = kvcalloc(umem->npgs, sizeof(*umem->pages),\n\t\t\t       GFP_KERNEL_ACCOUNT);\n\tif (!umem->pages) {\n\t\terr = -ENOMEM;\n\t\tgoto out_pin;\n\t}\n\n\terr = xdp_umem_map_pages(umem);\n\tif (!err)\n\t\treturn 0;\n\n\tkvfree(umem->pages);\n\nout_pin:\n\txdp_umem_unpin_pages(umem);\nout_account:\n\txdp_umem_unaccount_pages(umem);\n\treturn err;\n}", "func_src_after": "static int xdp_umem_reg(struct xdp_umem *umem, struct xdp_umem_reg *mr)\n{\n\tbool unaligned_chunks = mr->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;\n\tu32 chunk_size = mr->chunk_size, headroom = mr->headroom;\n\tunsigned int chunks, chunks_per_page;\n\tu64 addr = mr->addr, size = mr->len;\n\tint err;\n\n\tif (chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE) {\n\t\t/* Strictly speaking we could support this, if:\n\t\t * - huge pages, or*\n\t\t * - using an IOMMU, or\n\t\t * - making sure the memory area is consecutive\n\t\t * but for now, we simply say \"computer says no\".\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif (mr->flags & ~(XDP_UMEM_UNALIGNED_CHUNK_FLAG |\n\t\t\tXDP_UMEM_USES_NEED_WAKEUP))\n\t\treturn -EINVAL;\n\n\tif (!unaligned_chunks && !is_power_of_2(chunk_size))\n\t\treturn -EINVAL;\n\n\tif (!PAGE_ALIGNED(addr)) {\n\t\t/* Memory area has to be page size aligned. For\n\t\t * simplicity, this might change.\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif ((addr + size) < addr)\n\t\treturn -EINVAL;\n\n\tchunks = (unsigned int)div_u64(size, chunk_size);\n\tif (chunks == 0)\n\t\treturn -EINVAL;\n\n\tif (!unaligned_chunks) {\n\t\tchunks_per_page = PAGE_SIZE / chunk_size;\n\t\tif (chunks < chunks_per_page || chunks % chunks_per_page)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (headroom >= chunk_size - XDP_PACKET_HEADROOM)\n\t\treturn -EINVAL;\n\n\tumem->address = (unsigned long)addr;\n\tumem->chunk_mask = unaligned_chunks ? XSK_UNALIGNED_BUF_ADDR_MASK\n\t\t\t\t\t    : ~((u64)chunk_size - 1);\n\tumem->size = size;\n\tumem->headroom = headroom;\n\tumem->chunk_size_nohr = chunk_size - headroom;\n\tumem->npgs = size / PAGE_SIZE;\n\tumem->pgs = NULL;\n\tumem->user = NULL;\n\tumem->flags = mr->flags;\n\tINIT_LIST_HEAD(&umem->xsk_list);\n\tspin_lock_init(&umem->xsk_list_lock);\n\n\trefcount_set(&umem->users, 1);\n\n\terr = xdp_umem_account_pages(umem);\n\tif (err)\n\t\treturn err;\n\n\terr = xdp_umem_pin_pages(umem);\n\tif (err)\n\t\tgoto out_account;\n\n\tumem->pages = kvcalloc(umem->npgs, sizeof(*umem->pages),\n\t\t\t       GFP_KERNEL_ACCOUNT);\n\tif (!umem->pages) {\n\t\terr = -ENOMEM;\n\t\tgoto out_pin;\n\t}\n\n\terr = xdp_umem_map_pages(umem);\n\tif (!err)\n\t\treturn 0;\n\n\tkvfree(umem->pages);\n\nout_pin:\n\txdp_umem_unpin_pages(umem);\nout_account:\n\txdp_umem_unaccount_pages(umem);\n\treturn err;\n}", "line_changes": {"deleted": [{"line_no": 7, "char_start": 278, "char_end": 298, "line": "\tint size_chk, err;\n"}, {"line_no": 46, "char_start": 1202, "char_end": 1259, "line": "\tsize_chk = chunk_size - headroom - XDP_PACKET_HEADROOM;\n"}, {"line_no": 47, "char_start": 1259, "char_end": 1278, "line": "\tif (size_chk < 0)\n"}], "added": [{"line_no": 7, "char_start": 278, "char_end": 288, "line": "\tint err;\n"}, {"line_no": 46, "char_start": 1192, "char_end": 1243, "line": "\tif (headroom >= chunk_size - XDP_PACKET_HEADROOM)\n"}]}, "char_changes": {"deleted": [{"char_start": 283, "char_end": 293, "chars": "size_chk, "}, {"char_start": 1203, "char_end": 1204, "chars": "s"}, {"char_start": 1205, "char_end": 1209, "chars": "ze_c"}, {"char_start": 1210, "char_end": 1211, "chars": "k"}, {"char_start": 1227, "char_end": 1238, "chars": "headroom - "}, {"char_start": 1257, "char_end": 1276, "chars": ";\n\tif (size_chk < 0"}], "added": [{"char_start": 1194, "char_end": 1198, "chars": "f (h"}, {"char_start": 1199, "char_end": 1205, "chars": "adroom"}, {"char_start": 1206, "char_end": 1207, "chars": ">"}]}, "commit_link": "github.com/torvalds/linux/commit/99e3a236dd43d06c65af0a2ef9cb44306aef6e02", "file_name": "net/xdp/xdp_umem.c", "vul_type": "cwe-787"}
{"func_name": "gps_tracker", "func_src_before": "void gps_tracker( void )\n{\n\tssize_t unused;\n    int gpsd_sock;\n    char line[256], *temp;\n    struct sockaddr_in gpsd_addr;\n    int ret, is_json, pos;\n    fd_set read_fd;\n    struct timeval timeout;\n\n    /* attempt to connect to localhost, port 2947 */\n\n    pos = 0;\n    gpsd_sock = socket( AF_INET, SOCK_STREAM, 0 );\n\n    if( gpsd_sock < 0 ) {\n        return;\n    }\n\n    gpsd_addr.sin_family      = AF_INET;\n    gpsd_addr.sin_port        = htons( 2947 );\n    gpsd_addr.sin_addr.s_addr = inet_addr( \"127.0.0.1\" );\n\n    if( connect( gpsd_sock, (struct sockaddr *) &gpsd_addr,\n                 sizeof( gpsd_addr ) ) < 0 ) {\n        return;\n    }\n\n    // Check if it's GPSd < 2.92 or the new one\n    // 2.92+ immediately send stuff\n    // < 2.92 requires to send PVTAD command\n    FD_ZERO(&read_fd);\n    FD_SET(gpsd_sock, &read_fd);\n    timeout.tv_sec = 1;\n    timeout.tv_usec = 0;\n    is_json = select(gpsd_sock + 1, &read_fd, NULL, NULL, &timeout);\n    if (is_json) {\n    \t/*\n\t\t\t{\"class\":\"VERSION\",\"release\":\"2.95\",\"rev\":\"2010-11-16T21:12:35\",\"proto_major\":3,\"proto_minor\":3}\n\t\t\t?WATCH={\"json\":true};\n\t\t\t{\"class\":\"DEVICES\",\"devices\":[]}\n    \t */\n\n\n    \t// Get the crap and ignore it: {\"class\":\"VERSION\",\"release\":\"2.95\",\"rev\":\"2010-11-16T21:12:35\",\"proto_major\":3,\"proto_minor\":3}\n    \tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n    \t\treturn;\n\n    \tis_json = (line[0] == '{');\n    \tif (is_json) {\n\t\t\t// Send ?WATCH={\"json\":true};\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tstrcpy(line, \"?WATCH={\\\"json\\\":true};\\n\");\n\t\t\tif( send( gpsd_sock, line, 22, 0 ) != 22 )\n\t\t\t\treturn;\n\n\t\t\t// Check that we have devices\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n\t\t\t\treturn;\n\n\t\t\t// Stop processing if there is no device\n\t\t\tif (strncmp(line, \"{\\\"class\\\":\\\"DEVICES\\\",\\\"devices\\\":[]}\", 32) == 0) {\n\t\t\t\tclose(gpsd_sock);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpos = strlen(line);\n\t\t\t}\n    \t}\n    }\n\n    /* loop reading the GPS coordinates */\n\n    while( G.do_exit == 0 )\n    {\n        usleep( 500000 );\n        memset( G.gps_loc, 0, sizeof( float ) * 5 );\n\n        /* read position, speed, heading, altitude */\n        if (is_json) {\n        \t// Format definition: http://catb.org/gpsd/gpsd_json.html\n\n        \tif (pos == sizeof( line )) {\n        \t\tmemset(line, 0, sizeof(line));\n        \t\tpos = 0;\n        \t}\n\n        \t// New version, JSON\n        \tif( recv( gpsd_sock, line + pos, sizeof( line ) - 1, 0 ) <= 0 )\n        \t\treturn;\n\n        \t// search for TPV class: {\"class\":\"TPV\"\n        \ttemp = strstr(line, \"{\\\"class\\\":\\\"TPV\\\"\");\n        \tif (temp == NULL) {\n        \t\tcontinue;\n        \t}\n\n        \t// Make sure the data we have is complete\n        \tif (strchr(temp, '}') == NULL) {\n        \t\t// Move the data at the beginning of the buffer;\n        \t\tpos = strlen(temp);\n        \t\tif (temp != line) {\n        \t\t\tmemmove(line, temp, pos);\n        \t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n        \t\t}\n        \t}\n\n\t\t\t// Example line: {\"class\":\"TPV\",\"tag\":\"MID2\",\"device\":\"/dev/ttyUSB0\",\"time\":1350957517.000,\"ept\":0.005,\"lat\":46.878936576,\"lon\":-115.832602964,\"alt\":1968.382,\"track\":0.0000,\"speed\":0.000,\"climb\":0.000,\"mode\":3}\n\n        \t// Latitude\n        \ttemp = strstr(temp, \"\\\"lat\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[0]);\n\n\t\t\t// Longitude\n\t\t\ttemp = strstr(temp, \"\\\"lon\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[1]);\n\n\t\t\t// Altitude\n\t\t\ttemp = strstr(temp, \"\\\"alt\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[4]);\n\n\t\t\t// Speed\n\t\t\ttemp = strstr(temp, \"\\\"speed\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[2]);\n\n\t\t\t// No more heading\n\n\t\t\t// Get the next TPV class\n\t\t\ttemp = strstr(temp, \"{\\\"class\\\":\\\"TPV\\\"\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\t\tpos = 0;\n\t\t\t} else {\n\t\t\t\tpos = strlen(temp);\n\t\t\t\tmemmove(line, temp, pos);\n\t\t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n\t\t\t}\n\n        } else {\n        \tmemset( line, 0, sizeof( line ) );\n\n\t\t\tsnprintf( line,  sizeof( line ) - 1, \"PVTAD\\r\\n\" );\n\t\t\tif( send( gpsd_sock, line, 7, 0 ) != 7 )\n\t\t\t\treturn;\n\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n\t\t\t\treturn;\n\n\t\t\tif( memcmp( line, \"GPSD,P=\", 7 ) != 0 )\n\t\t\t\tcontinue;\n\n\t\t\t/* make sure the coordinates are present */\n\n\t\t\tif( line[7] == '?' )\n\t\t\t\tcontinue;\n\n\t\t\tret = sscanf( line + 7, \"%f %f\", &G.gps_loc[0], &G.gps_loc[1] );\n\n\t\t\tif( ( temp = strstr( line, \"V=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[2] ); /* speed */\n\n\t\t\tif( ( temp = strstr( line, \"T=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[3] ); /* heading */\n\n\t\t\tif( ( temp = strstr( line, \"A=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[4] ); /* altitude */\n        }\n\n        if (G.record_data)\n\t\t\tfputs( line, G.f_gps );\n\n\t\tG.save_gps = 1;\n\n        if (G.do_exit == 0)\n\t\t{\n\t\t\tunused = write( G.gc_pipe[1], G.gps_loc, sizeof( float ) * 5 );\n\t\t\tkill( getppid(), SIGUSR2 );\n\t\t}\n    }\n}", "func_src_after": "void gps_tracker( void )\n{\n\tssize_t unused;\n    int gpsd_sock;\n    char line[256], *temp;\n    struct sockaddr_in gpsd_addr;\n    int ret, is_json, pos;\n    fd_set read_fd;\n    struct timeval timeout;\n\n    /* attempt to connect to localhost, port 2947 */\n\n    pos = 0;\n    gpsd_sock = socket( AF_INET, SOCK_STREAM, 0 );\n\n    if( gpsd_sock < 0 ) {\n        return;\n    }\n\n    gpsd_addr.sin_family      = AF_INET;\n    gpsd_addr.sin_port        = htons( 2947 );\n    gpsd_addr.sin_addr.s_addr = inet_addr( \"127.0.0.1\" );\n\n    if( connect( gpsd_sock, (struct sockaddr *) &gpsd_addr,\n                 sizeof( gpsd_addr ) ) < 0 ) {\n        return;\n    }\n\n    // Check if it's GPSd < 2.92 or the new one\n    // 2.92+ immediately send stuff\n    // < 2.92 requires to send PVTAD command\n    FD_ZERO(&read_fd);\n    FD_SET(gpsd_sock, &read_fd);\n    timeout.tv_sec = 1;\n    timeout.tv_usec = 0;\n    is_json = select(gpsd_sock + 1, &read_fd, NULL, NULL, &timeout);\n    if (is_json) {\n    \t/*\n\t\t\t{\"class\":\"VERSION\",\"release\":\"2.95\",\"rev\":\"2010-11-16T21:12:35\",\"proto_major\":3,\"proto_minor\":3}\n\t\t\t?WATCH={\"json\":true};\n\t\t\t{\"class\":\"DEVICES\",\"devices\":[]}\n    \t */\n\n\n    \t// Get the crap and ignore it: {\"class\":\"VERSION\",\"release\":\"2.95\",\"rev\":\"2010-11-16T21:12:35\",\"proto_major\":3,\"proto_minor\":3}\n    \tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n    \t\treturn;\n\n    \tis_json = (line[0] == '{');\n    \tif (is_json) {\n\t\t\t// Send ?WATCH={\"json\":true};\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tstrcpy(line, \"?WATCH={\\\"json\\\":true};\\n\");\n\t\t\tif( send( gpsd_sock, line, 22, 0 ) != 22 )\n\t\t\t\treturn;\n\n\t\t\t// Check that we have devices\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n\t\t\t\treturn;\n\n\t\t\t// Stop processing if there is no device\n\t\t\tif (strncmp(line, \"{\\\"class\\\":\\\"DEVICES\\\",\\\"devices\\\":[]}\", 32) == 0) {\n\t\t\t\tclose(gpsd_sock);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpos = strlen(line);\n\t\t\t}\n    \t}\n    }\n\n    /* loop reading the GPS coordinates */\n\n    while( G.do_exit == 0 )\n    {\n        usleep( 500000 );\n        memset( G.gps_loc, 0, sizeof( float ) * 5 );\n\n        /* read position, speed, heading, altitude */\n        if (is_json) {\n        \t// Format definition: http://catb.org/gpsd/gpsd_json.html\n\n        \tif (pos == sizeof( line )) {\n        \t\tmemset(line, 0, sizeof(line));\n        \t\tpos = 0;\n        \t}\n\n        \t// New version, JSON\n        \tif( recv( gpsd_sock, line + pos, sizeof( line ) - pos - 1, 0 ) <= 0 )\n        \t\treturn;\n\n        \t// search for TPV class: {\"class\":\"TPV\"\n        \ttemp = strstr(line, \"{\\\"class\\\":\\\"TPV\\\"\");\n        \tif (temp == NULL) {\n        \t\tcontinue;\n        \t}\n\n        \t// Make sure the data we have is complete\n        \tif (strchr(temp, '}') == NULL) {\n        \t\t// Move the data at the beginning of the buffer;\n        \t\tpos = strlen(temp);\n        \t\tif (temp != line) {\n        \t\t\tmemmove(line, temp, pos);\n        \t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n        \t\t}\n        \t}\n\n\t\t\t// Example line: {\"class\":\"TPV\",\"tag\":\"MID2\",\"device\":\"/dev/ttyUSB0\",\"time\":1350957517.000,\"ept\":0.005,\"lat\":46.878936576,\"lon\":-115.832602964,\"alt\":1968.382,\"track\":0.0000,\"speed\":0.000,\"climb\":0.000,\"mode\":3}\n\n        \t// Latitude\n        \ttemp = strstr(temp, \"\\\"lat\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[0]);\n\n\t\t\t// Longitude\n\t\t\ttemp = strstr(temp, \"\\\"lon\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[1]);\n\n\t\t\t// Altitude\n\t\t\ttemp = strstr(temp, \"\\\"alt\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[4]);\n\n\t\t\t// Speed\n\t\t\ttemp = strstr(temp, \"\\\"speed\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[2]);\n\n\t\t\t// No more heading\n\n\t\t\t// Get the next TPV class\n\t\t\ttemp = strstr(temp, \"{\\\"class\\\":\\\"TPV\\\"\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\t\tpos = 0;\n\t\t\t} else {\n\t\t\t\tpos = strlen(temp);\n\t\t\t\tmemmove(line, temp, pos);\n\t\t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n\t\t\t}\n\n        } else {\n        \tmemset( line, 0, sizeof( line ) );\n\n\t\t\tsnprintf( line,  sizeof( line ) - 1, \"PVTAD\\r\\n\" );\n\t\t\tif( send( gpsd_sock, line, 7, 0 ) != 7 )\n\t\t\t\treturn;\n\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n\t\t\t\treturn;\n\n\t\t\tif( memcmp( line, \"GPSD,P=\", 7 ) != 0 )\n\t\t\t\tcontinue;\n\n\t\t\t/* make sure the coordinates are present */\n\n\t\t\tif( line[7] == '?' )\n\t\t\t\tcontinue;\n\n\t\t\tret = sscanf( line + 7, \"%f %f\", &G.gps_loc[0], &G.gps_loc[1] );\n\n\t\t\tif( ( temp = strstr( line, \"V=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[2] ); /* speed */\n\n\t\t\tif( ( temp = strstr( line, \"T=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[3] ); /* heading */\n\n\t\t\tif( ( temp = strstr( line, \"A=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[4] ); /* altitude */\n        }\n\n        if (G.record_data)\n\t\t\tfputs( line, G.f_gps );\n\n\t\tG.save_gps = 1;\n\n        if (G.do_exit == 0)\n\t\t{\n\t\t\tunused = write( G.gc_pipe[1], G.gps_loc, sizeof( float ) * 5 );\n\t\t\tkill( getppid(), SIGUSR2 );\n\t\t}\n    }\n}", "line_changes": {"deleted": [{"line_no": 89, "char_start": 2379, "char_end": 2452, "line": "        \tif( recv( gpsd_sock, line + pos, sizeof( line ) - 1, 0 ) <= 0 )\n"}], "added": [{"line_no": 89, "char_start": 2379, "char_end": 2458, "line": "        \tif( recv( gpsd_sock, line + pos, sizeof( line ) - pos - 1, 0 ) <= 0 )\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 2438, "char_end": 2444, "chars": "pos - "}]}, "commit_link": "github.com/aircrack-ng/aircrack-ng/commit/ff70494dd389ba570dbdbf36f217c28d4381c6b5/", "file_name": "src/airodump-ng.c", "vul_type": "cwe-787"}
{"func_name": "tcp_test", "func_src_before": "int tcp_test(const char* ip_str, const short port)\n{\n    int sock, i;\n    struct sockaddr_in s_in;\n    int packetsize = 1024;\n    unsigned char packet[packetsize];\n    struct timeval tv, tv2, tv3;\n    int caplen = 0;\n    int times[REQUESTS];\n    int min, avg, max, len;\n    struct net_hdr nh;\n\n    tv3.tv_sec=0;\n    tv3.tv_usec=1;\n\n    s_in.sin_family = PF_INET;\n    s_in.sin_port = htons(port);\n    if (!inet_aton(ip_str, &s_in.sin_addr))\n            return -1;\n\n    if ((sock = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)\n            return -1;\n\n    /* avoid blocking on reading the socket */\n    if( fcntl( sock, F_SETFL, O_NONBLOCK ) < 0 )\n    {\n        perror( \"fcntl(O_NONBLOCK) failed\" );\n        return( 1 );\n    }\n\n    gettimeofday( &tv, NULL );\n\n    while (1)  //waiting for relayed packet\n    {\n        if (connect(sock, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n        {\n            if(errno != EINPROGRESS && errno != EALREADY)\n            {\n                perror(\"connect\");\n                close(sock);\n\n                printf(\"Failed to connect\\n\");\n\n                return -1;\n            }\n        }\n        else\n        {\n            gettimeofday( &tv2, NULL );\n            break;\n        }\n\n        gettimeofday( &tv2, NULL );\n        //wait 3000ms for a successful connect\n        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (3000*1000))\n        {\n            printf(\"Connection timed out\\n\");\n            close(sock);\n            return(-1);\n        }\n        usleep(10);\n    }\n\n    PCT; printf(\"TCP connection successful\\n\");\n\n    //trying to identify airserv-ng\n    memset(&nh, 0, sizeof(nh));\n//     command: GET_CHAN\n    nh.nh_type\t= 2;\n    nh.nh_len\t= htonl(0);\n\n    if (send(sock, &nh, sizeof(nh), 0) != sizeof(nh))\n    {\n        perror(\"send\");\n        return -1;\n    }\n\n    gettimeofday( &tv, NULL );\n    i=0;\n\n    while (1)  //waiting for GET_CHAN answer\n    {\n        caplen = read(sock, &nh, sizeof(nh));\n\n        if(caplen == -1)\n        {\n            if( errno != EAGAIN )\n            {\n                perror(\"read\");\n                return -1;\n            }\n        }\n\n        if( (unsigned)caplen == sizeof(nh))\n        {\n            len = ntohl(nh.nh_len);\n            if( nh.nh_type == 1 && i==0 )\n            {\n                i=1;\n                caplen = read(sock, packet, len);\n                if(caplen == len)\n                {\n                    i=2;\n                    break;\n                }\n                else\n                {\n                    i=0;\n                }\n            }\n            else\n            {\n                caplen = read(sock, packet, len);\n            }\n        }\n\n        gettimeofday( &tv2, NULL );\n        //wait 1000ms for an answer\n        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1000*1000))\n        {\n            break;\n        }\n        if(caplen == -1)\n            usleep(10);\n    }\n\n    if(i==2)\n    {\n        PCT; printf(\"airserv-ng found\\n\");\n    }\n    else\n    {\n        PCT; printf(\"airserv-ng NOT found\\n\");\n    }\n\n    close(sock);\n\n    for(i=0; i<REQUESTS; i++)\n    {\n        if ((sock = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)\n                return -1;\n\n        /* avoid blocking on reading the socket */\n        if( fcntl( sock, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n\n        usleep(1000);\n\n        gettimeofday( &tv, NULL );\n\n        while (1)  //waiting for relayed packet\n        {\n            if (connect(sock, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n            {\n                if(errno != EINPROGRESS && errno != EALREADY)\n                {\n                    perror(\"connect\");\n                    close(sock);\n\n                    printf(\"Failed to connect\\n\");\n\n                    return -1;\n                }\n            }\n            else\n            {\n                gettimeofday( &tv2, NULL );\n                break;\n            }\n\n            gettimeofday( &tv2, NULL );\n            //wait 1000ms for a successful connect\n            if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1000*1000))\n            {\n                break;\n            }\n            //simple \"high-precision\" usleep\n            select(1, NULL, NULL, NULL, &tv3);\n        }\n        times[i] = ((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec));\n        printf( \"\\r%d/%d\\r\", i, REQUESTS);\n        fflush(stdout);\n        close(sock);\n    }\n\n    min = INT_MAX;\n    avg = 0;\n    max = 0;\n\n    for(i=0; i<REQUESTS; i++)\n    {\n        if(times[i] < min) min = times[i];\n        if(times[i] > max) max = times[i];\n        avg += times[i];\n    }\n    avg /= REQUESTS;\n\n    PCT; printf(\"ping %s:%d (min/avg/max): %.3fms/%.3fms/%.3fms\\n\", ip_str, port, min/1000.0, avg/1000.0, max/1000.0);\n\n    return 0;\n}", "func_src_after": "int tcp_test(const char* ip_str, const short port)\n{\n    int sock, i;\n    struct sockaddr_in s_in;\n    int packetsize = 1024;\n    unsigned char packet[packetsize];\n    struct timeval tv, tv2, tv3;\n    int caplen = 0;\n    int times[REQUESTS];\n    int min, avg, max, len;\n    struct net_hdr nh;\n\n    tv3.tv_sec=0;\n    tv3.tv_usec=1;\n\n    s_in.sin_family = PF_INET;\n    s_in.sin_port = htons(port);\n    if (!inet_aton(ip_str, &s_in.sin_addr))\n            return -1;\n\n    if ((sock = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)\n            return -1;\n\n    /* avoid blocking on reading the socket */\n    if( fcntl( sock, F_SETFL, O_NONBLOCK ) < 0 )\n    {\n        perror( \"fcntl(O_NONBLOCK) failed\" );\n        return( 1 );\n    }\n\n    gettimeofday( &tv, NULL );\n\n    while (1)  //waiting for relayed packet\n    {\n        if (connect(sock, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n        {\n            if(errno != EINPROGRESS && errno != EALREADY)\n            {\n                perror(\"connect\");\n                close(sock);\n\n                printf(\"Failed to connect\\n\");\n\n                return -1;\n            }\n        }\n        else\n        {\n            gettimeofday( &tv2, NULL );\n            break;\n        }\n\n        gettimeofday( &tv2, NULL );\n        //wait 3000ms for a successful connect\n        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (3000*1000))\n        {\n            printf(\"Connection timed out\\n\");\n            close(sock);\n            return(-1);\n        }\n        usleep(10);\n    }\n\n    PCT; printf(\"TCP connection successful\\n\");\n\n    //trying to identify airserv-ng\n    memset(&nh, 0, sizeof(nh));\n//     command: GET_CHAN\n    nh.nh_type\t= 2;\n    nh.nh_len\t= htonl(0);\n\n    if (send(sock, &nh, sizeof(nh), 0) != sizeof(nh))\n    {\n        perror(\"send\");\n        return -1;\n    }\n\n    gettimeofday( &tv, NULL );\n    i=0;\n\n    while (1)  //waiting for GET_CHAN answer\n    {\n        caplen = read(sock, &nh, sizeof(nh));\n\n        if(caplen == -1)\n        {\n            if( errno != EAGAIN )\n            {\n                perror(\"read\");\n                return -1;\n            }\n        }\n\n        if( (unsigned)caplen == sizeof(nh))\n        {\n            len = ntohl(nh.nh_len);\n            if (len > 1024 || len < 0)\n                continue;\n            if( nh.nh_type == 1 && i==0 )\n            {\n                i=1;\n                caplen = read(sock, packet, len);\n                if(caplen == len)\n                {\n                    i=2;\n                    break;\n                }\n                else\n                {\n                    i=0;\n                }\n            }\n            else\n            {\n                caplen = read(sock, packet, len);\n            }\n        }\n\n        gettimeofday( &tv2, NULL );\n        //wait 1000ms for an answer\n        if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1000*1000))\n        {\n            break;\n        }\n        if(caplen == -1)\n            usleep(10);\n    }\n\n    if(i==2)\n    {\n        PCT; printf(\"airserv-ng found\\n\");\n    }\n    else\n    {\n        PCT; printf(\"airserv-ng NOT found\\n\");\n    }\n\n    close(sock);\n\n    for(i=0; i<REQUESTS; i++)\n    {\n        if ((sock = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)\n                return -1;\n\n        /* avoid blocking on reading the socket */\n        if( fcntl( sock, F_SETFL, O_NONBLOCK ) < 0 )\n        {\n            perror( \"fcntl(O_NONBLOCK) failed\" );\n            return( 1 );\n        }\n\n        usleep(1000);\n\n        gettimeofday( &tv, NULL );\n\n        while (1)  //waiting for relayed packet\n        {\n            if (connect(sock, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n            {\n                if(errno != EINPROGRESS && errno != EALREADY)\n                {\n                    perror(\"connect\");\n                    close(sock);\n\n                    printf(\"Failed to connect\\n\");\n\n                    return -1;\n                }\n            }\n            else\n            {\n                gettimeofday( &tv2, NULL );\n                break;\n            }\n\n            gettimeofday( &tv2, NULL );\n            //wait 1000ms for a successful connect\n            if (((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec)) > (1000*1000))\n            {\n                break;\n            }\n            //simple \"high-precision\" usleep\n            select(1, NULL, NULL, NULL, &tv3);\n        }\n        times[i] = ((tv2.tv_sec*1000000 - tv.tv_sec*1000000) + (tv2.tv_usec - tv.tv_usec));\n        printf( \"\\r%d/%d\\r\", i, REQUESTS);\n        fflush(stdout);\n        close(sock);\n    }\n\n    min = INT_MAX;\n    avg = 0;\n    max = 0;\n\n    for(i=0; i<REQUESTS; i++)\n    {\n        if(times[i] < min) min = times[i];\n        if(times[i] > max) max = times[i];\n        avg += times[i];\n    }\n    avg /= REQUESTS;\n\n    PCT; printf(\"ping %s:%d (min/avg/max): %.3fms/%.3fms/%.3fms\\n\", ip_str, port, min/1000.0, avg/1000.0, max/1000.0);\n\n    return 0;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 97, "char_start": 2251, "char_end": 2290, "line": "            if (len > 1024 || len < 0)\n"}, {"line_no": 98, "char_start": 2290, "char_end": 2316, "line": "                continue;\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 2265, "char_end": 2330, "chars": " (len > 1024 || len < 0)\n                continue;\n            if"}]}, "commit_link": "github.com/aircrack-ng/aircrack-ng/commit/091b153f294b9b695b0b2831e65936438b550d7b", "file_name": "src/aireplay-ng.c", "vul_type": "cwe-787"}
{"func_name": "mapi_attr_read", "func_src_before": "mapi_attr_read (size_t len, unsigned char *buf)\n{\n    size_t idx = 0;\n    uint32 i,j;\n    assert(len > 4);\n    uint32 num_properties = GETINT32(buf+idx);\n    MAPI_Attr** attrs = CHECKED_XMALLOC (MAPI_Attr*, (num_properties + 1));\n\n    idx += 4;\n\n    if (!attrs) return NULL;\n    for (i = 0; i < num_properties; i++)\n    {\n\tMAPI_Attr* a = attrs[i] = CHECKED_XCALLOC(MAPI_Attr, 1);\n\tMAPI_Value* v = NULL;\n\n\tCHECKINT16(idx, len); a->type = GETINT16(buf+idx); idx += 2;\n\tCHECKINT16(idx, len); a->name = GETINT16(buf+idx); idx += 2;\n\n\t/* handle special case of GUID prefixed properties */\n\tif (a->name & GUID_EXISTS_FLAG)\n\t{\n\t    /* copy GUID */\n\t    a->guid = CHECKED_XMALLOC(GUID, 1);\n\t    copy_guid_from_buf(a->guid, buf+idx, len);\n\t    idx += sizeof (GUID);\n\n\t    CHECKINT32(idx, len); a->num_names = GETINT32(buf+idx); idx += 4;\n\t    if (a->num_names > 0)\n\t    {\n\t\t/* FIXME: do something useful here! */\n\t\tsize_t i;\n\n\t\ta->names = CHECKED_XCALLOC(VarLenData, a->num_names);\n\n\t\tfor (i = 0; i < a->num_names; i++)\n\t\t{\n\t\t    size_t j;\n\n\t\t    CHECKINT32(idx, len); a->names[i].len = GETINT32(buf+idx); idx += 4;\n\n\t\t    /* read the data into a buffer */\n\t\t    a->names[i].data \n\t\t\t= CHECKED_XMALLOC(unsigned char, a->names[i].len);\n\t\t    for (j = 0; j < (a->names[i].len >> 1); j++)\n\t\t\ta->names[i].data[j] = (buf+idx)[j*2];\n\n\t\t    /* But what are we going to do with it? */\n\t\t    \n\t\t    idx += pad_to_4byte(a->names[i].len);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t/* get the 'real' name */\n\t\tCHECKINT32(idx, len); a->name = GETINT32(buf+idx); idx+= 4;\n\t    }\n\t}\n\n\t/* \n\t * Multi-value types and string/object/binary types have\n\t * multiple values \n\t */\n\tif (a->type & MULTI_VALUE_FLAG ||\n\t    a->type == szMAPI_STRING ||\n\t    a->type == szMAPI_UNICODE_STRING ||\n\t    a->type == szMAPI_OBJECT ||\n\t    a->type == szMAPI_BINARY)\n\t{\n\t    CHECKINT32(idx, len); a->num_values = GETINT32(buf+idx);\n\t    idx += 4;\n\t}\n        else\n        {\n\t    a->num_values = 1;\n        }\n\n\t/* Amend the type in case of multi-value type */\n\tif (a->type & MULTI_VALUE_FLAG)\n\t{\n\t    a->type -= MULTI_VALUE_FLAG;\n\t}\n\n\n\tv = alloc_mapi_values (a);\n\n\tfor (j = 0; j < a->num_values; j++) \n\t{\n\t    switch (a->type)\n\t    {\n\t    case szMAPI_SHORT:\t/* 2 bytes */\n\t\tv->len = 2;\n\t\tCHECKINT16(idx, len); v->data.bytes2 = GETINT16(buf+idx);\n\t\tidx += 4;\t/* assume padding of 2, advance by 4! */\n\t\tbreak;\n\n\t    case szMAPI_INT:\t/* 4 bytes */\n\t\tv->len = 4;\n\t\tCHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);\n\t\tidx += 4;\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_FLOAT:\t/* 4 bytes */\n\t    case szMAPI_BOOLEAN: /* this should be 2 bytes + 2 padding */\n\t\tv->len = 4;\n\t\tCHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_SYSTIME: /* 8 bytes */\n\t\tv->len = 8;\n\t\tCHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);\n\t\tCHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);\n\t\tidx += 8;\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_DOUBLE:\t/* 8 bytes */\n\t    case szMAPI_APPTIME:\n\t    case szMAPI_CURRENCY:\n\t    case szMAPI_INT8BYTE:\n\t\tv->len = 8;\n\t\tCHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);\n\t\tCHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_CLSID:\n\t\tv->len = sizeof (GUID);\n\t\tcopy_guid_from_buf(&v->data.guid, buf+idx, len);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_STRING:\n\t    case szMAPI_UNICODE_STRING:\n\t    case szMAPI_OBJECT:\n\t    case szMAPI_BINARY:\n\t\tCHECKINT32(idx, len); v->len = GETINT32(buf+idx); idx += 4;\n\n\t\tif (a->type == szMAPI_UNICODE_STRING)\n\t\t{\n\t\t    v->data.buf = (unsigned char*)unicode_to_utf8(v->len, buf+idx);\n\t\t}\n\t\telse\n\t\t{\n\t\t    v->data.buf = CHECKED_XMALLOC(unsigned char, v->len);\n\t\t    memmove (v->data.buf, buf+idx, v->len);\n\t\t}\n\n\t\tidx += pad_to_4byte(v->len);\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_NULL:\t/* illegal in input tnef streams */\n\t    case szMAPI_ERROR:\n\t    case szMAPI_UNSPECIFIED:\n\t\tfprintf (stderr,\n\t\t\t \"Invalid attribute, input file may be corrupted\\n\");\n\t\tif (!ENCODE_SKIP) exit (1);\n\n\t\treturn NULL;\n\n\t    default:\t\t/* should never get here */\n\t\tfprintf (stderr,\n\t\t\t \"Undefined attribute, input file may be corrupted\\n\");\n\t\tif (!ENCODE_SKIP) exit (1);\n\n\t\treturn NULL;\n\n\t    }\n\t    if (DEBUG_ON) mapi_attr_dump (attrs[i]);\n\t}\n    }\n    attrs[i] = NULL;\n\n    return attrs;\n}", "func_src_after": "mapi_attr_read (size_t len, unsigned char *buf)\n{\n    size_t idx = 0;\n    uint32 i,j;\n    assert(len > 4);\n    uint32 num_properties = GETINT32(buf+idx);\n    assert((num_properties+1) != 0);\n    MAPI_Attr** attrs = CHECKED_XMALLOC (MAPI_Attr*, (num_properties + 1));\n\n    idx += 4;\n\n    if (!attrs) return NULL;\n    for (i = 0; i < num_properties; i++)\n    {\n\tMAPI_Attr* a = attrs[i] = CHECKED_XCALLOC(MAPI_Attr, 1);\n\tMAPI_Value* v = NULL;\n\n\tCHECKINT16(idx, len); a->type = GETINT16(buf+idx); idx += 2;\n\tCHECKINT16(idx, len); a->name = GETINT16(buf+idx); idx += 2;\n\n\t/* handle special case of GUID prefixed properties */\n\tif (a->name & GUID_EXISTS_FLAG)\n\t{\n\t    /* copy GUID */\n\t    a->guid = CHECKED_XMALLOC(GUID, 1);\n\t    copy_guid_from_buf(a->guid, buf+idx, len);\n\t    idx += sizeof (GUID);\n\n\t    CHECKINT32(idx, len); a->num_names = GETINT32(buf+idx); idx += 4;\n\t    if (a->num_names > 0)\n\t    {\n\t\t/* FIXME: do something useful here! */\n\t\tsize_t i;\n\n\t\ta->names = CHECKED_XCALLOC(VarLenData, a->num_names);\n\n\t\tfor (i = 0; i < a->num_names; i++)\n\t\t{\n\t\t    size_t j;\n\n\t\t    CHECKINT32(idx, len); a->names[i].len = GETINT32(buf+idx); idx += 4;\n\n\t\t    /* read the data into a buffer */\n\t\t    a->names[i].data \n\t\t\t= CHECKED_XMALLOC(unsigned char, a->names[i].len);\n\t\t    assert((idx+(a->names[i].len*2)) <= len);\n\t\t    for (j = 0; j < (a->names[i].len >> 1); j++)\n\t\t\ta->names[i].data[j] = (buf+idx)[j*2];\n\n\t\t    /* But what are we going to do with it? */\n\t\t    \n\t\t    idx += pad_to_4byte(a->names[i].len);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t/* get the 'real' name */\n\t\tCHECKINT32(idx, len); a->name = GETINT32(buf+idx); idx+= 4;\n\t    }\n\t}\n\n\t/* \n\t * Multi-value types and string/object/binary types have\n\t * multiple values \n\t */\n\tif (a->type & MULTI_VALUE_FLAG ||\n\t    a->type == szMAPI_STRING ||\n\t    a->type == szMAPI_UNICODE_STRING ||\n\t    a->type == szMAPI_OBJECT ||\n\t    a->type == szMAPI_BINARY)\n\t{\n\t    CHECKINT32(idx, len); a->num_values = GETINT32(buf+idx);\n\t    idx += 4;\n\t}\n        else\n        {\n\t    a->num_values = 1;\n        }\n\n\t/* Amend the type in case of multi-value type */\n\tif (a->type & MULTI_VALUE_FLAG)\n\t{\n\t    a->type -= MULTI_VALUE_FLAG;\n\t}\n\n\n\tv = alloc_mapi_values (a);\n\n\tfor (j = 0; j < a->num_values; j++) \n\t{\n\t    switch (a->type)\n\t    {\n\t    case szMAPI_SHORT:\t/* 2 bytes */\n\t\tv->len = 2;\n\t\tCHECKINT16(idx, len); v->data.bytes2 = GETINT16(buf+idx);\n\t\tidx += 4;\t/* assume padding of 2, advance by 4! */\n\t\tbreak;\n\n\t    case szMAPI_INT:\t/* 4 bytes */\n\t\tv->len = 4;\n\t\tCHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);\n\t\tidx += 4;\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_FLOAT:\t/* 4 bytes */\n\t    case szMAPI_BOOLEAN: /* this should be 2 bytes + 2 padding */\n\t\tv->len = 4;\n\t\tCHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_SYSTIME: /* 8 bytes */\n\t\tv->len = 8;\n\t\tCHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);\n\t\tCHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);\n\t\tidx += 8;\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_DOUBLE:\t/* 8 bytes */\n\t    case szMAPI_APPTIME:\n\t    case szMAPI_CURRENCY:\n\t    case szMAPI_INT8BYTE:\n\t\tv->len = 8;\n\t\tCHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);\n\t\tCHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_CLSID:\n\t\tv->len = sizeof (GUID);\n\t\tcopy_guid_from_buf(&v->data.guid, buf+idx, len);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_STRING:\n\t    case szMAPI_UNICODE_STRING:\n\t    case szMAPI_OBJECT:\n\t    case szMAPI_BINARY:\n\t\tCHECKINT32(idx, len); v->len = GETINT32(buf+idx); idx += 4;\n\n\t\tassert(v->len + idx <= len);\n\n\t\tif (a->type == szMAPI_UNICODE_STRING)\n\t\t{\n\t\t    assert(v->len != 0);\n\t\t    v->data.buf = (unsigned char*)unicode_to_utf8(v->len, buf+idx);\n\t\t}\n\t\telse\n\t\t{\n\t\t    v->data.buf = CHECKED_XMALLOC(unsigned char, v->len);\n\t\t    memmove (v->data.buf, buf+idx, v->len);\n\t\t}\n\n\t\tidx += pad_to_4byte(v->len);\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_NULL:\t/* illegal in input tnef streams */\n\t    case szMAPI_ERROR:\n\t    case szMAPI_UNSPECIFIED:\n\t\tfprintf (stderr,\n\t\t\t \"Invalid attribute, input file may be corrupted\\n\");\n\t\tif (!ENCODE_SKIP) exit (1);\n\n\t\treturn NULL;\n\n\t    default:\t\t/* should never get here */\n\t\tfprintf (stderr,\n\t\t\t \"Undefined attribute, input file may be corrupted\\n\");\n\t\tif (!ENCODE_SKIP) exit (1);\n\n\t\treturn NULL;\n\n\t    }\n\t    if (DEBUG_ON) mapi_attr_dump (attrs[i]);\n\t}\n    }\n    attrs[i] = NULL;\n\n    return attrs;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 7, "char_start": 154, "char_end": 191, "line": "    assert((num_properties+1) != 0);\n"}, {"line_no": 46, "char_start": 1263, "char_end": 1311, "line": "\t\t    assert((idx+(a->names[i].len*2)) <= len);\n"}, {"line_no": 143, "char_start": 3582, "char_end": 3613, "line": "\t\tassert(v->len + idx <= len);\n"}, {"line_no": 144, "char_start": 3613, "char_end": 3614, "line": "\n"}, {"line_no": 147, "char_start": 3658, "char_end": 3685, "line": "\t\t    assert(v->len != 0);\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 158, "char_end": 195, "chars": "assert((num_properties+1) != 0);\n    "}, {"char_start": 1257, "char_end": 1305, "chars": "len);\n\t\t    assert((idx+(a->names[i].len*2)) <= "}, {"char_start": 3584, "char_end": 3616, "chars": "assert(v->len + idx <= len);\n\n\t\t"}, {"char_start": 3657, "char_end": 3684, "chars": "\n\t\t    assert(v->len != 0);"}]}, "commit_link": "github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a", "file_name": "src/mapi_attr.c", "vul_type": "cwe-787"}
{"func_name": "WritePSDChannel", "func_src_before": "static size_t WritePSDChannel(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const QuantumType quantum_type, unsigned char *compact_pixels,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  ExceptionInfo *exception)\n{\n  int\n    y;\n\n  MagickBooleanType\n    monochrome;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count,\n    length;\n\n  unsigned char\n    *pixels;\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n\n#define CHUNK 16384\n\n  int\n    flush,\n    level;\n\n  unsigned char\n    *compressed_pixels;\n\n  z_stream\n    stream;\n\n  compressed_pixels=(unsigned char *) NULL;\n  flush=Z_NO_FLUSH;\n#endif\n  count=0;\n  if (separate != MagickFalse)\n    {\n      size_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,1);\n    }\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n    MagickTrue : MagickFalse;\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    return(0);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (next_image->compression == ZipCompression)\n    {\n      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,\n        sizeof(*compressed_pixels));\n      if (compressed_pixels == (unsigned char *) NULL)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n      ResetMagickMemory(&stream,0,sizeof(stream));\n      stream.data_type=Z_BINARY;\n      level=Z_DEFAULT_COMPRESSION;\n      if ((image_info->quality > 0 && image_info->quality < 10))\n        level=(int) image_info->quality;\n      if (deflateInit(&stream,level) != Z_OK)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n    }\n#endif\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (monochrome != MagickFalse)\n      for (i=0; i < (ssize_t) length; i++)\n        pixels[i]=(~pixels[i]);\n    if (next_image->compression == RLECompression)\n      {\n        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n          exception);\n        count+=WriteBlob(image,length,compact_pixels);\n        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);\n      }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n    else if (next_image->compression == ZipCompression)\n      {\n        stream.avail_in=(uInt) length;\n        stream.next_in=(Bytef *) pixels;\n        if (y == (ssize_t) next_image->rows-1)\n          flush=Z_FINISH;\n        do {\n            stream.avail_out=(uInt) CHUNK;\n            stream.next_out=(Bytef *) compressed_pixels;\n            if (deflate(&stream,flush) == Z_STREAM_ERROR)\n              break;\n            length=(size_t) CHUNK-stream.avail_out;\n            if (length > 0)\n              count+=WriteBlob(image,length,compressed_pixels);\n        } while (stream.avail_out == 0);\n      }\n#endif\n    else\n      count+=WriteBlob(image,length,pixels);\n  }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (next_image->compression == ZipCompression)\n    {\n      (void) deflateEnd(&stream);\n      compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n        compressed_pixels);\n    }\n#endif\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  return(count);\n}", "func_src_after": "static size_t WritePSDChannel(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const QuantumType quantum_type, unsigned char *compact_pixels,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  ExceptionInfo *exception)\n{\n  int\n    y;\n\n  MagickBooleanType\n    monochrome;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count,\n    length;\n\n  unsigned char\n    *pixels;\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n\n#define CHUNK 16384\n\n  int\n    flush,\n    level;\n\n  unsigned char\n    *compressed_pixels;\n\n  z_stream\n    stream;\n\n  compressed_pixels=(unsigned char *) NULL;\n  flush=Z_NO_FLUSH;\n#endif\n  count=0;\n  if (separate != MagickFalse)\n    {\n      size_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,1);\n    }\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n    MagickTrue : MagickFalse;\n  quantum_info=AcquireQuantumInfo(image_info,next_image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    return(0);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (next_image->compression == ZipCompression)\n    {\n      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,\n        sizeof(*compressed_pixels));\n      if (compressed_pixels == (unsigned char *) NULL)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n      ResetMagickMemory(&stream,0,sizeof(stream));\n      stream.data_type=Z_BINARY;\n      level=Z_DEFAULT_COMPRESSION;\n      if ((image_info->quality > 0 && image_info->quality < 10))\n        level=(int) image_info->quality;\n      if (deflateInit(&stream,level) != Z_OK)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n    }\n#endif\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (monochrome != MagickFalse)\n      for (i=0; i < (ssize_t) length; i++)\n        pixels[i]=(~pixels[i]);\n    if (next_image->compression == RLECompression)\n      {\n        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n          exception);\n        count+=WriteBlob(image,length,compact_pixels);\n        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);\n      }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n    else if (next_image->compression == ZipCompression)\n      {\n        stream.avail_in=(uInt) length;\n        stream.next_in=(Bytef *) pixels;\n        if (y == (ssize_t) next_image->rows-1)\n          flush=Z_FINISH;\n        do {\n            stream.avail_out=(uInt) CHUNK;\n            stream.next_out=(Bytef *) compressed_pixels;\n            if (deflate(&stream,flush) == Z_STREAM_ERROR)\n              break;\n            length=(size_t) CHUNK-stream.avail_out;\n            if (length > 0)\n              count+=WriteBlob(image,length,compressed_pixels);\n        } while (stream.avail_out == 0);\n      }\n#endif\n    else\n      count+=WriteBlob(image,length,pixels);\n  }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (next_image->compression == ZipCompression)\n    {\n      (void) deflateEnd(&stream);\n      compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n        compressed_pixels);\n    }\n#endif\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  return(count);\n}", "line_changes": {"deleted": [{"line_no": 56, "char_start": 1009, "char_end": 1062, "line": "  quantum_info=AcquireQuantumInfo(image_info,image);\n"}], "added": [{"line_no": 56, "char_start": 1009, "char_end": 1067, "line": "  quantum_info=AcquireQuantumInfo(image_info,next_image);\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1054, "char_end": 1059, "chars": "next_"}]}, "commit_link": "github.com/ImageMagick/ImageMagick/commit/91cc3f36f2ccbd485a0456bab9aebe63b635da88", "file_name": "coders/psd.c", "vul_type": "cwe-787"}
{"func_name": "flb_gzip_compress", "func_src_before": "int flb_gzip_compress(void *in_data, size_t in_len,\n                      void **out_data, size_t *out_len)\n{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n    out_size = in_len + 32;\n    out_buf = flb_malloc(out_size);\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* Initialize streaming buffer context */\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;\n    strm.opaque    = Z_NULL;\n    strm.next_in   = in_data;\n    strm.avail_in  = in_len;\n    strm.total_out = 0;\n\n    /* Deflate mode */\n    deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n                 Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);\n\n    /*\n     * Miniz don't support GZip format directly, instead we will:\n     *\n     * - append manual GZip magic bytes\n     * - deflate raw content\n     * - append manual CRC32 data\n     */\n    gzip_header(out_buf);\n\n    /* Header offset */\n    pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;\n\n    flush = Z_NO_FLUSH;\n    while (1) {\n        strm.next_out  = pb + strm.total_out;\n        strm.avail_out = out_size - (pb - (uint8_t *) out_buf);\n\n        if (strm.avail_in == 0) {\n            flush = Z_FINISH;\n        }\n\n        status = deflate(&strm, flush);\n        if (status == Z_STREAM_END) {\n            break;\n        }\n        else if (status != Z_OK) {\n            deflateEnd(&strm);\n            return -1;\n        }\n    }\n\n    if (deflateEnd(&strm) != Z_OK) {\n        flb_free(out_buf);\n        return -1;\n    }\n    *out_len = strm.total_out;\n\n    /* Construct the gzip checksum (CRC32 footer) */\n    footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;\n    pb = (uint8_t *) out_buf + footer_start;\n\n    crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);\n    *pb++ = crc & 0xFF;\n    *pb++ = (crc >> 8) & 0xFF;\n    *pb++ = (crc >> 16) & 0xFF;\n    *pb++ = (crc >> 24) & 0xFF;\n    *pb++ = in_len & 0xFF;\n    *pb++ = (in_len >> 8) & 0xFF;\n    *pb++ = (in_len >> 16) & 0xFF;\n    *pb++ = (in_len >> 24) & 0xFF;\n\n    /* Set the real buffer size for the caller */\n    *out_len += FLB_GZIP_HEADER_OFFSET + 8;\n    *out_data = out_buf;\n\n    return 0;\n}", "func_src_after": "int flb_gzip_compress(void *in_data, size_t in_len,\n                      void **out_data, size_t *out_len)\n{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n\n    /*\n     * GZIP relies on an algorithm with worst-case expansion\n     * of 5 bytes per 32KB data. This means we need to create a variable\n     * length output, that depends on the input length.\n     * See RFC 1951 for details.\n     */\n    int max_input_expansion = ((int)(in_len / 32000) + 1) * 5;\n\n    /*\n     * Max compressed size is equal to sum of:\n     *   10 byte header\n     *   8 byte foot\n     *   max input expansion\n     *   size of input\n     */\n    out_size = 10 + 8 + max_input_expansion + in_len;\n    out_buf = flb_malloc(out_size);\n\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* Initialize streaming buffer context */\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;\n    strm.opaque    = Z_NULL;\n    strm.next_in   = in_data;\n    strm.avail_in  = in_len;\n    strm.total_out = 0;\n\n    /* Deflate mode */\n    deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n                 Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);\n\n    /*\n     * Miniz don't support GZip format directly, instead we will:\n     *\n     * - append manual GZip magic bytes\n     * - deflate raw content\n     * - append manual CRC32 data\n     */\n    gzip_header(out_buf);\n\n    /* Header offset */\n    pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;\n\n    flush = Z_NO_FLUSH;\n    while (1) {\n        strm.next_out  = pb + strm.total_out;\n        strm.avail_out = out_size - (pb - (uint8_t *) out_buf);\n\n        if (strm.avail_in == 0) {\n            flush = Z_FINISH;\n        }\n\n        status = deflate(&strm, flush);\n        if (status == Z_STREAM_END) {\n            break;\n        }\n        else if (status != Z_OK) {\n            deflateEnd(&strm);\n            return -1;\n        }\n    }\n\n    if (deflateEnd(&strm) != Z_OK) {\n        flb_free(out_buf);\n        return -1;\n    }\n    *out_len = strm.total_out;\n\n    /* Construct the gzip checksum (CRC32 footer) */\n    footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;\n    pb = (uint8_t *) out_buf + footer_start;\n\n    crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);\n    *pb++ = crc & 0xFF;\n    *pb++ = (crc >> 8) & 0xFF;\n    *pb++ = (crc >> 16) & 0xFF;\n    *pb++ = (crc >> 24) & 0xFF;\n    *pb++ = in_len & 0xFF;\n    *pb++ = (in_len >> 8) & 0xFF;\n    *pb++ = (in_len >> 16) & 0xFF;\n    *pb++ = (in_len >> 24) & 0xFF;\n\n    /* Set the real buffer size for the caller */\n    *out_len += FLB_GZIP_HEADER_OFFSET + 8;\n    *out_data = out_buf;\n\n    return 0;\n}", "line_changes": {"deleted": [{"line_no": 13, "char_start": 258, "char_end": 286, "line": "    out_size = in_len + 32;\n"}], "added": [{"line_no": 13, "char_start": 258, "char_end": 259, "line": "\n"}, {"line_no": 14, "char_start": 259, "char_end": 266, "line": "    /*\n"}, {"line_no": 15, "char_start": 266, "char_end": 327, "line": "     * GZIP relies on an algorithm with worst-case expansion\n"}, {"line_no": 16, "char_start": 327, "char_end": 400, "line": "     * of 5 bytes per 32KB data. This means we need to create a variable\n"}, {"line_no": 17, "char_start": 400, "char_end": 456, "line": "     * length output, that depends on the input length.\n"}, {"line_no": 18, "char_start": 456, "char_end": 489, "line": "     * See RFC 1951 for details.\n"}, {"line_no": 19, "char_start": 489, "char_end": 497, "line": "     */\n"}, {"line_no": 20, "char_start": 497, "char_end": 560, "line": "    int max_input_expansion = ((int)(in_len / 32000) + 1) * 5;\n"}, {"line_no": 21, "char_start": 560, "char_end": 561, "line": "\n"}, {"line_no": 22, "char_start": 561, "char_end": 568, "line": "    /*\n"}, {"line_no": 23, "char_start": 568, "char_end": 615, "line": "     * Max compressed size is equal to sum of:\n"}, {"line_no": 24, "char_start": 615, "char_end": 639, "line": "     *   10 byte header\n"}, {"line_no": 25, "char_start": 639, "char_end": 660, "line": "     *   8 byte foot\n"}, {"line_no": 26, "char_start": 660, "char_end": 689, "line": "     *   max input expansion\n"}, {"line_no": 27, "char_start": 689, "char_end": 712, "line": "     *   size of input\n"}, {"line_no": 28, "char_start": 712, "char_end": 720, "line": "     */\n"}, {"line_no": 29, "char_start": 720, "char_end": 774, "line": "    out_size = 10 + 8 + max_input_expansion + in_len;\n"}, {"line_no": 31, "char_start": 810, "char_end": 811, "line": "\n"}]}, "char_changes": {"deleted": [{"char_start": 276, "char_end": 277, "chars": "l"}, {"char_start": 282, "char_end": 284, "chars": "32"}], "added": [{"char_start": 258, "char_end": 259, "chars": "\n"}, {"char_start": 263, "char_end": 324, "chars": "/*\n     * GZIP relies on an algorithm with worst-case expansi"}, {"char_start": 325, "char_end": 418, "chars": "n\n     * of 5 bytes per 32KB data. This means we need to create a variable\n     * length outp"}, {"char_start": 420, "char_end": 433, "chars": ", that depend"}, {"char_start": 434, "char_end": 442, "chars": " on the "}, {"char_start": 443, "char_end": 465, "chars": "nput length.\n     * Se"}, {"char_start": 467, "char_end": 525, "chars": "RFC 1951 for details.\n     */\n    int max_input_expansion "}, {"char_start": 527, "char_end": 534, "chars": "((int)("}, {"char_start": 541, "char_end": 542, "chars": "/"}, {"char_start": 545, "char_end": 772, "chars": "000) + 1) * 5;\n\n    /*\n     * Max compressed size is equal to sum of:\n     *   10 byte header\n     *   8 byte foot\n     *   max input expansion\n     *   size of input\n     */\n    out_size = 10 + 8 + max_input_expansion + in_len"}, {"char_start": 809, "char_end": 810, "chars": "\n"}]}, "commit_link": "github.com/fluent/fluent-bit/commit/cadff53c093210404aed01c4cf586adb8caa07af", "file_name": "src/flb_gzip.c", "vul_type": "cwe-787"}
{"func_name": "sc_oberthur_read_file", "func_src_before": "sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tint rec;\n\t\tint offs = 0;\n\t\tint rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii;\n\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (rv != SC_SUCCESS) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii=0; ii<rv; ii++)   {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t};\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "func_src_after": "sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tsize_t rec;\n\t\tsize_t offs = 0;\n\t\tsize_t rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\tif (rec > file->record_count) {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii;\n\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (rv != SC_SUCCESS) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii=0; ii<rv; ii++)   {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t};\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "line_changes": {"deleted": [{"line_no": 43, "char_start": 1107, "char_end": 1118, "line": "\t\tint rec;\n"}, {"line_no": 44, "char_start": 1118, "char_end": 1134, "line": "\t\tint offs = 0;\n"}, {"line_no": 45, "char_start": 1134, "char_end": 1171, "line": "\t\tint rec_len = file->record_length;\n"}], "added": [{"line_no": 43, "char_start": 1107, "char_end": 1121, "line": "\t\tsize_t rec;\n"}, {"line_no": 44, "char_start": 1121, "char_end": 1140, "line": "\t\tsize_t offs = 0;\n"}, {"line_no": 45, "char_start": 1140, "char_end": 1180, "line": "\t\tsize_t rec_len = file->record_length;\n"}, {"line_no": 48, "char_start": 1210, "char_end": 1245, "line": "\t\t\tif (rec > file->record_count) {\n"}, {"line_no": 49, "char_start": 1245, "char_end": 1257, "line": "\t\t\t\trv = 0;\n"}, {"line_no": 50, "char_start": 1257, "char_end": 1268, "line": "\t\t\t\tbreak;\n"}, {"line_no": 51, "char_start": 1268, "char_end": 1273, "line": "\t\t\t}\n"}]}, "char_changes": {"deleted": [{"char_start": 1110, "char_end": 1111, "chars": "n"}, {"char_start": 1121, "char_end": 1122, "chars": "n"}, {"char_start": 1137, "char_end": 1138, "chars": "n"}], "added": [{"char_start": 1109, "char_end": 1110, "chars": "s"}, {"char_start": 1111, "char_end": 1114, "chars": "ze_"}, {"char_start": 1123, "char_end": 1124, "chars": "s"}, {"char_start": 1125, "char_end": 1128, "chars": "ze_"}, {"char_start": 1142, "char_end": 1143, "chars": "s"}, {"char_start": 1144, "char_end": 1147, "chars": "ze_"}, {"char_start": 1209, "char_end": 1272, "chars": "\n\t\t\tif (rec > file->record_count) {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}"}]}, "commit_link": "github.com/OpenSC/OpenSC/commit/6903aebfddc466d966c7b865fae34572bf3ed23e", "file_name": "src/libopensc/pkcs15-oberthur.c", "vul_type": "cwe-787"}
{"func_name": "tflite::ops::builtin::segment_sum::ResizeOutputTensor", "func_src_before": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* data,\n                                const TfLiteTensor* segment_ids,\n                                TfLiteTensor* output) {\n  int max_index = -1;\n  const int segment_id_size = segment_ids->dims->data[0];\n  if (segment_id_size > 0) {\n    max_index = segment_ids->data.i32[segment_id_size - 1];\n  }\n  const int data_rank = NumDimensions(data);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n  output_shape->data[0] = max_index + 1;\n  for (int i = 1; i < data_rank; ++i) {\n    output_shape->data[i] = data->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}", "func_src_after": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* data,\n                                const TfLiteTensor* segment_ids,\n                                TfLiteTensor* output) {\n  // Segment ids should be of same cardinality as first input dimension and they\n  // should be increasing by at most 1, from 0 (e.g., [0, 0, 1, 2, 3] is valid)\n  const int segment_id_size = segment_ids->dims->data[0];\n  TF_LITE_ENSURE_EQ(context, segment_id_size, data->dims->data[0]);\n  int previous_segment_id = -1;\n  for (int i = 0; i < segment_id_size; i++) {\n    const int current_segment_id = GetTensorData<int32_t>(segment_ids)[i];\n    if (i == 0) {\n      TF_LITE_ENSURE_EQ(context, current_segment_id, 0);\n    } else {\n      int delta = current_segment_id - previous_segment_id;\n      TF_LITE_ENSURE(context, delta == 0 || delta == 1);\n    }\n    previous_segment_id = current_segment_id;\n  }\n\n  const int max_index = previous_segment_id;\n\n  const int data_rank = NumDimensions(data);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n  output_shape->data[0] = max_index + 1;\n  for (int i = 1; i < data_rank; ++i) {\n    output_shape->data[i] = data->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}", "line_changes": {"deleted": [{"line_no": 5, "char_start": 235, "char_end": 257, "line": "  int max_index = -1;\n"}, {"line_no": 7, "char_start": 315, "char_end": 344, "line": "  if (segment_id_size > 0) {\n"}, {"line_no": 8, "char_start": 344, "char_end": 404, "line": "    max_index = segment_ids->data.i32[segment_id_size - 1];\n"}], "added": [{"line_no": 8, "char_start": 454, "char_end": 522, "line": "  TF_LITE_ENSURE_EQ(context, segment_id_size, data->dims->data[0]);\n"}, {"line_no": 9, "char_start": 522, "char_end": 554, "line": "  int previous_segment_id = -1;\n"}, {"line_no": 10, "char_start": 554, "char_end": 600, "line": "  for (int i = 0; i < segment_id_size; i++) {\n"}, {"line_no": 11, "char_start": 600, "char_end": 675, "line": "    const int current_segment_id = GetTensorData<int32_t>(segment_ids)[i];\n"}, {"line_no": 12, "char_start": 675, "char_end": 693, "line": "    if (i == 0) {\n"}, {"line_no": 13, "char_start": 693, "char_end": 750, "line": "      TF_LITE_ENSURE_EQ(context, current_segment_id, 0);\n"}, {"line_no": 14, "char_start": 750, "char_end": 763, "line": "    } else {\n"}, {"line_no": 15, "char_start": 763, "char_end": 823, "line": "      int delta = current_segment_id - previous_segment_id;\n"}, {"line_no": 16, "char_start": 823, "char_end": 880, "line": "      TF_LITE_ENSURE(context, delta == 0 || delta == 1);\n"}, {"line_no": 17, "char_start": 880, "char_end": 886, "line": "    }\n"}, {"line_no": 18, "char_start": 886, "char_end": 932, "line": "    previous_segment_id = current_segment_id;\n"}, {"line_no": 20, "char_start": 936, "char_end": 937, "line": "\n"}, {"line_no": 21, "char_start": 937, "char_end": 982, "line": "  const int max_index = previous_segment_id;\n"}, {"line_no": 22, "char_start": 982, "char_end": 983, "line": "\n"}]}, "char_changes": {"deleted": [{"char_start": 237, "char_end": 238, "chars": "i"}, {"char_start": 243, "char_end": 245, "chars": "x_"}, {"char_start": 249, "char_end": 250, "chars": "x"}, {"char_start": 251, "char_end": 252, "chars": "="}, {"char_start": 253, "char_end": 254, "chars": "-"}, {"char_start": 255, "char_end": 256, "chars": ";"}, {"char_start": 349, "char_end": 351, "chars": "ax"}, {"char_start": 356, "char_end": 357, "chars": "x"}, {"char_start": 371, "char_end": 373, "chars": "->"}, {"char_start": 377, "char_end": 378, "chars": "."}, {"char_start": 379, "char_end": 382, "chars": "32["}, {"char_start": 395, "char_end": 396, "chars": "z"}, {"char_start": 398, "char_end": 399, "chars": "-"}, {"char_start": 400, "char_end": 402, "chars": "1]"}, {"char_start": 404, "char_end": 407, "chars": "  }"}], "added": [{"char_start": 237, "char_end": 274, "chars": "// Segment ids should be of same card"}, {"char_start": 276, "char_end": 279, "chars": "ali"}, {"char_start": 280, "char_end": 284, "chars": "y as"}, {"char_start": 285, "char_end": 299, "chars": "first input di"}, {"char_start": 300, "char_end": 307, "chars": "ension "}, {"char_start": 308, "char_end": 338, "chars": "nd they\n  // should be increas"}, {"char_start": 340, "char_end": 364, "chars": "g by at most 1, from 0 ("}, {"char_start": 365, "char_end": 369, "chars": ".g.,"}, {"char_start": 370, "char_end": 373, "chars": "[0,"}, {"char_start": 374, "char_end": 377, "chars": "0, "}, {"char_start": 378, "char_end": 395, "chars": ", 2, 3] is valid)"}, {"char_start": 456, "char_end": 491, "chars": "TF_LITE_ENSURE_EQ(context, segment_"}, {"char_start": 492, "char_end": 556, "chars": "d_size, data->dims->data[0]);\n  int previous_segment_id = -1;\n  "}, {"char_start": 557, "char_end": 559, "chars": "or"}, {"char_start": 561, "char_end": 576, "chars": "int i = 0; i < "}, {"char_start": 591, "char_end": 592, "chars": ";"}, {"char_start": 593, "char_end": 656, "chars": "i++) {\n    const int current_segment_id = GetTensorData<int32_t"}, {"char_start": 657, "char_end": 687, "chars": "(segment_ids)[i];\n    if (i =="}, {"char_start": 697, "char_end": 722, "chars": "  TF_LITE_ENSURE_EQ(conte"}, {"char_start": 723, "char_end": 741, "chars": "t, current_segment"}, {"char_start": 743, "char_end": 770, "chars": "d, 0);\n    } else {\n      i"}, {"char_start": 771, "char_end": 773, "chars": "t "}, {"char_start": 775, "char_end": 778, "chars": "lta"}, {"char_start": 781, "char_end": 789, "chars": "current_"}, {"char_start": 799, "char_end": 809, "chars": " - previou"}, {"char_start": 810, "char_end": 820, "chars": "_segment_i"}, {"char_start": 821, "char_end": 857, "chars": ";\n      TF_LITE_ENSURE(context, delt"}, {"char_start": 858, "char_end": 870, "chars": " == 0 || del"}, {"char_start": 872, "char_end": 894, "chars": " == 1);\n    }\n    prev"}, {"char_start": 895, "char_end": 899, "chars": "ous_"}, {"char_start": 909, "char_end": 919, "chars": " = current"}, {"char_start": 922, "char_end": 930, "chars": "gment_id"}, {"char_start": 935, "char_end": 982, "chars": "\n\n  const int max_index = previous_segment_id;\n"}]}, "commit_link": "github.com/tensorflow/tensorflow/commit/204945b19e44b57906c9344c0d00120eeeae178a", "file_name": "tensorflow/lite/kernels/segment_sum.cc", "vul_type": "cwe-787"}
{"func_name": "mwifiex_ret_wmm_get_status", "func_src_before": "int mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,\n\t\t\t       const struct host_cmd_ds_command *resp)\n{\n\tu8 *curr = (u8 *) &resp->params.get_wmm_status;\n\tuint16_t resp_len = le16_to_cpu(resp->size), tlv_len;\n\tint mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK;\n\tbool valid = true;\n\n\tstruct mwifiex_ie_types_data *tlv_hdr;\n\tstruct mwifiex_ie_types_wmm_queue_status *tlv_wmm_qstatus;\n\tstruct ieee_types_wmm_parameter *wmm_param_ie = NULL;\n\tstruct mwifiex_wmm_ac_status *ac_status;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: WMM: WMM_GET_STATUS cmdresp received: %d\\n\",\n\t\t    resp_len);\n\n\twhile ((resp_len >= sizeof(tlv_hdr->header)) && valid) {\n\t\ttlv_hdr = (struct mwifiex_ie_types_data *) curr;\n\t\ttlv_len = le16_to_cpu(tlv_hdr->header.len);\n\n\t\tif (resp_len < tlv_len + sizeof(tlv_hdr->header))\n\t\t\tbreak;\n\n\t\tswitch (le16_to_cpu(tlv_hdr->header.type)) {\n\t\tcase TLV_TYPE_WMMQSTATUS:\n\t\t\ttlv_wmm_qstatus =\n\t\t\t\t(struct mwifiex_ie_types_wmm_queue_status *)\n\t\t\t\ttlv_hdr;\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"QSTATUS TLV: %d, %d, %d\\n\",\n\t\t\t\t    tlv_wmm_qstatus->queue_index,\n\t\t\t\t    tlv_wmm_qstatus->flow_required,\n\t\t\t\t    tlv_wmm_qstatus->disabled);\n\n\t\t\tac_status = &priv->wmm.ac_status[tlv_wmm_qstatus->\n\t\t\t\t\t\t\t queue_index];\n\t\t\tac_status->disabled = tlv_wmm_qstatus->disabled;\n\t\t\tac_status->flow_required =\n\t\t\t\t\t\ttlv_wmm_qstatus->flow_required;\n\t\t\tac_status->flow_created = tlv_wmm_qstatus->flow_created;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t/*\n\t\t\t * Point the regular IEEE IE 2 bytes into the Marvell IE\n\t\t\t *   and setup the IEEE IE type and length byte fields\n\t\t\t */\n\n\t\t\twmm_param_ie =\n\t\t\t\t(struct ieee_types_wmm_parameter *) (curr +\n\t\t\t\t\t\t\t\t    2);\n\t\t\twmm_param_ie->vend_hdr.len = (u8) tlv_len;\n\t\t\twmm_param_ie->vend_hdr.element_id =\n\t\t\t\t\t\tWLAN_EID_VENDOR_SPECIFIC;\n\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"WMM Parameter Set Count: %d\\n\",\n\t\t\t\t    wmm_param_ie->qos_info_bitmap & mask);\n\n\t\t\tmemcpy((u8 *) &priv->curr_bss_params.bss_descriptor.\n\t\t\t       wmm_ie, wmm_param_ie,\n\t\t\t       wmm_param_ie->vend_hdr.len + 2);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tvalid = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tcurr += (tlv_len + sizeof(tlv_hdr->header));\n\t\tresp_len -= (tlv_len + sizeof(tlv_hdr->header));\n\t}\n\n\tmwifiex_wmm_setup_queue_priorities(priv, wmm_param_ie);\n\tmwifiex_wmm_setup_ac_downgrade(priv);\n\n\treturn 0;\n}", "func_src_after": "int mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,\n\t\t\t       const struct host_cmd_ds_command *resp)\n{\n\tu8 *curr = (u8 *) &resp->params.get_wmm_status;\n\tuint16_t resp_len = le16_to_cpu(resp->size), tlv_len;\n\tint mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK;\n\tbool valid = true;\n\n\tstruct mwifiex_ie_types_data *tlv_hdr;\n\tstruct mwifiex_ie_types_wmm_queue_status *tlv_wmm_qstatus;\n\tstruct ieee_types_wmm_parameter *wmm_param_ie = NULL;\n\tstruct mwifiex_wmm_ac_status *ac_status;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: WMM: WMM_GET_STATUS cmdresp received: %d\\n\",\n\t\t    resp_len);\n\n\twhile ((resp_len >= sizeof(tlv_hdr->header)) && valid) {\n\t\ttlv_hdr = (struct mwifiex_ie_types_data *) curr;\n\t\ttlv_len = le16_to_cpu(tlv_hdr->header.len);\n\n\t\tif (resp_len < tlv_len + sizeof(tlv_hdr->header))\n\t\t\tbreak;\n\n\t\tswitch (le16_to_cpu(tlv_hdr->header.type)) {\n\t\tcase TLV_TYPE_WMMQSTATUS:\n\t\t\ttlv_wmm_qstatus =\n\t\t\t\t(struct mwifiex_ie_types_wmm_queue_status *)\n\t\t\t\ttlv_hdr;\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"QSTATUS TLV: %d, %d, %d\\n\",\n\t\t\t\t    tlv_wmm_qstatus->queue_index,\n\t\t\t\t    tlv_wmm_qstatus->flow_required,\n\t\t\t\t    tlv_wmm_qstatus->disabled);\n\n\t\t\tac_status = &priv->wmm.ac_status[tlv_wmm_qstatus->\n\t\t\t\t\t\t\t queue_index];\n\t\t\tac_status->disabled = tlv_wmm_qstatus->disabled;\n\t\t\tac_status->flow_required =\n\t\t\t\t\t\ttlv_wmm_qstatus->flow_required;\n\t\t\tac_status->flow_created = tlv_wmm_qstatus->flow_created;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t/*\n\t\t\t * Point the regular IEEE IE 2 bytes into the Marvell IE\n\t\t\t *   and setup the IEEE IE type and length byte fields\n\t\t\t */\n\n\t\t\twmm_param_ie =\n\t\t\t\t(struct ieee_types_wmm_parameter *) (curr +\n\t\t\t\t\t\t\t\t    2);\n\t\t\twmm_param_ie->vend_hdr.len = (u8) tlv_len;\n\t\t\twmm_param_ie->vend_hdr.element_id =\n\t\t\t\t\t\tWLAN_EID_VENDOR_SPECIFIC;\n\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"WMM Parameter Set Count: %d\\n\",\n\t\t\t\t    wmm_param_ie->qos_info_bitmap & mask);\n\n\t\t\tif (wmm_param_ie->vend_hdr.len + 2 >\n\t\t\t\tsizeof(struct ieee_types_wmm_parameter))\n\t\t\t\tbreak;\n\n\t\t\tmemcpy((u8 *) &priv->curr_bss_params.bss_descriptor.\n\t\t\t       wmm_ie, wmm_param_ie,\n\t\t\t       wmm_param_ie->vend_hdr.len + 2);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tvalid = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tcurr += (tlv_len + sizeof(tlv_hdr->header));\n\t\tresp_len -= (tlv_len + sizeof(tlv_hdr->header));\n\t}\n\n\tmwifiex_wmm_setup_queue_priorities(priv, wmm_param_ie);\n\tmwifiex_wmm_setup_ac_downgrade(priv);\n\n\treturn 0;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 63, "char_start": 2014, "char_end": 2054, "line": "\t\t\tif (wmm_param_ie->vend_hdr.len + 2 >\n"}, {"line_no": 64, "char_start": 2054, "char_end": 2099, "line": "\t\t\t\tsizeof(struct ieee_types_wmm_parameter))\n"}, {"line_no": 65, "char_start": 2099, "char_end": 2110, "line": "\t\t\t\tbreak;\n"}, {"line_no": 66, "char_start": 2110, "char_end": 2111, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 2017, "char_end": 2114, "chars": "if (wmm_param_ie->vend_hdr.len + 2 >\n\t\t\t\tsizeof(struct ieee_types_wmm_parameter))\n\t\t\t\tbreak;\n\n\t\t\t"}]}, "commit_link": "github.com/torvalds/linux/commit/3a9b153c5591548612c3955c9600a98150c81875", "file_name": "drivers/net/wireless/marvell/mwifiex/wmm.c", "vul_type": "cwe-787"}
{"func_name": "patch", "func_src_before": "static PyObject* patch(PyObject* self, PyObject* args)\n{\n    char *origData, *newData, *diffBlock, *extraBlock, *diffPtr, *extraPtr;\n    Py_ssize_t origDataLength, newDataLength, diffBlockLength, extraBlockLength;\n    PyObject *controlTuples, *tuple, *results;\n    off_t oldpos, newpos, x, y, z;\n    int i, j, numTuples;\n\n    if (!PyArg_ParseTuple(args, \"s#nO!s#s#\",\n                          &origData, &origDataLength, &newDataLength,\n                          &PyList_Type, &controlTuples,\n                          &diffBlock, &diffBlockLength,\n                          &extraBlock, &extraBlockLength))\n        return NULL;\n\n    /* allocate the memory for the new data */\n    newData = PyMem_Malloc(newDataLength + 1);\n    if (!newData)\n        return PyErr_NoMemory();\n\n    oldpos = 0;\n    newpos = 0;\n    diffPtr = diffBlock;\n    extraPtr = extraBlock;\n    numTuples = PyList_GET_SIZE(controlTuples);\n    for (i = 0; i < numTuples; i++) {\n        tuple = PyList_GET_ITEM(controlTuples, i);\n        if (!PyTuple_Check(tuple)) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_TypeError, \"expecting tuple\");\n            return NULL;\n        }\n        if (PyTuple_GET_SIZE(tuple) != 3) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_TypeError, \"expecting tuple of size 3\");\n            return NULL;\n        }\n        x = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 0));\n        y = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 1));\n        z = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 2));\n        if (newpos + x > newDataLength ||\n                diffPtr + x > diffBlock + diffBlockLength ||\n                extraPtr + y > extraBlock + extraBlockLength) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_ValueError, \"corrupt patch (overflow)\");\n            return NULL;\n        }\n        memcpy(newData + newpos, diffPtr, x);\n        diffPtr += x;\n        for (j = 0; j < x; j++)\n            if ((oldpos + j >= 0) && (oldpos + j < origDataLength))\n                newData[newpos + j] += origData[oldpos + j];\n        newpos += x;\n        oldpos += x;\n        memcpy(newData + newpos, extraPtr, y);\n        extraPtr += y;\n        newpos += y;\n        oldpos += z;\n    }\n\n    /* confirm that a valid patch was applied */\n    if (newpos != newDataLength ||\n            diffPtr != diffBlock + diffBlockLength ||\n            extraPtr != extraBlock + extraBlockLength) {\n        PyMem_Free(newData);\n        PyErr_SetString(PyExc_ValueError, \"corrupt patch (underflow)\");\n        return NULL;\n    }\n\n    results = PyBytes_FromStringAndSize(newData, newDataLength);\n    PyMem_Free(newData);\n    return results;\n}", "func_src_after": "static PyObject* patch(PyObject* self, PyObject* args)\n{\n    char *origData, *newData, *diffBlock, *extraBlock, *diffPtr, *extraPtr;\n    Py_ssize_t origDataLength, newDataLength, diffBlockLength, extraBlockLength;\n    PyObject *controlTuples, *tuple, *results;\n    off_t oldpos, newpos, x, y, z;\n    int i, j, numTuples;\n\n    if (!PyArg_ParseTuple(args, \"s#nO!s#s#\",\n                          &origData, &origDataLength, &newDataLength,\n                          &PyList_Type, &controlTuples,\n                          &diffBlock, &diffBlockLength,\n                          &extraBlock, &extraBlockLength))\n        return NULL;\n\n    /* allocate the memory for the new data */\n    newData = PyMem_Malloc(newDataLength + 1);\n    if (!newData)\n        return PyErr_NoMemory();\n\n    oldpos = 0;\n    newpos = 0;\n    diffPtr = diffBlock;\n    extraPtr = extraBlock;\n    numTuples = PyList_GET_SIZE(controlTuples);\n    for (i = 0; i < numTuples; i++) {\n        tuple = PyList_GET_ITEM(controlTuples, i);\n        if (!PyTuple_Check(tuple)) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_TypeError, \"expecting tuple\");\n            return NULL;\n        }\n        if (PyTuple_GET_SIZE(tuple) != 3) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_TypeError, \"expecting tuple of size 3\");\n            return NULL;\n        }\n        x = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 0));\n        y = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 1));\n        z = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 2));\n        if (newpos + x > newDataLength ||\n                diffPtr + x > diffBlock + diffBlockLength) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_ValueError, \"corrupt patch (overflow)\");\n            return NULL;\n        }\n        memcpy(newData + newpos, diffPtr, x);\n        diffPtr += x;\n        for (j = 0; j < x; j++)\n            if ((oldpos + j >= 0) && (oldpos + j < origDataLength))\n                newData[newpos + j] += origData[oldpos + j];\n        newpos += x;\n        oldpos += x;\n        if (newpos + y > newDataLength ||\n                extraPtr + y > extraBlock + extraBlockLength) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_ValueError, \"corrupt patch (overflow)\");\n            return NULL;\n        }\n        memcpy(newData + newpos, extraPtr, y);\n        extraPtr += y;\n        newpos += y;\n        oldpos += z;\n    }\n\n    /* confirm that a valid patch was applied */\n    if (newpos != newDataLength ||\n            diffPtr != diffBlock + diffBlockLength ||\n            extraPtr != extraBlock + extraBlockLength) {\n        PyMem_Free(newData);\n        PyErr_SetString(PyExc_ValueError, \"corrupt patch (underflow)\");\n        return NULL;\n    }\n\n    results = PyBytes_FromStringAndSize(newData, newDataLength);\n    PyMem_Free(newData);\n    return results;\n}", "line_changes": {"deleted": [{"line_no": 42, "char_start": 1561, "char_end": 1622, "line": "                diffPtr + x > diffBlock + diffBlockLength ||\n"}, {"line_no": 43, "char_start": 1622, "char_end": 1686, "line": "                extraPtr + y > extraBlock + extraBlockLength) {\n"}], "added": [{"line_no": 42, "char_start": 1561, "char_end": 1622, "line": "                diffPtr + x > diffBlock + diffBlockLength) {\n"}, {"line_no": 54, "char_start": 2036, "char_end": 2078, "line": "        if (newpos + y > newDataLength ||\n"}, {"line_no": 55, "char_start": 2078, "char_end": 2142, "line": "                extraPtr + y > extraBlock + extraBlockLength) {\n"}, {"line_no": 56, "char_start": 2142, "char_end": 2175, "line": "            PyMem_Free(newData);\n"}, {"line_no": 57, "char_start": 2175, "char_end": 2250, "line": "            PyErr_SetString(PyExc_ValueError, \"corrupt patch (overflow)\");\n"}, {"line_no": 58, "char_start": 2250, "char_end": 2275, "line": "            return NULL;\n"}, {"line_no": 59, "char_start": 2275, "char_end": 2285, "line": "        }\n"}]}, "char_changes": {"deleted": [{"char_start": 1618, "char_end": 1682, "chars": " ||\n                extraPtr + y > extraBlock + extraBlockLength"}], "added": [{"char_start": 2035, "char_end": 2284, "chars": "\n        if (newpos + y > newDataLength ||\n                extraPtr + y > extraBlock + extraBlockLength) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_ValueError, \"corrupt patch (overflow)\");\n            return NULL;\n        }"}]}, "commit_link": "github.com/ilanschnell/bsdiff4/commit/49a4cee2feef7deaf9d89e5e793a8824930284d7", "file_name": "bsdiff4/core.c", "vul_type": "cwe-787"}
{"func_name": "HandleRFBServerMessage", "func_src_before": "HandleRFBServerMessage(rfbClient* client)\n{\n  rfbServerToClientMsg msg;\n\n  if (client->serverPort==-1)\n    client->vncRec->readTimestamp = TRUE;\n  if (!ReadFromRFBServer(client, (char *)&msg, 1))\n    return FALSE;\n\n  switch (msg.type) {\n\n  case rfbSetColourMapEntries:\n  {\n    /* TODO:\n    int i;\n    uint16_t rgb[3];\n    XColor xc;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbSetColourMapEntriesMsg - 1))\n      return FALSE;\n\n    msg.scme.firstColour = rfbClientSwap16IfLE(msg.scme.firstColour);\n    msg.scme.nColours = rfbClientSwap16IfLE(msg.scme.nColours);\n\n    for (i = 0; i < msg.scme.nColours; i++) {\n      if (!ReadFromRFBServer(client, (char *)rgb, 6))\n\treturn FALSE;\n      xc.pixel = msg.scme.firstColour + i;\n      xc.red = rfbClientSwap16IfLE(rgb[0]);\n      xc.green = rfbClientSwap16IfLE(rgb[1]);\n      xc.blue = rfbClientSwap16IfLE(rgb[2]);\n      xc.flags = DoRed|DoGreen|DoBlue;\n      XStoreColor(dpy, cmap, &xc);\n    }\n    */\n\n    break;\n  }\n\n  case rfbFramebufferUpdate:\n  {\n    rfbFramebufferUpdateRectHeader rect;\n    int linesToRead;\n    int bytesPerLine;\n    int i;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg.fu) + 1,\n\t\t\t   sz_rfbFramebufferUpdateMsg - 1))\n      return FALSE;\n\n    msg.fu.nRects = rfbClientSwap16IfLE(msg.fu.nRects);\n\n    for (i = 0; i < msg.fu.nRects; i++) {\n      if (!ReadFromRFBServer(client, (char *)&rect, sz_rfbFramebufferUpdateRectHeader))\n\treturn FALSE;\n\n      rect.encoding = rfbClientSwap32IfLE(rect.encoding);\n      if (rect.encoding == rfbEncodingLastRect)\n\tbreak;\n\n      rect.r.x = rfbClientSwap16IfLE(rect.r.x);\n      rect.r.y = rfbClientSwap16IfLE(rect.r.y);\n      rect.r.w = rfbClientSwap16IfLE(rect.r.w);\n      rect.r.h = rfbClientSwap16IfLE(rect.r.h);\n\n\n      if (rect.encoding == rfbEncodingXCursor ||\n\t  rect.encoding == rfbEncodingRichCursor) {\n\n\tif (!HandleCursorShape(client,\n\t\t\t       rect.r.x, rect.r.y, rect.r.w, rect.r.h,\n\t\t\t       rect.encoding)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n\n      if (rect.encoding == rfbEncodingPointerPos) {\n\tif (!client->HandleCursorPos(client,rect.r.x, rect.r.y)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n      \n      if (rect.encoding == rfbEncodingKeyboardLedState) {\n          /* OK! We have received a keyboard state message!!! */\n          client->KeyboardLedStateEnabled = 1;\n          if (client->HandleKeyboardLedState!=NULL)\n              client->HandleKeyboardLedState(client, rect.r.x, 0);\n          /* stash it for the future */\n          client->CurrentKeyboardLedState = rect.r.x;\n          continue;\n      }\n\n      if (rect.encoding == rfbEncodingNewFBSize) {\n\tclient->width = rect.r.w;\n\tclient->height = rect.r.h;\n\tclient->updateRect.x = client->updateRect.y = 0;\n\tclient->updateRect.w = client->width;\n\tclient->updateRect.h = client->height;\n\tif (!client->MallocFrameBuffer(client))\n\t  return FALSE;\n\tSendFramebufferUpdateRequest(client, 0, 0, rect.r.w, rect.r.h, FALSE);\n\trfbClientLog(\"Got new framebuffer size: %dx%d\\n\", rect.r.w, rect.r.h);\n\tcontinue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingSupportedMessages) {\n          int loop;\n          if (!ReadFromRFBServer(client, (char *)&client->supportedMessages, sz_rfbSupportedMessages))\n              return FALSE;\n\n          /* msgs is two sets of bit flags of supported messages client2server[] and server2client[] */\n          /* currently ignored by this library */\n\n          rfbClientLog(\"client2server supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.client2server[loop],   client->supportedMessages.client2server[loop+1],\n                client->supportedMessages.client2server[loop+2], client->supportedMessages.client2server[loop+3],\n                client->supportedMessages.client2server[loop+4], client->supportedMessages.client2server[loop+5],\n                client->supportedMessages.client2server[loop+6], client->supportedMessages.client2server[loop+7]);\n\n          rfbClientLog(\"server2client supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.server2client[loop],   client->supportedMessages.server2client[loop+1],\n                client->supportedMessages.server2client[loop+2], client->supportedMessages.server2client[loop+3],\n                client->supportedMessages.server2client[loop+4], client->supportedMessages.server2client[loop+5],\n                client->supportedMessages.server2client[loop+6], client->supportedMessages.server2client[loop+7]);\n          continue;\n      }\n\n      /* rect.r.w=byte count, rect.r.h=# of encodings */\n      if (rect.encoding == rfbEncodingSupportedEncodings) {\n          char *buffer;\n          buffer = malloc(rect.r.w);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n\n          /* buffer now contains rect.r.h # of uint32_t encodings that the server supports */\n          /* currently ignored by this library */\n          free(buffer);\n          continue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingServerIdentity) {\n          char *buffer;\n          buffer = malloc(rect.r.w+1);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          buffer[rect.r.w]=0; /* null terminate, just in case */\n          rfbClientLog(\"Connected to Server \\\"%s\\\"\\n\", buffer);\n          free(buffer);\n          continue;\n      }\n\n      /* rfbEncodingUltraZip is a collection of subrects.   x = # of subrects, and h is always 0 */\n      if (rect.encoding != rfbEncodingUltraZip)\n      {\n        if ((rect.r.x + rect.r.w > client->width) ||\n\t    (rect.r.y + rect.r.h > client->height))\n\t    {\n\t      rfbClientLog(\"Rect too large: %dx%d at (%d, %d)\\n\",\n\t  \t  rect.r.w, rect.r.h, rect.r.x, rect.r.y);\n\t      return FALSE;\n            }\n\n        /* UltraVNC with scaling, will send rectangles with a zero W or H\n         *\n        if ((rect.encoding != rfbEncodingTight) && \n            (rect.r.h * rect.r.w == 0))\n        {\n\t  rfbClientLog(\"Zero size rect - ignoring (encoding=%d (0x%08x) %dx, %dy, %dw, %dh)\\n\", rect.encoding, rect.encoding, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n\t  continue;\n        }\n        */\n        \n        /* If RichCursor encoding is used, we should prevent collisions\n\t   between framebuffer updates and cursor drawing operations. */\n        client->SoftCursorLockArea(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n      }\n\n      switch (rect.encoding) {\n\n      case rfbEncodingRaw: {\n\tint y=rect.r.y, h=rect.r.h;\n\n\tbytesPerLine = rect.r.w * client->format.bitsPerPixel / 8;\n\t/* RealVNC 4.x-5.x on OSX can induce bytesPerLine==0, \n\t   usually during GPU accel. */\n\t/* Regardless of cause, do not divide by zero. */\n\tlinesToRead = bytesPerLine ? (RFB_BUFFER_SIZE / bytesPerLine) : 0;\n\n\twhile (linesToRead && h > 0) {\n\t  if (linesToRead > h)\n\t    linesToRead = h;\n\n\t  if (!ReadFromRFBServer(client, client->buffer,bytesPerLine * linesToRead))\n\t    return FALSE;\n\n\t  client->GotBitmap(client, (uint8_t *)client->buffer,\n\t\t\t   rect.r.x, y, rect.r.w,linesToRead);\n\n\t  h -= linesToRead;\n\t  y += linesToRead;\n\n\t}\n\tbreak;\n      } \n\n      case rfbEncodingCopyRect:\n      {\n\trfbCopyRect cr;\n\n\tif (!ReadFromRFBServer(client, (char *)&cr, sz_rfbCopyRect))\n\t  return FALSE;\n\n\tcr.srcX = rfbClientSwap16IfLE(cr.srcX);\n\tcr.srcY = rfbClientSwap16IfLE(cr.srcY);\n\n\t/* If RichCursor encoding is used, we should extend our\n\t   \"cursor lock area\" (previously set to destination\n\t   rectangle) to the source rectangle as well. */\n\tclient->SoftCursorLockArea(client,\n\t\t\t\t   cr.srcX, cr.srcY, rect.r.w, rect.r.h);\n\n        client->GotCopyRect(client, cr.srcX, cr.srcY, rect.r.w, rect.r.h,\n                            rect.r.x, rect.r.y);\n\n\tbreak;\n      }\n\n      case rfbEncodingRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingCoRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleCoRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleCoRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleCoRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingHextile:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleHextile8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleHextile16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleHextile32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingUltra:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltra8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltra16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltra32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n      case rfbEncodingUltraZip:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltraZip8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltraZip16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltraZip32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n\n      case rfbEncodingTRLE:\n\t  {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleTRLE8(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (client->si.format.greenMax > 0x1F) {\n            if (!HandleTRLE16(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else {\n            if (!HandleTRLE15(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          }\n          break;\n        case 32: {\n          uint32_t maxColor =\n              (client->format.redMax << client->format.redShift) |\n              (client->format.greenMax << client->format.greenShift) |\n              (client->format.blueMax << client->format.blueShift);\n          if ((client->format.bigEndian && (maxColor & 0xff) == 0) ||\n              (!client->format.bigEndian && (maxColor & 0xff000000) == 0)) {\n            if (!HandleTRLE24(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (!client->format.bigEndian && (maxColor & 0xff) == 0) {\n            if (!HandleTRLE24Up(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (client->format.bigEndian && (maxColor & 0xff000000) == 0) {\n            if (!HandleTRLE24Down(client, rect.r.x, rect.r.y, rect.r.w,\n                                  rect.r.h))\n              return FALSE;\n          } else if (!HandleTRLE32(client, rect.r.x, rect.r.y, rect.r.w,\n                                   rect.r.h))\n            return FALSE;\n          break;\n        }\n        }\n        break;\n      }\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      case rfbEncodingZlib:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZlib8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleZlib16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleZlib32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n     }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      case rfbEncodingTight:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleTight8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleTight16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleTight32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n#endif\n      case rfbEncodingZRLE:\n\t/* Fail safe for ZYWRLE unsupport VNC server. */\n\tclient->appData.qualityLevel = 9;\n\t/* fall through */\n      case rfbEncodingZYWRLE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZRLE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (client->si.format.greenMax > 0x1F) {\n\t    if (!HandleZRLE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else {\n\t    if (!HandleZRLE15(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  }\n\t  break;\n\tcase 32:\n\t{\n\t  uint32_t maxColor=(client->format.redMax<<client->format.redShift)|\n\t\t(client->format.greenMax<<client->format.greenShift)|\n\t\t(client->format.blueMax<<client->format.blueShift);\n\t  if ((client->format.bigEndian && (maxColor&0xff)==0) ||\n\t      (!client->format.bigEndian && (maxColor&0xff000000)==0)) {\n\t    if (!HandleZRLE24(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!client->format.bigEndian && (maxColor&0xff)==0) {\n\t    if (!HandleZRLE24Up(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (client->format.bigEndian && (maxColor&0xff000000)==0) {\n\t    if (!HandleZRLE24Down(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!HandleZRLE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\t}\n\tbreak;\n     }\n\n#endif\n\n      default:\n\t {\n\t   rfbBool handled = FALSE;\n\t   rfbClientProtocolExtension* e;\n\n\t   for(e = rfbClientExtensions; !handled && e; e = e->next)\n\t     if(e->handleEncoding && e->handleEncoding(client, &rect))\n\t       handled = TRUE;\n\n\t   if(!handled) {\n\t     rfbClientLog(\"Unknown rect encoding %d\\n\",\n\t\t (int)rect.encoding);\n\t     return FALSE;\n\t   }\n\t }\n      }\n\n      /* Now we may discard \"soft cursor locks\". */\n      client->SoftCursorUnlockScreen(client);\n\n      client->GotFrameBufferUpdate(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n    }\n\n    if (!SendIncrementalFramebufferUpdateRequest(client))\n      return FALSE;\n\n    if (client->FinishedFrameBufferUpdate)\n      client->FinishedFrameBufferUpdate(client);\n\n    break;\n  }\n\n  case rfbBell:\n  {\n    client->Bell(client);\n\n    break;\n  }\n\n  case rfbServerCutText:\n  {\n    char *buffer;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbServerCutTextMsg - 1))\n      return FALSE;\n\n    msg.sct.length = rfbClientSwap32IfLE(msg.sct.length);\n\n    if (msg.sct.length > 1<<20) {\n\t    rfbClientErr(\"Ignoring too big cut text length sent by server: %u B > 1 MB\\n\", (unsigned int)msg.sct.length);\n\t    return FALSE;\n    }  \n\n    buffer = malloc((uint64_t)msg.sct.length+1);\n\n    if (!ReadFromRFBServer(client, buffer, msg.sct.length)) {\n      free(buffer);\n      return FALSE;\n    }\n\n    buffer[msg.sct.length] = 0;\n\n    if (client->GotXCutText)\n      client->GotXCutText(client, buffer, msg.sct.length);\n\n    free(buffer);\n\n    break;\n  }\n\n  case rfbTextChat:\n  {\n      char *buffer=NULL;\n      if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                             sz_rfbTextChatMsg- 1))\n        return FALSE;\n      msg.tc.length = rfbClientSwap32IfLE(msg.sct.length);\n      switch(msg.tc.length) {\n      case rfbTextChatOpen:\n          rfbClientLog(\"Received TextChat Open\\n\");\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatOpen, NULL);\n          break;\n      case rfbTextChatClose:\n          rfbClientLog(\"Received TextChat Close\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatClose, NULL);\n          break;\n      case rfbTextChatFinished:\n          rfbClientLog(\"Received TextChat Finished\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatFinished, NULL);\n          break;\n      default:\n          buffer=malloc(msg.tc.length+1);\n          if (!ReadFromRFBServer(client, buffer, msg.tc.length))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          /* Null Terminate <just in case> */\n          buffer[msg.tc.length]=0;\n          rfbClientLog(\"Received TextChat \\\"%s\\\"\\n\", buffer);\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)msg.tc.length, buffer);\n          free(buffer);\n          break;\n      }\n      break;\n  }\n\n  case rfbXvp:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbXvpMsg -1))\n      return FALSE;\n\n    SetClient2Server(client, rfbXvp);\n    /* technically, we only care what we can *send* to the server\n     * but, we set Server2Client Just in case it ever becomes useful\n     */\n    SetServer2Client(client, rfbXvp);\n\n    if(client->HandleXvpMsg)\n      client->HandleXvpMsg(client, msg.xvp.version, msg.xvp.code);\n\n    break;\n  }\n\n  case rfbResizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbResizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.rsfb.framebufferWidth);\n    client->height = rfbClientSwap16IfLE(msg.rsfb.framebufferHeigth);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  case rfbPalmVNCReSizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbPalmVNCReSizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.prsfb.buffer_w);\n    client->height = rfbClientSwap16IfLE(msg.prsfb.buffer_h);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  default:\n    {\n      rfbBool handled = FALSE;\n      rfbClientProtocolExtension* e;\n\n      for(e = rfbClientExtensions; !handled && e; e = e->next)\n\tif(e->handleMessage && e->handleMessage(client, &msg))\n\t  handled = TRUE;\n\n      if(!handled) {\n\tchar buffer[256];\n\trfbClientLog(\"Unknown message type %d from VNC server\\n\",msg.type);\n\tReadFromRFBServer(client, buffer, 256);\n\treturn FALSE;\n      }\n    }\n  }\n\n  return TRUE;\n}", "func_src_after": "HandleRFBServerMessage(rfbClient* client)\n{\n  rfbServerToClientMsg msg;\n\n  if (client->serverPort==-1)\n    client->vncRec->readTimestamp = TRUE;\n  if (!ReadFromRFBServer(client, (char *)&msg, 1))\n    return FALSE;\n\n  switch (msg.type) {\n\n  case rfbSetColourMapEntries:\n  {\n    /* TODO:\n    int i;\n    uint16_t rgb[3];\n    XColor xc;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbSetColourMapEntriesMsg - 1))\n      return FALSE;\n\n    msg.scme.firstColour = rfbClientSwap16IfLE(msg.scme.firstColour);\n    msg.scme.nColours = rfbClientSwap16IfLE(msg.scme.nColours);\n\n    for (i = 0; i < msg.scme.nColours; i++) {\n      if (!ReadFromRFBServer(client, (char *)rgb, 6))\n\treturn FALSE;\n      xc.pixel = msg.scme.firstColour + i;\n      xc.red = rfbClientSwap16IfLE(rgb[0]);\n      xc.green = rfbClientSwap16IfLE(rgb[1]);\n      xc.blue = rfbClientSwap16IfLE(rgb[2]);\n      xc.flags = DoRed|DoGreen|DoBlue;\n      XStoreColor(dpy, cmap, &xc);\n    }\n    */\n\n    break;\n  }\n\n  case rfbFramebufferUpdate:\n  {\n    rfbFramebufferUpdateRectHeader rect;\n    int linesToRead;\n    int bytesPerLine;\n    int i;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg.fu) + 1,\n\t\t\t   sz_rfbFramebufferUpdateMsg - 1))\n      return FALSE;\n\n    msg.fu.nRects = rfbClientSwap16IfLE(msg.fu.nRects);\n\n    for (i = 0; i < msg.fu.nRects; i++) {\n      if (!ReadFromRFBServer(client, (char *)&rect, sz_rfbFramebufferUpdateRectHeader))\n\treturn FALSE;\n\n      rect.encoding = rfbClientSwap32IfLE(rect.encoding);\n      if (rect.encoding == rfbEncodingLastRect)\n\tbreak;\n\n      rect.r.x = rfbClientSwap16IfLE(rect.r.x);\n      rect.r.y = rfbClientSwap16IfLE(rect.r.y);\n      rect.r.w = rfbClientSwap16IfLE(rect.r.w);\n      rect.r.h = rfbClientSwap16IfLE(rect.r.h);\n\n\n      if (rect.encoding == rfbEncodingXCursor ||\n\t  rect.encoding == rfbEncodingRichCursor) {\n\n\tif (!HandleCursorShape(client,\n\t\t\t       rect.r.x, rect.r.y, rect.r.w, rect.r.h,\n\t\t\t       rect.encoding)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n\n      if (rect.encoding == rfbEncodingPointerPos) {\n\tif (!client->HandleCursorPos(client,rect.r.x, rect.r.y)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n      \n      if (rect.encoding == rfbEncodingKeyboardLedState) {\n          /* OK! We have received a keyboard state message!!! */\n          client->KeyboardLedStateEnabled = 1;\n          if (client->HandleKeyboardLedState!=NULL)\n              client->HandleKeyboardLedState(client, rect.r.x, 0);\n          /* stash it for the future */\n          client->CurrentKeyboardLedState = rect.r.x;\n          continue;\n      }\n\n      if (rect.encoding == rfbEncodingNewFBSize) {\n\tclient->width = rect.r.w;\n\tclient->height = rect.r.h;\n\tclient->updateRect.x = client->updateRect.y = 0;\n\tclient->updateRect.w = client->width;\n\tclient->updateRect.h = client->height;\n\tif (!client->MallocFrameBuffer(client))\n\t  return FALSE;\n\tSendFramebufferUpdateRequest(client, 0, 0, rect.r.w, rect.r.h, FALSE);\n\trfbClientLog(\"Got new framebuffer size: %dx%d\\n\", rect.r.w, rect.r.h);\n\tcontinue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingSupportedMessages) {\n          int loop;\n          if (!ReadFromRFBServer(client, (char *)&client->supportedMessages, sz_rfbSupportedMessages))\n              return FALSE;\n\n          /* msgs is two sets of bit flags of supported messages client2server[] and server2client[] */\n          /* currently ignored by this library */\n\n          rfbClientLog(\"client2server supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.client2server[loop],   client->supportedMessages.client2server[loop+1],\n                client->supportedMessages.client2server[loop+2], client->supportedMessages.client2server[loop+3],\n                client->supportedMessages.client2server[loop+4], client->supportedMessages.client2server[loop+5],\n                client->supportedMessages.client2server[loop+6], client->supportedMessages.client2server[loop+7]);\n\n          rfbClientLog(\"server2client supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.server2client[loop],   client->supportedMessages.server2client[loop+1],\n                client->supportedMessages.server2client[loop+2], client->supportedMessages.server2client[loop+3],\n                client->supportedMessages.server2client[loop+4], client->supportedMessages.server2client[loop+5],\n                client->supportedMessages.server2client[loop+6], client->supportedMessages.server2client[loop+7]);\n          continue;\n      }\n\n      /* rect.r.w=byte count, rect.r.h=# of encodings */\n      if (rect.encoding == rfbEncodingSupportedEncodings) {\n          char *buffer;\n          buffer = malloc(rect.r.w);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n\n          /* buffer now contains rect.r.h # of uint32_t encodings that the server supports */\n          /* currently ignored by this library */\n          free(buffer);\n          continue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingServerIdentity) {\n          char *buffer;\n          buffer = malloc(rect.r.w+1);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          buffer[rect.r.w]=0; /* null terminate, just in case */\n          rfbClientLog(\"Connected to Server \\\"%s\\\"\\n\", buffer);\n          free(buffer);\n          continue;\n      }\n\n      /* rfbEncodingUltraZip is a collection of subrects.   x = # of subrects, and h is always 0 */\n      if (rect.encoding != rfbEncodingUltraZip)\n      {\n        if ((rect.r.x + rect.r.w > client->width) ||\n\t    (rect.r.y + rect.r.h > client->height))\n\t    {\n\t      rfbClientLog(\"Rect too large: %dx%d at (%d, %d)\\n\",\n\t  \t  rect.r.w, rect.r.h, rect.r.x, rect.r.y);\n\t      return FALSE;\n            }\n\n        /* UltraVNC with scaling, will send rectangles with a zero W or H\n         *\n        if ((rect.encoding != rfbEncodingTight) && \n            (rect.r.h * rect.r.w == 0))\n        {\n\t  rfbClientLog(\"Zero size rect - ignoring (encoding=%d (0x%08x) %dx, %dy, %dw, %dh)\\n\", rect.encoding, rect.encoding, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n\t  continue;\n        }\n        */\n        \n        /* If RichCursor encoding is used, we should prevent collisions\n\t   between framebuffer updates and cursor drawing operations. */\n        client->SoftCursorLockArea(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n      }\n\n      switch (rect.encoding) {\n\n      case rfbEncodingRaw: {\n\tint y=rect.r.y, h=rect.r.h;\n\n\tbytesPerLine = rect.r.w * client->format.bitsPerPixel / 8;\n\t/* RealVNC 4.x-5.x on OSX can induce bytesPerLine==0, \n\t   usually during GPU accel. */\n\t/* Regardless of cause, do not divide by zero. */\n\tlinesToRead = bytesPerLine ? (RFB_BUFFER_SIZE / bytesPerLine) : 0;\n\n\twhile (linesToRead && h > 0) {\n\t  if (linesToRead > h)\n\t    linesToRead = h;\n\n\t  if (!ReadFromRFBServer(client, client->buffer,bytesPerLine * linesToRead))\n\t    return FALSE;\n\n\t  client->GotBitmap(client, (uint8_t *)client->buffer,\n\t\t\t   rect.r.x, y, rect.r.w,linesToRead);\n\n\t  h -= linesToRead;\n\t  y += linesToRead;\n\n\t}\n\tbreak;\n      } \n\n      case rfbEncodingCopyRect:\n      {\n\trfbCopyRect cr;\n\n\tif (!ReadFromRFBServer(client, (char *)&cr, sz_rfbCopyRect))\n\t  return FALSE;\n\n\tcr.srcX = rfbClientSwap16IfLE(cr.srcX);\n\tcr.srcY = rfbClientSwap16IfLE(cr.srcY);\n\n\t/* If RichCursor encoding is used, we should extend our\n\t   \"cursor lock area\" (previously set to destination\n\t   rectangle) to the source rectangle as well. */\n\tclient->SoftCursorLockArea(client,\n\t\t\t\t   cr.srcX, cr.srcY, rect.r.w, rect.r.h);\n\n        client->GotCopyRect(client, cr.srcX, cr.srcY, rect.r.w, rect.r.h,\n                            rect.r.x, rect.r.y);\n\n\tbreak;\n      }\n\n      case rfbEncodingRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingCoRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleCoRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleCoRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleCoRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingHextile:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleHextile8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleHextile16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleHextile32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingUltra:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltra8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltra16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltra32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n      case rfbEncodingUltraZip:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltraZip8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltraZip16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltraZip32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n\n      case rfbEncodingTRLE:\n\t  {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleTRLE8(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (client->si.format.greenMax > 0x1F) {\n            if (!HandleTRLE16(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else {\n            if (!HandleTRLE15(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          }\n          break;\n        case 32: {\n          uint32_t maxColor =\n              (client->format.redMax << client->format.redShift) |\n              (client->format.greenMax << client->format.greenShift) |\n              (client->format.blueMax << client->format.blueShift);\n          if ((client->format.bigEndian && (maxColor & 0xff) == 0) ||\n              (!client->format.bigEndian && (maxColor & 0xff000000) == 0)) {\n            if (!HandleTRLE24(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (!client->format.bigEndian && (maxColor & 0xff) == 0) {\n            if (!HandleTRLE24Up(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (client->format.bigEndian && (maxColor & 0xff000000) == 0) {\n            if (!HandleTRLE24Down(client, rect.r.x, rect.r.y, rect.r.w,\n                                  rect.r.h))\n              return FALSE;\n          } else if (!HandleTRLE32(client, rect.r.x, rect.r.y, rect.r.w,\n                                   rect.r.h))\n            return FALSE;\n          break;\n        }\n        }\n        break;\n      }\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      case rfbEncodingZlib:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZlib8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleZlib16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleZlib32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n     }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      case rfbEncodingTight:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleTight8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleTight16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleTight32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n#endif\n      case rfbEncodingZRLE:\n\t/* Fail safe for ZYWRLE unsupport VNC server. */\n\tclient->appData.qualityLevel = 9;\n\t/* fall through */\n      case rfbEncodingZYWRLE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZRLE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (client->si.format.greenMax > 0x1F) {\n\t    if (!HandleZRLE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else {\n\t    if (!HandleZRLE15(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  }\n\t  break;\n\tcase 32:\n\t{\n\t  uint32_t maxColor=(client->format.redMax<<client->format.redShift)|\n\t\t(client->format.greenMax<<client->format.greenShift)|\n\t\t(client->format.blueMax<<client->format.blueShift);\n\t  if ((client->format.bigEndian && (maxColor&0xff)==0) ||\n\t      (!client->format.bigEndian && (maxColor&0xff000000)==0)) {\n\t    if (!HandleZRLE24(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!client->format.bigEndian && (maxColor&0xff)==0) {\n\t    if (!HandleZRLE24Up(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (client->format.bigEndian && (maxColor&0xff000000)==0) {\n\t    if (!HandleZRLE24Down(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!HandleZRLE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\t}\n\tbreak;\n     }\n\n#endif\n\n      default:\n\t {\n\t   rfbBool handled = FALSE;\n\t   rfbClientProtocolExtension* e;\n\n\t   for(e = rfbClientExtensions; !handled && e; e = e->next)\n\t     if(e->handleEncoding && e->handleEncoding(client, &rect))\n\t       handled = TRUE;\n\n\t   if(!handled) {\n\t     rfbClientLog(\"Unknown rect encoding %d\\n\",\n\t\t (int)rect.encoding);\n\t     return FALSE;\n\t   }\n\t }\n      }\n\n      /* Now we may discard \"soft cursor locks\". */\n      client->SoftCursorUnlockScreen(client);\n\n      client->GotFrameBufferUpdate(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n    }\n\n    if (!SendIncrementalFramebufferUpdateRequest(client))\n      return FALSE;\n\n    if (client->FinishedFrameBufferUpdate)\n      client->FinishedFrameBufferUpdate(client);\n\n    break;\n  }\n\n  case rfbBell:\n  {\n    client->Bell(client);\n\n    break;\n  }\n\n  case rfbServerCutText:\n  {\n    char *buffer;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbServerCutTextMsg - 1))\n      return FALSE;\n\n    msg.sct.length = rfbClientSwap32IfLE(msg.sct.length);\n\n    if (msg.sct.length > 1<<20) {\n\t    rfbClientErr(\"Ignoring too big cut text length sent by server: %u B > 1 MB\\n\", (unsigned int)msg.sct.length);\n\t    return FALSE;\n    }  \n\n    buffer = malloc(msg.sct.length+1);\n\n    if (!ReadFromRFBServer(client, buffer, msg.sct.length)) {\n      free(buffer);\n      return FALSE;\n    }\n\n    buffer[msg.sct.length] = 0;\n\n    if (client->GotXCutText)\n      client->GotXCutText(client, buffer, msg.sct.length);\n\n    free(buffer);\n\n    break;\n  }\n\n  case rfbTextChat:\n  {\n      char *buffer=NULL;\n      if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                             sz_rfbTextChatMsg- 1))\n        return FALSE;\n      msg.tc.length = rfbClientSwap32IfLE(msg.sct.length);\n      switch(msg.tc.length) {\n      case rfbTextChatOpen:\n          rfbClientLog(\"Received TextChat Open\\n\");\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatOpen, NULL);\n          break;\n      case rfbTextChatClose:\n          rfbClientLog(\"Received TextChat Close\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatClose, NULL);\n          break;\n      case rfbTextChatFinished:\n          rfbClientLog(\"Received TextChat Finished\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatFinished, NULL);\n          break;\n      default:\n          buffer=malloc(msg.tc.length+1);\n          if (!ReadFromRFBServer(client, buffer, msg.tc.length))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          /* Null Terminate <just in case> */\n          buffer[msg.tc.length]=0;\n          rfbClientLog(\"Received TextChat \\\"%s\\\"\\n\", buffer);\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)msg.tc.length, buffer);\n          free(buffer);\n          break;\n      }\n      break;\n  }\n\n  case rfbXvp:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbXvpMsg -1))\n      return FALSE;\n\n    SetClient2Server(client, rfbXvp);\n    /* technically, we only care what we can *send* to the server\n     * but, we set Server2Client Just in case it ever becomes useful\n     */\n    SetServer2Client(client, rfbXvp);\n\n    if(client->HandleXvpMsg)\n      client->HandleXvpMsg(client, msg.xvp.version, msg.xvp.code);\n\n    break;\n  }\n\n  case rfbResizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbResizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.rsfb.framebufferWidth);\n    client->height = rfbClientSwap16IfLE(msg.rsfb.framebufferHeigth);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  case rfbPalmVNCReSizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbPalmVNCReSizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.prsfb.buffer_w);\n    client->height = rfbClientSwap16IfLE(msg.prsfb.buffer_h);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  default:\n    {\n      rfbBool handled = FALSE;\n      rfbClientProtocolExtension* e;\n\n      for(e = rfbClientExtensions; !handled && e; e = e->next)\n\tif(e->handleMessage && e->handleMessage(client, &msg))\n\t  handled = TRUE;\n\n      if(!handled) {\n\tchar buffer[256];\n\trfbClientLog(\"Unknown message type %d from VNC server\\n\",msg.type);\n\tReadFromRFBServer(client, buffer, 256);\n\treturn FALSE;\n      }\n    }\n  }\n\n  return TRUE;\n}", "line_changes": {"deleted": [{"line_no": 517, "char_start": 15578, "char_end": 15627, "line": "    buffer = malloc((uint64_t)msg.sct.length+1);\n"}], "added": [{"line_no": 517, "char_start": 15578, "char_end": 15617, "line": "    buffer = malloc(msg.sct.length+1);\n"}]}, "char_changes": {"deleted": [{"char_start": 15598, "char_end": 15608, "chars": "(uint64_t)"}], "added": []}, "commit_link": "github.com/LibVNC/libvncserver/commit/a64c3b37af9a6c8f8009d7516874b8d266b42bae", "file_name": "libvncclient/rfbproto.c", "vul_type": "cwe-787"}
{"func_name": "enc_untrusted_create_wait_queue", "func_src_before": "int32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}", "func_src_after": "int32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  if (!TrustedPrimitives::IsOutsideEnclave(queue, sizeof(int32_t))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_create_wait_queue: queue should be in untrusted memory\");\n  }\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 10, "char_start": 435, "char_end": 505, "line": "  if (!TrustedPrimitives::IsOutsideEnclave(queue, sizeof(int32_t))) {\n"}, {"line_no": 11, "char_start": 505, "char_end": 545, "line": "    TrustedPrimitives::BestEffortAbort(\n"}, {"line_no": 12, "char_start": 545, "char_end": 626, "line": "        \"enc_untrusted_create_wait_queue: queue should be in untrusted memory\");\n"}, {"line_no": 13, "char_start": 626, "char_end": 630, "line": "  }\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 438, "char_end": 633, "chars": "f (!TrustedPrimitives::IsOutsideEnclave(queue, sizeof(int32_t))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_create_wait_queue: queue should be in untrusted memory\");\n  }\n  i"}]}, "commit_link": "github.com/google/asylo/commit/a37fb6a0e7daf30134dbbf357c9a518a1026aa02", "file_name": "asylo/platform/host_call/trusted/concurrency.cc", "vul_type": "cwe-787"}
{"func_name": "FromkLinuxSockAddr", "func_src_before": "bool FromkLinuxSockAddr(const struct klinux_sockaddr *input,\n                        socklen_t input_len, struct sockaddr *output,\n                        socklen_t *output_len,\n                        void (*abort_handler)(const char *)) {\n  if (!input || !output || !output_len || input_len == 0) {\n    output = nullptr;\n    return false;\n  }\n\n  int16_t klinux_family = input->klinux_sa_family;\n  if (klinux_family == kLinux_AF_UNIX) {\n    struct klinux_sockaddr_un *klinux_sockaddr_un_in =\n        const_cast<struct klinux_sockaddr_un *>(\n            reinterpret_cast<const struct klinux_sockaddr_un *>(input));\n\n    struct sockaddr_un sockaddr_un_out;\n    sockaddr_un_out.sun_family = AF_UNIX;\n    InitializeToZeroArray(sockaddr_un_out.sun_path);\n    ReinterpretCopyArray(\n        sockaddr_un_out.sun_path, klinux_sockaddr_un_in->klinux_sun_path,\n        std::min(sizeof(sockaddr_un_out.sun_path),\n                 sizeof(klinux_sockaddr_un_in->klinux_sun_path)));\n    CopySockaddr(&sockaddr_un_out, sizeof(sockaddr_un_out), output, output_len);\n  } else if (klinux_family == kLinux_AF_INET) {\n    struct klinux_sockaddr_in *klinux_sockaddr_in_in =\n        const_cast<struct klinux_sockaddr_in *>(\n            reinterpret_cast<const struct klinux_sockaddr_in *>(input));\n\n    struct sockaddr_in sockaddr_in_out;\n    sockaddr_in_out.sin_family = AF_INET;\n    sockaddr_in_out.sin_port = klinux_sockaddr_in_in->klinux_sin_port;\n    InitializeToZeroSingle(&sockaddr_in_out.sin_addr);\n    ReinterpretCopySingle(&sockaddr_in_out.sin_addr,\n                          &klinux_sockaddr_in_in->klinux_sin_addr);\n    InitializeToZeroArray(sockaddr_in_out.sin_zero);\n    ReinterpretCopyArray(sockaddr_in_out.sin_zero,\n                         klinux_sockaddr_in_in->klinux_sin_zero);\n    CopySockaddr(&sockaddr_in_out, sizeof(sockaddr_in_out), output, output_len);\n  } else if (klinux_family == kLinux_AF_INET6) {\n    struct klinux_sockaddr_in6 *klinux_sockaddr_in6_in =\n        const_cast<struct klinux_sockaddr_in6 *>(\n            reinterpret_cast<const struct klinux_sockaddr_in6 *>(input));\n\n    struct sockaddr_in6 sockaddr_in6_out;\n    sockaddr_in6_out.sin6_family = AF_INET6;\n    sockaddr_in6_out.sin6_port = klinux_sockaddr_in6_in->klinux_sin6_port;\n    sockaddr_in6_out.sin6_flowinfo =\n        klinux_sockaddr_in6_in->klinux_sin6_flowinfo;\n    sockaddr_in6_out.sin6_scope_id =\n        klinux_sockaddr_in6_in->klinux_sin6_scope_id;\n    InitializeToZeroSingle(&sockaddr_in6_out.sin6_addr);\n    ReinterpretCopySingle(&sockaddr_in6_out.sin6_addr,\n                          &klinux_sockaddr_in6_in->klinux_sin6_addr);\n    CopySockaddr(&sockaddr_in6_out, sizeof(sockaddr_in6_out), output,\n                 output_len);\n  } else if (klinux_family == kLinux_AF_UNSPEC) {\n    output = nullptr;\n    *output_len = 0;\n  } else {\n    if (abort_handler != nullptr) {\n      std::string message = absl::StrCat(\n          \"Type conversion error - Unsupported AF family: \", klinux_family);\n      abort_handler(message.c_str());\n    } else {\n      abort();\n    }\n  }\n  return true;\n}", "func_src_after": "bool FromkLinuxSockAddr(const struct klinux_sockaddr *input,\n                        socklen_t input_len, struct sockaddr *output,\n                        socklen_t *output_len,\n                        void (*abort_handler)(const char *)) {\n  if (!input || !output || !output_len || input_len == 0) {\n    output = nullptr;\n    return false;\n  }\n\n  int16_t klinux_family = input->klinux_sa_family;\n  if (klinux_family == kLinux_AF_UNIX) {\n    if (input_len < sizeof(struct klinux_sockaddr_un)) {\n      return false;\n    }\n\n    struct klinux_sockaddr_un *klinux_sockaddr_un_in =\n        const_cast<struct klinux_sockaddr_un *>(\n            reinterpret_cast<const struct klinux_sockaddr_un *>(input));\n\n    struct sockaddr_un sockaddr_un_out;\n    sockaddr_un_out.sun_family = AF_UNIX;\n    InitializeToZeroArray(sockaddr_un_out.sun_path);\n    ReinterpretCopyArray(\n        sockaddr_un_out.sun_path, klinux_sockaddr_un_in->klinux_sun_path,\n        std::min(sizeof(sockaddr_un_out.sun_path),\n                 sizeof(klinux_sockaddr_un_in->klinux_sun_path)));\n    CopySockaddr(&sockaddr_un_out, sizeof(sockaddr_un_out), output, output_len);\n  } else if (klinux_family == kLinux_AF_INET) {\n    if (input_len < sizeof(struct klinux_sockaddr_in)) {\n      return false;\n    }\n    struct klinux_sockaddr_in *klinux_sockaddr_in_in =\n        const_cast<struct klinux_sockaddr_in *>(\n            reinterpret_cast<const struct klinux_sockaddr_in *>(input));\n\n    struct sockaddr_in sockaddr_in_out;\n    sockaddr_in_out.sin_family = AF_INET;\n    sockaddr_in_out.sin_port = klinux_sockaddr_in_in->klinux_sin_port;\n    InitializeToZeroSingle(&sockaddr_in_out.sin_addr);\n    ReinterpretCopySingle(&sockaddr_in_out.sin_addr,\n                          &klinux_sockaddr_in_in->klinux_sin_addr);\n    InitializeToZeroArray(sockaddr_in_out.sin_zero);\n    ReinterpretCopyArray(sockaddr_in_out.sin_zero,\n                         klinux_sockaddr_in_in->klinux_sin_zero);\n    CopySockaddr(&sockaddr_in_out, sizeof(sockaddr_in_out), output, output_len);\n  } else if (klinux_family == kLinux_AF_INET6) {\n    if (input_len < sizeof(struct klinux_sockaddr_in6)) {\n      return false;\n    }\n\n    struct klinux_sockaddr_in6 *klinux_sockaddr_in6_in =\n        const_cast<struct klinux_sockaddr_in6 *>(\n            reinterpret_cast<const struct klinux_sockaddr_in6 *>(input));\n\n    struct sockaddr_in6 sockaddr_in6_out;\n    sockaddr_in6_out.sin6_family = AF_INET6;\n    sockaddr_in6_out.sin6_port = klinux_sockaddr_in6_in->klinux_sin6_port;\n    sockaddr_in6_out.sin6_flowinfo =\n        klinux_sockaddr_in6_in->klinux_sin6_flowinfo;\n    sockaddr_in6_out.sin6_scope_id =\n        klinux_sockaddr_in6_in->klinux_sin6_scope_id;\n    InitializeToZeroSingle(&sockaddr_in6_out.sin6_addr);\n    ReinterpretCopySingle(&sockaddr_in6_out.sin6_addr,\n                          &klinux_sockaddr_in6_in->klinux_sin6_addr);\n    CopySockaddr(&sockaddr_in6_out, sizeof(sockaddr_in6_out), output,\n                 output_len);\n  } else if (klinux_family == kLinux_AF_UNSPEC) {\n    output = nullptr;\n    *output_len = 0;\n  } else {\n    if (abort_handler != nullptr) {\n      std::string message = absl::StrCat(\n          \"Type conversion error - Unsupported AF family: \", klinux_family);\n      abort_handler(message.c_str());\n    } else {\n      abort();\n    }\n  }\n  return true;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 12, "char_start": 438, "char_end": 495, "line": "    if (input_len < sizeof(struct klinux_sockaddr_un)) {\n"}, {"line_no": 13, "char_start": 495, "char_end": 515, "line": "      return false;\n"}, {"line_no": 14, "char_start": 515, "char_end": 521, "line": "    }\n"}, {"line_no": 15, "char_start": 521, "char_end": 522, "line": "\n"}, {"line_no": 29, "char_start": 1182, "char_end": 1239, "line": "    if (input_len < sizeof(struct klinux_sockaddr_in)) {\n"}, {"line_no": 30, "char_start": 1239, "char_end": 1259, "line": "      return false;\n"}, {"line_no": 31, "char_start": 1259, "char_end": 1265, "line": "    }\n"}, {"line_no": 47, "char_start": 2072, "char_end": 2130, "line": "    if (input_len < sizeof(struct klinux_sockaddr_in6)) {\n"}, {"line_no": 48, "char_start": 2130, "char_end": 2150, "line": "      return false;\n"}, {"line_no": 49, "char_start": 2150, "char_end": 2156, "line": "    }\n"}, {"line_no": 50, "char_start": 2156, "char_end": 2157, "line": "\n"}]}, "char_changes": {"deleted": [{"char_start": 493, "char_end": 493, "chars": ""}, {"char_start": 1856, "char_end": 1856, "chars": ""}], "added": [{"char_start": 442, "char_end": 526, "chars": "if (input_len < sizeof(struct klinux_sockaddr_un)) {\n      return false;\n    }\n\n    "}, {"char_start": 1182, "char_end": 1265, "chars": "    if (input_len < sizeof(struct klinux_sockaddr_in)) {\n      return false;\n    }\n"}, {"char_start": 2071, "char_end": 2156, "chars": "\n    if (input_len < sizeof(struct klinux_sockaddr_in6)) {\n      return false;\n    }\n"}]}, "commit_link": "github.com/google/asylo/commit/bda9772e7872b0d2b9bee32930cf7a4983837b39", "file_name": "asylo/platform/system_call/type_conversions/manual_types_functions.cc", "vul_type": "cwe-787"}
{"func_name": "opj_pi_create_decode", "func_src_before": "opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,\n\t\t\t\t\t\t\t\t\t\topj_cp_t *p_cp,\n\t\t\t\t\t\t\t\t\t\tOPJ_UINT32 p_tile_no)\n{\n\t/* loop */\n\tOPJ_UINT32 pino;\n\tOPJ_UINT32 compno, resno;\n\n\t/* to store w, h, dx and dy fro all components and resolutions */\n\tOPJ_UINT32 * l_tmp_data;\n\tOPJ_UINT32 ** l_tmp_ptr;\n\n\t/* encoding prameters to set */\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\tOPJ_UINT32 l_bound;\n\tOPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;\n\tOPJ_UINT32 l_data_stride;\n\n\t/* pointers */\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t *l_tccp = 00;\n\topj_pi_comp_t *l_current_comp = 00;\n\topj_image_comp_t * l_img_comp = 00;\n\topj_pi_iterator_t * l_current_pi = 00;\n\tOPJ_UINT32 * l_encoding_value_ptr = 00;\n\n\t/* preconditions in debug */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\t/* initializations */\n\tl_tcp = &p_cp->tcps[p_tile_no];\n\tl_bound = l_tcp->numpocs+1;\n\n\tl_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n\tl_tmp_data = (OPJ_UINT32*)opj_malloc(\n\t\tl_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n\tif\n\t\t(! l_tmp_data)\n\t{\n\t\treturn 00;\n\t}\n\tl_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n\t\tp_image->numcomps * sizeof(OPJ_UINT32 *));\n\tif\n\t\t(! l_tmp_ptr)\n\t{\n\t\topj_free(l_tmp_data);\n\t\treturn 00;\n\t}\n\n\t/* memory allocation for pi */\n\tl_pi = opj_pi_create(p_image, p_cp, p_tile_no);\n\tif (!l_pi) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\treturn 00;\n\t}\n\n\tl_encoding_value_ptr = l_tmp_data;\n\t/* update pointer array */\n\tfor\n\t\t(compno = 0; compno < p_image->numcomps; ++compno)\n\t{\n\t\tl_tmp_ptr[compno] = l_encoding_value_ptr;\n\t\tl_encoding_value_ptr += l_data_stride;\n\t}\n\t/* get encoding parameters */\n\topj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);\n\n\t/* step calculations */\n\tl_step_p = 1;\n\tl_step_c = l_max_prec * l_step_p;\n\tl_step_r = p_image->numcomps * l_step_c;\n\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator */\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include */\n\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n\tif\n\t\t(!l_current_pi->include)\n\t{\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}\n\n\t/* special treatment for the first packet iterator */\n\tl_current_comp = l_current_pi->comps;\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\n\tl_current_pi->tx0 = l_tx0;\n\tl_current_pi->ty0 = l_ty0;\n\tl_current_pi->tx1 = l_tx1;\n\tl_current_pi->ty1 = l_ty1;\n\n\t/*l_current_pi->dx = l_img_comp->dx;*/\n\t/*l_current_pi->dy = l_img_comp->dy;*/\n\n\tl_current_pi->step_p = l_step_p;\n\tl_current_pi->step_c = l_step_c;\n\tl_current_pi->step_r = l_step_r;\n\tl_current_pi->step_l = l_step_l;\n\n\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\tfor\n\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t{\n\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\tl_current_comp->dx = l_img_comp->dx;\n\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t/* resolutions have already been initialized */\n\t\tfor\n\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t{\n\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t++l_res;\n\t\t}\n\t\t++l_current_comp;\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n\t++l_current_pi;\n\n\tfor (pino = 1 ; pino<l_bound ; ++pino )\n\t{\n\t\tl_current_comp = l_current_pi->comps;\n\t\tl_img_comp = p_image->comps;\n\t\tl_tccp = l_tcp->tccps;\n\n\t\tl_current_pi->tx0 = l_tx0;\n\t\tl_current_pi->ty0 = l_ty0;\n\t\tl_current_pi->tx1 = l_tx1;\n\t\tl_current_pi->ty1 = l_ty1;\n\t\t/*l_current_pi->dx = l_dx_min;*/\n\t\t/*l_current_pi->dy = l_dy_min;*/\n\t\tl_current_pi->step_p = l_step_p;\n\t\tl_current_pi->step_c = l_step_c;\n\t\tl_current_pi->step_r = l_step_r;\n\t\tl_current_pi->step_l = l_step_l;\n\n\t\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\t\tfor\n\t\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t\t{\n\t\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\t\tl_current_comp->dx = l_img_comp->dx;\n\t\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t\t/* resolutions have already been initialized */\n\t\t\tfor\n\t\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t\t{\n\t\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t\t++l_res;\n\t\t\t}\n\t\t\t++l_current_comp;\n\t\t\t++l_img_comp;\n\t\t\t++l_tccp;\n\t\t}\n\t\t/* special treatment*/\n\t\tl_current_pi->include = (l_current_pi-1)->include;\n\t\t++l_current_pi;\n\t}\n\topj_free(l_tmp_data);\n\tl_tmp_data = 00;\n\topj_free(l_tmp_ptr);\n\tl_tmp_ptr = 00;\n\tif\n\t\t(l_tcp->POC)\n\t{\n\t\topj_pi_update_decode_poc (l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\telse\n\t{\n\t\topj_pi_update_decode_not_poc(l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\treturn l_pi;\n}", "func_src_after": "opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,\n\t\t\t\t\t\t\t\t\t\topj_cp_t *p_cp,\n\t\t\t\t\t\t\t\t\t\tOPJ_UINT32 p_tile_no)\n{\n\t/* loop */\n\tOPJ_UINT32 pino;\n\tOPJ_UINT32 compno, resno;\n\n\t/* to store w, h, dx and dy fro all components and resolutions */\n\tOPJ_UINT32 * l_tmp_data;\n\tOPJ_UINT32 ** l_tmp_ptr;\n\n\t/* encoding prameters to set */\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\tOPJ_UINT32 l_bound;\n\tOPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;\n\tOPJ_UINT32 l_data_stride;\n\n\t/* pointers */\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t *l_tccp = 00;\n\topj_pi_comp_t *l_current_comp = 00;\n\topj_image_comp_t * l_img_comp = 00;\n\topj_pi_iterator_t * l_current_pi = 00;\n\tOPJ_UINT32 * l_encoding_value_ptr = 00;\n\n\t/* preconditions in debug */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\t/* initializations */\n\tl_tcp = &p_cp->tcps[p_tile_no];\n\tl_bound = l_tcp->numpocs+1;\n\n\tl_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n\tl_tmp_data = (OPJ_UINT32*)opj_malloc(\n\t\tl_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n\tif\n\t\t(! l_tmp_data)\n\t{\n\t\treturn 00;\n\t}\n\tl_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n\t\tp_image->numcomps * sizeof(OPJ_UINT32 *));\n\tif\n\t\t(! l_tmp_ptr)\n\t{\n\t\topj_free(l_tmp_data);\n\t\treturn 00;\n\t}\n\n\t/* memory allocation for pi */\n\tl_pi = opj_pi_create(p_image, p_cp, p_tile_no);\n\tif (!l_pi) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\treturn 00;\n\t}\n\n\tl_encoding_value_ptr = l_tmp_data;\n\t/* update pointer array */\n\tfor\n\t\t(compno = 0; compno < p_image->numcomps; ++compno)\n\t{\n\t\tl_tmp_ptr[compno] = l_encoding_value_ptr;\n\t\tl_encoding_value_ptr += l_data_stride;\n\t}\n\t/* get encoding parameters */\n\topj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);\n\n\t/* step calculations */\n\tl_step_p = 1;\n\tl_step_c = l_max_prec * l_step_p;\n\tl_step_r = p_image->numcomps * l_step_c;\n\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator */\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include */\n\t/* prevent an integer overflow issue */\n\tl_current_pi->include = 00;\n\tif (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U)))\n\t{\n\t\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n\t}\n\n\tif\n\t\t(!l_current_pi->include)\n\t{\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}\n\n\t/* special treatment for the first packet iterator */\n\tl_current_comp = l_current_pi->comps;\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\n\tl_current_pi->tx0 = l_tx0;\n\tl_current_pi->ty0 = l_ty0;\n\tl_current_pi->tx1 = l_tx1;\n\tl_current_pi->ty1 = l_ty1;\n\n\t/*l_current_pi->dx = l_img_comp->dx;*/\n\t/*l_current_pi->dy = l_img_comp->dy;*/\n\n\tl_current_pi->step_p = l_step_p;\n\tl_current_pi->step_c = l_step_c;\n\tl_current_pi->step_r = l_step_r;\n\tl_current_pi->step_l = l_step_l;\n\n\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\tfor\n\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t{\n\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\tl_current_comp->dx = l_img_comp->dx;\n\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t/* resolutions have already been initialized */\n\t\tfor\n\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t{\n\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t++l_res;\n\t\t}\n\t\t++l_current_comp;\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n\t++l_current_pi;\n\n\tfor (pino = 1 ; pino<l_bound ; ++pino )\n\t{\n\t\tl_current_comp = l_current_pi->comps;\n\t\tl_img_comp = p_image->comps;\n\t\tl_tccp = l_tcp->tccps;\n\n\t\tl_current_pi->tx0 = l_tx0;\n\t\tl_current_pi->ty0 = l_ty0;\n\t\tl_current_pi->tx1 = l_tx1;\n\t\tl_current_pi->ty1 = l_ty1;\n\t\t/*l_current_pi->dx = l_dx_min;*/\n\t\t/*l_current_pi->dy = l_dy_min;*/\n\t\tl_current_pi->step_p = l_step_p;\n\t\tl_current_pi->step_c = l_step_c;\n\t\tl_current_pi->step_r = l_step_r;\n\t\tl_current_pi->step_l = l_step_l;\n\n\t\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\t\tfor\n\t\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t\t{\n\t\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\t\tl_current_comp->dx = l_img_comp->dx;\n\t\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t\t/* resolutions have already been initialized */\n\t\t\tfor\n\t\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t\t{\n\t\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t\t++l_res;\n\t\t\t}\n\t\t\t++l_current_comp;\n\t\t\t++l_img_comp;\n\t\t\t++l_tccp;\n\t\t}\n\t\t/* special treatment*/\n\t\tl_current_pi->include = (l_current_pi-1)->include;\n\t\t++l_current_pi;\n\t}\n\topj_free(l_tmp_data);\n\tl_tmp_data = 00;\n\topj_free(l_tmp_ptr);\n\tl_tmp_ptr = 00;\n\tif\n\t\t(l_tcp->POC)\n\t{\n\t\topj_pi_update_decode_poc (l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\telse\n\t{\n\t\topj_pi_update_decode_not_poc(l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\treturn l_pi;\n}", "line_changes": {"deleted": [{"line_no": 86, "char_start": 2139, "char_end": 2242, "line": "\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n"}], "added": [{"line_no": 86, "char_start": 2139, "char_end": 2180, "line": "\t/* prevent an integer overflow issue */\n"}, {"line_no": 87, "char_start": 2180, "char_end": 2209, "line": "\tl_current_pi->include = 00;\n"}, {"line_no": 88, "char_start": 2209, "char_end": 2264, "line": "\tif (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U)))\n"}, {"line_no": 89, "char_start": 2264, "char_end": 2267, "line": "\t{\n"}, {"line_no": 90, "char_start": 2267, "char_end": 2371, "line": "\t\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n"}, {"line_no": 91, "char_start": 2371, "char_end": 2374, "line": "\t}\n"}, {"line_no": 92, "char_start": 2374, "char_end": 2375, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 2140, "char_end": 2269, "chars": "/* prevent an integer overflow issue */\n\tl_current_pi->include = 00;\n\tif (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U)))\n\t{\n\t\t"}, {"char_start": 2370, "char_end": 2374, "chars": "\n\t}\n"}]}, "commit_link": "github.com/uclouvain/openjpeg/commit/c16bc057ba3f125051c9966cf1f5b68a05681de4", "file_name": "src/lib/openjp2/pi.c", "vul_type": "cwe-787"}
{"func_name": "opj_j2k_set_cinema_parameters", "func_src_before": "static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters,\n        opj_image_t *image, opj_event_mgr_t *p_manager)\n{\n    /* Configure cinema parameters */\n    int i;\n\n    /* No tiling */\n    parameters->tile_size_on = OPJ_FALSE;\n    parameters->cp_tdx = 1;\n    parameters->cp_tdy = 1;\n\n    /* One tile part for each component */\n    parameters->tp_flag = 'C';\n    parameters->tp_on = 1;\n\n    /* Tile and Image shall be at (0,0) */\n    parameters->cp_tx0 = 0;\n    parameters->cp_ty0 = 0;\n    parameters->image_offset_x0 = 0;\n    parameters->image_offset_y0 = 0;\n\n    /* Codeblock size= 32*32 */\n    parameters->cblockw_init = 32;\n    parameters->cblockh_init = 32;\n\n    /* Codeblock style: no mode switch enabled */\n    parameters->mode = 0;\n\n    /* No ROI */\n    parameters->roi_compno = -1;\n\n    /* No subsampling */\n    parameters->subsampling_dx = 1;\n    parameters->subsampling_dy = 1;\n\n    /* 9-7 transform */\n    parameters->irreversible = 1;\n\n    /* Number of layers */\n    if (parameters->tcp_numlayers > 1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"1 single quality layer\"\n                      \"-> Number of layers forced to 1 (rather than %d)\\n\"\n                      \"-> Rate of the last layer (%3.1f) will be used\",\n                      parameters->tcp_numlayers,\n                      parameters->tcp_rates[parameters->tcp_numlayers - 1]);\n        parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];\n        parameters->tcp_numlayers = 1;\n    }\n\n    /* Resolution levels */\n    switch (parameters->rsiz) {\n    case OPJ_PROFILE_CINEMA_2K:\n        if (parameters->numresolution > 6) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                          \"Number of decomposition levels <= 5\\n\"\n                          \"-> Number of decomposition levels forced to 5 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 6;\n        }\n        break;\n    case OPJ_PROFILE_CINEMA_4K:\n        if (parameters->numresolution < 2) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 1 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 1;\n        } else if (parameters->numresolution > 7) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 6 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 7;\n        }\n        break;\n    default :\n        break;\n    }\n\n    /* Precincts */\n    parameters->csty |= 0x01;\n    parameters->res_spec = parameters->numresolution - 1;\n    for (i = 0; i < parameters->res_spec; i++) {\n        parameters->prcw_init[i] = 256;\n        parameters->prch_init[i] = 256;\n    }\n\n    /* The progression order shall be CPRL */\n    parameters->prog_order = OPJ_CPRL;\n\n    /* Progression order changes for 4K, disallowed for 2K */\n    if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {\n        parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,\n                              parameters->numresolution);\n    } else {\n        parameters->numpocs = 0;\n    }\n\n    /* Limited bit-rate */\n    parameters->cp_disto_alloc = 1;\n    if (parameters->max_cs_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\\n\");\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n    }\n\n    if (parameters->max_comp_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\\n\");\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n    }\n\n    parameters->tcp_rates[0] = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *\n                               image->comps[0].h * image->comps[0].prec) /\n                               (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *\n                                       image->comps[0].dy);\n\n}", "func_src_after": "static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters,\n        opj_image_t *image, opj_event_mgr_t *p_manager)\n{\n    /* Configure cinema parameters */\n    int i;\n\n    /* No tiling */\n    parameters->tile_size_on = OPJ_FALSE;\n    parameters->cp_tdx = 1;\n    parameters->cp_tdy = 1;\n\n    /* One tile part for each component */\n    parameters->tp_flag = 'C';\n    parameters->tp_on = 1;\n\n    /* Tile and Image shall be at (0,0) */\n    parameters->cp_tx0 = 0;\n    parameters->cp_ty0 = 0;\n    parameters->image_offset_x0 = 0;\n    parameters->image_offset_y0 = 0;\n\n    /* Codeblock size= 32*32 */\n    parameters->cblockw_init = 32;\n    parameters->cblockh_init = 32;\n\n    /* Codeblock style: no mode switch enabled */\n    parameters->mode = 0;\n\n    /* No ROI */\n    parameters->roi_compno = -1;\n\n    /* No subsampling */\n    parameters->subsampling_dx = 1;\n    parameters->subsampling_dy = 1;\n\n    /* 9-7 transform */\n    parameters->irreversible = 1;\n\n    /* Number of layers */\n    if (parameters->tcp_numlayers > 1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"1 single quality layer\"\n                      \"-> Number of layers forced to 1 (rather than %d)\\n\"\n                      \"-> Rate of the last layer (%3.1f) will be used\",\n                      parameters->tcp_numlayers,\n                      parameters->tcp_rates[parameters->tcp_numlayers - 1]);\n        parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];\n        parameters->tcp_numlayers = 1;\n    }\n\n    /* Resolution levels */\n    switch (parameters->rsiz) {\n    case OPJ_PROFILE_CINEMA_2K:\n        if (parameters->numresolution > 6) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                          \"Number of decomposition levels <= 5\\n\"\n                          \"-> Number of decomposition levels forced to 5 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 6;\n        }\n        break;\n    case OPJ_PROFILE_CINEMA_4K:\n        if (parameters->numresolution < 2) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 1 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 1;\n        } else if (parameters->numresolution > 7) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 6 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 7;\n        }\n        break;\n    default :\n        break;\n    }\n\n    /* Precincts */\n    parameters->csty |= 0x01;\n    if (parameters->numresolution == 1) {\n        parameters->res_spec = 1;\n        parameters->prcw_init[0] = 128;\n        parameters->prch_init[0] = 128;\n    } else {\n        parameters->res_spec = parameters->numresolution - 1;\n        for (i = 0; i < parameters->res_spec; i++) {\n            parameters->prcw_init[i] = 256;\n            parameters->prch_init[i] = 256;\n        }\n    }\n\n    /* The progression order shall be CPRL */\n    parameters->prog_order = OPJ_CPRL;\n\n    /* Progression order changes for 4K, disallowed for 2K */\n    if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {\n        parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,\n                              parameters->numresolution);\n    } else {\n        parameters->numpocs = 0;\n    }\n\n    /* Limited bit-rate */\n    parameters->cp_disto_alloc = 1;\n    if (parameters->max_cs_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\\n\");\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n    }\n\n    if (parameters->max_comp_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\\n\");\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n    }\n\n    parameters->tcp_rates[0] = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *\n                               image->comps[0].h * image->comps[0].prec) /\n                               (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *\n                                       image->comps[0].dy);\n\n}", "line_changes": {"deleted": [{"line_no": 87, "char_start": 3193, "char_end": 3251, "line": "    parameters->res_spec = parameters->numresolution - 1;\n"}, {"line_no": 88, "char_start": 3251, "char_end": 3300, "line": "    for (i = 0; i < parameters->res_spec; i++) {\n"}, {"line_no": 89, "char_start": 3300, "char_end": 3340, "line": "        parameters->prcw_init[i] = 256;\n"}, {"line_no": 90, "char_start": 3340, "char_end": 3380, "line": "        parameters->prch_init[i] = 256;\n"}], "added": [{"line_no": 87, "char_start": 3193, "char_end": 3235, "line": "    if (parameters->numresolution == 1) {\n"}, {"line_no": 88, "char_start": 3235, "char_end": 3269, "line": "        parameters->res_spec = 1;\n"}, {"line_no": 89, "char_start": 3269, "char_end": 3309, "line": "        parameters->prcw_init[0] = 128;\n"}, {"line_no": 90, "char_start": 3309, "char_end": 3349, "line": "        parameters->prch_init[0] = 128;\n"}, {"line_no": 91, "char_start": 3349, "char_end": 3362, "line": "    } else {\n"}, {"line_no": 92, "char_start": 3362, "char_end": 3424, "line": "        parameters->res_spec = parameters->numresolution - 1;\n"}, {"line_no": 93, "char_start": 3424, "char_end": 3477, "line": "        for (i = 0; i < parameters->res_spec; i++) {\n"}, {"line_no": 94, "char_start": 3477, "char_end": 3521, "line": "            parameters->prcw_init[i] = 256;\n"}, {"line_no": 95, "char_start": 3521, "char_end": 3565, "line": "            parameters->prch_init[i] = 256;\n"}, {"line_no": 96, "char_start": 3565, "char_end": 3575, "line": "        }\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 3197, "char_end": 3370, "chars": "if (parameters->numresolution == 1) {\n        parameters->res_spec = 1;\n        parameters->prcw_init[0] = 128;\n        parameters->prch_init[0] = 128;\n    } else {\n        "}, {"char_start": 3424, "char_end": 3428, "chars": "    "}, {"char_start": 3485, "char_end": 3489, "chars": "    "}, {"char_start": 3521, "char_end": 3523, "chars": "  "}, {"char_start": 3531, "char_end": 3533, "chars": "  "}, {"char_start": 3564, "char_end": 3574, "chars": "\n        }"}]}, "commit_link": "github.com/uclouvain/openjpeg/commit/4241ae6fbbf1de9658764a80944dc8108f2b4154", "file_name": "src/lib/openjp2/j2k.c", "vul_type": "cwe-787"}
{"func_name": "adminchild", "func_src_before": "void * adminchild(struct clientparam* param) {\n int i, res;\n char * buf;\n char username[256];\n char *sb;\n char *req = NULL;\n struct printparam pp;\n int contentlen = 0;\n int isform = 0;\n\n pp.inbuf = 0;\n pp.cp = param;\n\n buf = myalloc(LINESIZE);\n if(!buf) {RETURN(555);}\n i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\\n', conf.timeouts[STRING_S]);\n if(i<5 || ((buf[0]!='G' || buf[1]!='E' || buf[2]!='T' || buf[3]!=' ' || buf[4]!='/') && \n\t   (buf[0]!='P' || buf[1]!='O' || buf[2]!='S' || buf[3]!='T' || buf[4]!=' ' || buf[5]!='/')))\n {\n\tRETURN(701);\n }\n buf[i] = 0;\n sb = strchr(buf+5, ' ');\n if(!sb){\n\tRETURN(702);\n }\n *sb = 0;\n req = mystrdup(buf + ((*buf == 'P')? 6 : 5));\n while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\\n', conf.timeouts[STRING_S])) > 2){\n\tbuf[i] = 0;\n\tif(i > 19 && (!strncasecmp(buf, \"authorization\", 13))){\n\t\tsb = strchr(buf, ':');\n\t\tif(!sb)continue;\n\t\t++sb;\n\t\twhile(isspace(*sb))sb++;\n\t\tif(!*sb || strncasecmp(sb, \"basic\", 5)){\n\t\t\tcontinue;\n\t\t}\n\t\tsb+=5;\n\t\twhile(isspace(*sb))sb++;\n\t\ti = de64((unsigned char *)sb, (unsigned char *)username, 255);\n\t\tif(i<=0)continue;\n\t\tusername[i] = 0;\n\t\tsb = strchr((char *)username, ':');\n\t\tif(sb){\n\t\t\t*sb = 0;\n\t\t\tif(param->password)myfree(param->password);\n\t\t\tparam->password = (unsigned char *)mystrdup(sb+1);\n\t\t}\n\t\tif(param->username) myfree(param->username);\n\t\tparam->username = (unsigned char *)mystrdup(username);\n\t\tcontinue;\n\t}\n\telse if(i > 15 && (!strncasecmp(buf, \"content-length:\", 15))){\n\t\tsb = buf + 15;\n\t\twhile(isspace(*sb))sb++;\n\t\tcontentlen = atoi(sb);\n\t}\n\telse if(i > 13 && (!strncasecmp(buf, \"content-type:\", 13))){\n\t\tsb = buf + 13;\n\t\twhile(isspace(*sb))sb++;\n\t\tif(!strncasecmp(sb, \"x-www-form-urlencoded\", 21)) isform = 1;\n\t}\n }\n param->operation = ADMIN;\n if(isform && contentlen) {\n\tprintstr(&pp, \"HTTP/1.0 100 Continue\\r\\n\\r\\n\");\n\tstdpr(&pp, NULL, 0);\n }\n res = (*param->srv->authfunc)(param);\n if(res && res != 10) {\n\tprintstr(&pp, authreq);\n\tRETURN(res);\n }\n if(param->srv->singlepacket || param->redirected){\n\tif(*req == 'C') req[1] = 0;\n\telse *req = 0;\n }\n sprintf(buf, ok, conf.stringtable?(char *)conf.stringtable[2]:\"3proxy\", conf.stringtable?(char *)conf.stringtable[2]:\"3[APA3A] tiny proxy\", conf.stringtable?(char *)conf.stringtable[3]:\"\");\n if(*req != 'S') printstr(&pp, buf);\n switch(*req){\n\tcase 'C':\n\t\tprintstr(&pp, counters);\n\t\t{\n\t\t\tstruct trafcount *cp; \n\t\t\tint num = 0;\n\t\t\tfor(cp = conf.trafcounter; cp; cp = cp->next, num++){\n\t\t\t int inbuf = 0;\n\n\t\t\t if(cp->ace && (param->srv->singlepacket || param->redirected)){\n\t\t\t\tif(!ACLmatches(cp->ace, param))continue;\n\t\t\t }\n\t\t\t if(req[1] == 'S' && atoi(req+2) == num) cp->disabled=0;\n\t\t\t if(req[1] == 'D' && atoi(req+2) == num) cp->disabled=1;\n\t\t\t inbuf += sprintf(buf,\t\"<tr>\"\n\t\t\t\t\t\t\"<td>%s</td><td><A HREF=\\'/C%c%d\\'>%s</A></td><td>\",\n\t\t\t\t\t\t(cp->comment)?cp->comment:\"&nbsp;\",\n\t\t\t\t\t\t(cp->disabled)?'S':'D',\n\t\t\t\t\t\tnum,\n\t\t\t\t\t\t(cp->disabled)?\"NO\":\"YES\"\n\t\t\t\t\t);\n\t\t\t if(!cp->ace || !cp->ace->users){\n\t\t\t\tinbuf += sprintf(buf+inbuf, \"<center>ANY</center>\");\n\t\t\t }\n\t\t\t else {\n\t\t\t\tinbuf += printuserlist(buf+inbuf, LINESIZE-800, cp->ace->users, \",<br />\\r\\n\");\n\t\t\t }\n\t\t\t inbuf += sprintf(buf+inbuf, \"</td><td>\");\n\t\t\t if(!cp->ace || !cp->ace->src){\n\t\t\t\tinbuf += sprintf(buf+inbuf, \"<center>ANY</center>\");\n\t\t\t }\n\t\t\t else {\n\t\t\t\tinbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->src, \",<br />\\r\\n\");\n\t\t\t }\n\t\t\t inbuf += sprintf(buf+inbuf, \"</td><td>\");\n\t\t\t if(!cp->ace || !cp->ace->dst){\n\t\t\t\tinbuf += sprintf(buf+inbuf, \"<center>ANY</center>\");\n\t\t\t }\n\t\t\t else {\n\t\t\t\tinbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->dst, \",<br />\\r\\n\");\n\t\t\t }\n\t\t\t inbuf += sprintf(buf+inbuf, \"</td><td>\");\n\t\t\t if(!cp->ace || !cp->ace->ports){\n\t\t\t\tinbuf += sprintf(buf+inbuf, \"<center>ANY</center>\");\n\t\t\t }\n\t\t\t else {\n\t\t\t\tinbuf += printportlist(buf+inbuf, LINESIZE-128, cp->ace->ports, \",<br />\\r\\n\");\n\t\t\t }\n\t\t\t if(cp->type == NONE) {\n\t\t\t  inbuf += sprintf(buf+inbuf,\t\n\t\t\t\t\t\"</td><td colspan=\\'6\\' align=\\'center\\'>exclude from limitation</td></tr>\\r\\n\"\n\t\t\t\t );\n\t\t\t }\n\t\t\t else {\n\t\t\t  inbuf += sprintf(buf+inbuf,\t\n\t\t\t\t\t\"</td><td>%\"PRINTF_INT64_MODIFIER\"u</td>\"\n\t\t\t\t\t\"<td>MB%s</td>\"\n\t\t\t\t\t\"<td>%\"PRINTF_INT64_MODIFIER\"u</td>\"\n\t\t\t\t\t\"<td>%s</td>\",\n\t\t\t\t cp->traflim64 / (1024 * 1024),\n\t\t\t\t rotations[cp->type],\n\t\t\t\t cp->traf64,\n\t\t\t\t cp->cleared?ctime(&cp->cleared):\"never\"\n\t\t\t\t);\n\t\t\t inbuf += sprintf(buf + inbuf,\n\t\t\t\t\t\"<td>%s</td>\"\n\t\t\t\t\t\"<td>%i</td>\"\n\t\t\t\t\t\"</tr>\\r\\n\",\n\n\t\t\t\t cp->updated?ctime(&cp->updated):\"never\",\n\t\t\t\t cp->number\n\t\t\t\t);\n\t\t\t }\n\t\t\t printstr(&pp, buf);\n\t\t\t}\n\n\t\t}\n\t\tprintstr(&pp, counterstail);\n\t\tbreak;\n\t\t\n\tcase 'R':\n\t\tconf.needreload = 1;\n\t\tprintstr(&pp, \"<h3>Reload scheduled</h3>\");\n\t\tbreak;\n\tcase 'S':\n\t\t{\n\t\t\tif(req[1] == 'X'){\n\t\t\t\tprintstr(&pp, style);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintstr(&pp, xml);\n\t\t\tprintval(conf.services, TYPE_SERVER, 0, &pp);\n\t\t\tprintstr(&pp, postxml);\n\t\t}\n\t\t\tbreak;\n\tcase 'F':\n\t\t{\n\t\t\tFILE *fp;\n\t\t\tchar buf[256];\n\n\t\t\tfp = confopen();\n\t\t\tif(!fp){\n\t\t\t\tprintstr(&pp, \"<h3><font color=\\\"red\\\">Failed to open config file</font></h3>\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\tprintstr(&pp, \"<h3>Please be careful editing config file remotely</h3>\");\n\t\t\t\tprintstr(&pp, \"<form method=\\\"POST\\\" action=\\\"/U\\\"><textarea cols=\\\"80\\\" rows=\\\"30\\\" name=\\\"conffile\\\">\");\n\t\t\t\twhile(fgets(buf, 256, fp)){\n\t\t\t\t\tprintstr(&pp, buf);\n\t\t\t\t}\n\t\t\t\tif(!writable) fclose(fp);\n\t\t\t\tprintstr(&pp, \"</textarea><br><input type=\\\"Submit\\\"></form>\");\n\t\t\tbreak;\n\t\t}\n\tcase 'U':\n\t\t{\n\t\t\tint l=0;\n\t\t\tint error = 0;\n\n\t\t\tif(!writable || fseek(writable, 0, 0)){\n\t\t\t\terror = 1;\n\t\t\t}\n\t\t\twhile((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '+', conf.timeouts[STRING_S])) > 0){\n\t\t\t\tif(i > (contentlen - l)) i = (contentlen - l);\n\t\t\t\tbuf[i] = 0;\n\t\t\t\tif(!l){\n\t\t\t\t\tif(strncasecmp(buf, \"conffile=\", 9)) error = 1;\n\t\t\t\t}\n\t\t\t\tif(!error){\n\t\t\t\t\tdecodeurl((unsigned char *)buf, 1);\n\t\t\t\t\tfprintf(writable, \"%s\", l? buf : buf + 9);\n\t\t\t\t}\n\t\t\t\tl += i;\n\t\t\t\tif(l >= contentlen) break;\n\t\t\t}\n\t\t\tif(writable && !error){\n\t\t\t\tfflush(writable);\n#ifndef _WINCE\n\t\t\t\tftruncate(fileno(writable), ftell(writable));\n#endif\n\t\t\t}\n\t\t\tprintstr(&pp, error?    \"<h3><font color=\\\"red\\\">Config file is not writable</font></h3>Make sure you have \\\"writable\\\" command in configuration file\":\n\t\t\t\t\t\t\"<h3>Configuration updated</h3>\");\n\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintstr(&pp, (char *)conf.stringtable[WEBBANNERS]);\n\t\tbreak;\n }\n if(*req != 'S') printstr(&pp, tail);\n\nCLEANRET:\n\n\n printstr(&pp, NULL);\n if(buf) myfree(buf);\n (*param->srv->logfunc)(param, (unsigned char *)req);\n if(req)myfree(req);\n freeparam(param);\n return (NULL);\n}", "func_src_after": "void * adminchild(struct clientparam* param) {\n int i, res;\n char * buf;\n char username[256];\n char *sb;\n char *req = NULL;\n struct printparam pp;\n unsigned contentlen = 0;\n int isform = 0;\n\n pp.inbuf = 0;\n pp.cp = param;\n\n buf = myalloc(LINESIZE);\n if(!buf) {RETURN(555);}\n i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\\n', conf.timeouts[STRING_S]);\n if(i<5 || ((buf[0]!='G' || buf[1]!='E' || buf[2]!='T' || buf[3]!=' ' || buf[4]!='/') && \n\t   (buf[0]!='P' || buf[1]!='O' || buf[2]!='S' || buf[3]!='T' || buf[4]!=' ' || buf[5]!='/')))\n {\n\tRETURN(701);\n }\n buf[i] = 0;\n sb = strchr(buf+5, ' ');\n if(!sb){\n\tRETURN(702);\n }\n *sb = 0;\n req = mystrdup(buf + ((*buf == 'P')? 6 : 5));\n while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\\n', conf.timeouts[STRING_S])) > 2){\n\tbuf[i] = 0;\n\tif(i > 19 && (!strncasecmp(buf, \"authorization\", 13))){\n\t\tsb = strchr(buf, ':');\n\t\tif(!sb)continue;\n\t\t++sb;\n\t\twhile(isspace(*sb))sb++;\n\t\tif(!*sb || strncasecmp(sb, \"basic\", 5)){\n\t\t\tcontinue;\n\t\t}\n\t\tsb+=5;\n\t\twhile(isspace(*sb))sb++;\n\t\ti = de64((unsigned char *)sb, (unsigned char *)username, 255);\n\t\tif(i<=0)continue;\n\t\tusername[i] = 0;\n\t\tsb = strchr((char *)username, ':');\n\t\tif(sb){\n\t\t\t*sb = 0;\n\t\t\tif(param->password)myfree(param->password);\n\t\t\tparam->password = (unsigned char *)mystrdup(sb+1);\n\t\t}\n\t\tif(param->username) myfree(param->username);\n\t\tparam->username = (unsigned char *)mystrdup(username);\n\t\tcontinue;\n\t}\n\telse if(i > 15 && (!strncasecmp(buf, \"content-length:\", 15))){\n\t\tsb = buf + 15;\n\t\twhile(isspace(*sb))sb++;\n\t\tsscanf(sb, \"%u\", &contentlen);\n\t\tif(contentlen > LINESIZE*1024) contentlen = 0;\n\t}\n\telse if(i > 13 && (!strncasecmp(buf, \"content-type:\", 13))){\n\t\tsb = buf + 13;\n\t\twhile(isspace(*sb))sb++;\n\t\tif(!strncasecmp(sb, \"x-www-form-urlencoded\", 21)) isform = 1;\n\t}\n }\n param->operation = ADMIN;\n if(isform && contentlen) {\n\tprintstr(&pp, \"HTTP/1.0 100 Continue\\r\\n\\r\\n\");\n\tstdpr(&pp, NULL, 0);\n }\n res = (*param->srv->authfunc)(param);\n if(res && res != 10) {\n\tprintstr(&pp, authreq);\n\tRETURN(res);\n }\n if(param->srv->singlepacket || param->redirected){\n\tif(*req == 'C') req[1] = 0;\n\telse *req = 0;\n }\n sprintf(buf, ok, conf.stringtable?(char *)conf.stringtable[2]:\"3proxy\", conf.stringtable?(char *)conf.stringtable[2]:\"3[APA3A] tiny proxy\", conf.stringtable?(char *)conf.stringtable[3]:\"\");\n if(*req != 'S') printstr(&pp, buf);\n switch(*req){\n\tcase 'C':\n\t\tprintstr(&pp, counters);\n\t\t{\n\t\t\tstruct trafcount *cp; \n\t\t\tint num = 0;\n\t\t\tfor(cp = conf.trafcounter; cp; cp = cp->next, num++){\n\t\t\t int inbuf = 0;\n\n\t\t\t if(cp->ace && (param->srv->singlepacket || param->redirected)){\n\t\t\t\tif(!ACLmatches(cp->ace, param))continue;\n\t\t\t }\n\t\t\t if(req[1] == 'S' && atoi(req+2) == num) cp->disabled=0;\n\t\t\t if(req[1] == 'D' && atoi(req+2) == num) cp->disabled=1;\n\t\t\t inbuf += sprintf(buf,\t\"<tr>\"\n\t\t\t\t\t\t\"<td>%s</td><td><A HREF=\\'/C%c%d\\'>%s</A></td><td>\",\n\t\t\t\t\t\t(cp->comment)?cp->comment:\"&nbsp;\",\n\t\t\t\t\t\t(cp->disabled)?'S':'D',\n\t\t\t\t\t\tnum,\n\t\t\t\t\t\t(cp->disabled)?\"NO\":\"YES\"\n\t\t\t\t\t);\n\t\t\t if(!cp->ace || !cp->ace->users){\n\t\t\t\tinbuf += sprintf(buf+inbuf, \"<center>ANY</center>\");\n\t\t\t }\n\t\t\t else {\n\t\t\t\tinbuf += printuserlist(buf+inbuf, LINESIZE-800, cp->ace->users, \",<br />\\r\\n\");\n\t\t\t }\n\t\t\t inbuf += sprintf(buf+inbuf, \"</td><td>\");\n\t\t\t if(!cp->ace || !cp->ace->src){\n\t\t\t\tinbuf += sprintf(buf+inbuf, \"<center>ANY</center>\");\n\t\t\t }\n\t\t\t else {\n\t\t\t\tinbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->src, \",<br />\\r\\n\");\n\t\t\t }\n\t\t\t inbuf += sprintf(buf+inbuf, \"</td><td>\");\n\t\t\t if(!cp->ace || !cp->ace->dst){\n\t\t\t\tinbuf += sprintf(buf+inbuf, \"<center>ANY</center>\");\n\t\t\t }\n\t\t\t else {\n\t\t\t\tinbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->dst, \",<br />\\r\\n\");\n\t\t\t }\n\t\t\t inbuf += sprintf(buf+inbuf, \"</td><td>\");\n\t\t\t if(!cp->ace || !cp->ace->ports){\n\t\t\t\tinbuf += sprintf(buf+inbuf, \"<center>ANY</center>\");\n\t\t\t }\n\t\t\t else {\n\t\t\t\tinbuf += printportlist(buf+inbuf, LINESIZE-128, cp->ace->ports, \",<br />\\r\\n\");\n\t\t\t }\n\t\t\t if(cp->type == NONE) {\n\t\t\t  inbuf += sprintf(buf+inbuf,\t\n\t\t\t\t\t\"</td><td colspan=\\'6\\' align=\\'center\\'>exclude from limitation</td></tr>\\r\\n\"\n\t\t\t\t );\n\t\t\t }\n\t\t\t else {\n\t\t\t  inbuf += sprintf(buf+inbuf,\t\n\t\t\t\t\t\"</td><td>%\"PRINTF_INT64_MODIFIER\"u</td>\"\n\t\t\t\t\t\"<td>MB%s</td>\"\n\t\t\t\t\t\"<td>%\"PRINTF_INT64_MODIFIER\"u</td>\"\n\t\t\t\t\t\"<td>%s</td>\",\n\t\t\t\t cp->traflim64 / (1024 * 1024),\n\t\t\t\t rotations[cp->type],\n\t\t\t\t cp->traf64,\n\t\t\t\t cp->cleared?ctime(&cp->cleared):\"never\"\n\t\t\t\t);\n\t\t\t inbuf += sprintf(buf + inbuf,\n\t\t\t\t\t\"<td>%s</td>\"\n\t\t\t\t\t\"<td>%i</td>\"\n\t\t\t\t\t\"</tr>\\r\\n\",\n\n\t\t\t\t cp->updated?ctime(&cp->updated):\"never\",\n\t\t\t\t cp->number\n\t\t\t\t);\n\t\t\t }\n\t\t\t printstr(&pp, buf);\n\t\t\t}\n\n\t\t}\n\t\tprintstr(&pp, counterstail);\n\t\tbreak;\n\t\t\n\tcase 'R':\n\t\tconf.needreload = 1;\n\t\tprintstr(&pp, \"<h3>Reload scheduled</h3>\");\n\t\tbreak;\n\tcase 'S':\n\t\t{\n\t\t\tif(req[1] == 'X'){\n\t\t\t\tprintstr(&pp, style);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintstr(&pp, xml);\n\t\t\tprintval(conf.services, TYPE_SERVER, 0, &pp);\n\t\t\tprintstr(&pp, postxml);\n\t\t}\n\t\t\tbreak;\n\tcase 'F':\n\t\t{\n\t\t\tFILE *fp;\n\t\t\tchar buf[256];\n\n\t\t\tfp = confopen();\n\t\t\tif(!fp){\n\t\t\t\tprintstr(&pp, \"<h3><font color=\\\"red\\\">Failed to open config file</font></h3>\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\tprintstr(&pp, \"<h3>Please be careful editing config file remotely</h3>\");\n\t\t\t\tprintstr(&pp, \"<form method=\\\"POST\\\" action=\\\"/U\\\" enctype=\\\"application/x-www-form-urlencoded\\\"><textarea cols=\\\"80\\\" rows=\\\"30\\\" name=\\\"conffile\\\">\");\n\t\t\t\twhile(fgets(buf, 256, fp)){\n\t\t\t\t\tprintstr(&pp, buf);\n\t\t\t\t}\n\t\t\t\tif(!writable) fclose(fp);\n\t\t\t\tprintstr(&pp, \"</textarea><br><input type=\\\"Submit\\\"></form>\");\n\t\t\tbreak;\n\t\t}\n\tcase 'U':\n\t\t{\n\t\t\tunsigned l=0;\n\t\t\tint error = 0;\n\n\t\t\tif(!writable || !contentlen || fseek(writable, 0, 0)){\n\t\t\t\terror = 1;\n\t\t\t}\n\t\t\twhile(l < contentlen && (i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, (contentlen - l) > LINESIZE - 1?LINESIZE - 1:contentlen - l, '+', conf.timeouts[STRING_S])) > 0){\n\t\t\t\tif(i > (contentlen - l)) i = (contentlen - l);\n\t\t\t\tif(!l){\n\t\t\t\t\tif(i<9 || strncasecmp(buf, \"conffile=\", 9)) error = 1;\n\t\t\t\t}\n\t\t\t\tif(!error){\n\t\t\t\t\tbuf[i] = 0;\n\t\t\t\t\tdecodeurl((unsigned char *)buf, 1);\n\t\t\t\t\tfprintf(writable, \"%s\", l? buf : buf + 9);\n\t\t\t\t}\n\t\t\t\tl += i;\n\t\t\t}\n\t\t\tif(writable && !error){\n\t\t\t\tfflush(writable);\n#ifndef _WINCE\n\t\t\t\tftruncate(fileno(writable), ftell(writable));\n#endif\n\t\t\t}\n\t\t\tprintstr(&pp, error?    \"<h3><font color=\\\"red\\\">Config file is not writable</font></h3>Make sure you have \\\"writable\\\" command in configuration file\":\n\t\t\t\t\t\t\"<h3>Configuration updated</h3>\");\n\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintstr(&pp, (char *)conf.stringtable[WEBBANNERS]);\n\t\tbreak;\n }\n if(*req != 'S') printstr(&pp, tail);\n\nCLEANRET:\n\n\n printstr(&pp, NULL);\n if(buf) myfree(buf);\n (*param->srv->logfunc)(param, (unsigned char *)req);\n if(req)myfree(req);\n freeparam(param);\n return (NULL);\n}", "line_changes": {"deleted": [{"line_no": 8, "char_start": 147, "char_end": 168, "line": " int contentlen = 0;\n"}, {"line_no": 57, "char_start": 1557, "char_end": 1582, "line": "\t\tcontentlen = atoi(sb);\n"}, {"line_no": 187, "char_start": 5131, "char_end": 5242, "line": "\t\t\t\tprintstr(&pp, \"<form method=\\\"POST\\\" action=\\\"/U\\\"><textarea cols=\\\"80\\\" rows=\\\"30\\\" name=\\\"conffile\\\">\");\n"}, {"line_no": 197, "char_start": 5432, "char_end": 5444, "line": "\t\t\tint l=0;\n"}, {"line_no": 200, "char_start": 5463, "char_end": 5506, "line": "\t\t\tif(!writable || fseek(writable, 0, 0)){\n"}, {"line_no": 203, "char_start": 5526, "char_end": 5643, "line": "\t\t\twhile((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '+', conf.timeouts[STRING_S])) > 0){\n"}, {"line_no": 205, "char_start": 5694, "char_end": 5710, "line": "\t\t\t\tbuf[i] = 0;\n"}, {"line_no": 207, "char_start": 5722, "char_end": 5775, "line": "\t\t\t\t\tif(strncasecmp(buf, \"conffile=\", 9)) error = 1;\n"}, {"line_no": 214, "char_start": 5904, "char_end": 5935, "line": "\t\t\t\tif(l >= contentlen) break;\n"}], "added": [{"line_no": 8, "char_start": 147, "char_end": 173, "line": " unsigned contentlen = 0;\n"}, {"line_no": 57, "char_start": 1562, "char_end": 1595, "line": "\t\tsscanf(sb, \"%u\", &contentlen);\n"}, {"line_no": 58, "char_start": 1595, "char_end": 1644, "line": "\t\tif(contentlen > LINESIZE*1024) contentlen = 0;\n"}, {"line_no": 188, "char_start": 5193, "char_end": 5350, "line": "\t\t\t\tprintstr(&pp, \"<form method=\\\"POST\\\" action=\\\"/U\\\" enctype=\\\"application/x-www-form-urlencoded\\\"><textarea cols=\\\"80\\\" rows=\\\"30\\\" name=\\\"conffile\\\">\");\n"}, {"line_no": 198, "char_start": 5540, "char_end": 5557, "line": "\t\t\tunsigned l=0;\n"}, {"line_no": 201, "char_start": 5576, "char_end": 5634, "line": "\t\t\tif(!writable || !contentlen || fseek(writable, 0, 0)){\n"}, {"line_no": 204, "char_start": 5654, "char_end": 5836, "line": "\t\t\twhile(l < contentlen && (i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, (contentlen - l) > LINESIZE - 1?LINESIZE - 1:contentlen - l, '+', conf.timeouts[STRING_S])) > 0){\n"}, {"line_no": 207, "char_start": 5899, "char_end": 5959, "line": "\t\t\t\t\tif(i<9 || strncasecmp(buf, \"conffile=\", 9)) error = 1;\n"}, {"line_no": 210, "char_start": 5981, "char_end": 5998, "line": "\t\t\t\t\tbuf[i] = 0;\n"}]}, "char_changes": {"deleted": [{"char_start": 150, "char_end": 151, "chars": "t"}, {"char_start": 1570, "char_end": 1571, "chars": "="}, {"char_start": 1572, "char_end": 1579, "chars": "atoi(sb"}, {"char_start": 5437, "char_end": 5438, "chars": "t"}, {"char_start": 5698, "char_end": 5714, "chars": "buf[i] = 0;\n\t\t\t\t"}, {"char_start": 5902, "char_end": 5933, "chars": ";\n\t\t\t\tif(l >= contentlen) break"}], "added": [{"char_start": 148, "char_end": 151, "chars": "uns"}, {"char_start": 152, "char_end": 153, "chars": "g"}, {"char_start": 154, "char_end": 156, "chars": "ed"}, {"char_start": 1564, "char_end": 1582, "chars": "sscanf(sb, \"%u\", &"}, {"char_start": 1592, "char_end": 1597, "chars": ");\n\t\t"}, {"char_start": 1598, "char_end": 1599, "chars": "f"}, {"char_start": 1600, "char_end": 1626, "chars": "contentlen > LINESIZE*1024"}, {"char_start": 1627, "char_end": 1642, "chars": " contentlen = 0"}, {"char_start": 5247, "char_end": 5293, "chars": " enctype=\\\"application/x-www-form-urlencoded\\\""}, {"char_start": 5543, "char_end": 5546, "chars": "uns"}, {"char_start": 5547, "char_end": 5548, "chars": "g"}, {"char_start": 5549, "char_end": 5551, "chars": "ed"}, {"char_start": 5595, "char_end": 5610, "chars": "!contentlen || "}, {"char_start": 5663, "char_end": 5681, "chars": "l < contentlen && "}, {"char_start": 5737, "char_end": 5756, "chars": " (contentlen - l) >"}, {"char_start": 5769, "char_end": 5797, "chars": "?LINESIZE - 1:contentlen - l"}, {"char_start": 5907, "char_end": 5914, "chars": "i<9 || "}, {"char_start": 5981, "char_end": 5998, "chars": "\t\t\t\t\tbuf[i] = 0;\n"}]}, "commit_link": "github.com/z3APA3A/3proxy/commit/3b67dc844789dc0f00e934270c7b349bcb547865", "file_name": "src/webadmin.c", "vul_type": "cwe-787"}
{"func_name": "ecall_restore", "func_src_before": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(\n          output_len, sizeof(uint64_t))) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input/output found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}", "func_src_after": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(\n          output_len, sizeof(uint64_t)) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(output,\n                                                              *output_len)) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input/output found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}", "line_changes": {"deleted": [{"line_no": 6, "char_start": 322, "char_end": 365, "line": "          output_len, sizeof(uint64_t))) {\n"}], "added": [{"line_no": 6, "char_start": 322, "char_end": 365, "line": "          output_len, sizeof(uint64_t)) ||\n"}, {"line_no": 7, "char_start": 365, "char_end": 435, "line": "      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(output,\n"}, {"line_no": 8, "char_start": 435, "char_end": 513, "line": "                                                              *output_len)) {\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 361, "char_end": 509, "chars": " ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(output,\n                                                              *output_len)"}]}, "commit_link": "github.com/google/asylo/commit/382da2b8b09cbf928668a2445efb778f76bd9c8a", "file_name": "asylo/platform/primitives/sgx/ecalls.cc", "vul_type": "cwe-787"}
{"func_name": "handle_PORT", "func_src_before": "static void handle_PORT(ctrl_t *ctrl, char *str)\n{\n\tint a, b, c, d, e, f;\n\tchar addr[INET_ADDRSTRLEN];\n\tstruct sockaddr_in sin;\n\n\tif (ctrl->data_sd > 0) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t}\n\n\t/* Convert PORT command's argument to IP address + port */\n\tsscanf(str, \"%d,%d,%d,%d,%d,%d\", &a, &b, &c, &d, &e, &f);\n\tsprintf(addr, \"%d.%d.%d.%d\", a, b, c, d);\n\n\t/* Check IPv4 address using inet_aton(), throw away converted result */\n\tif (!inet_aton(addr, &(sin.sin_addr))) {\n\t\tERR(0, \"Invalid address '%s' given to PORT command\", addr);\n\t\tsend_msg(ctrl->sd, \"500 Illegal PORT command.\\r\\n\");\n\t\treturn;\n\t}\n\n\tstrlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));\n\tctrl->data_port = e * 256 + f;\n\n\tDBG(\"Client PORT command accepted for %s:%d\", ctrl->data_address, ctrl->data_port);\n\tsend_msg(ctrl->sd, \"200 PORT command successful.\\r\\n\");\n}", "func_src_after": "static void handle_PORT(ctrl_t *ctrl, char *str)\n{\n\tint a, b, c, d, e, f;\n\tchar addr[INET_ADDRSTRLEN];\n\tstruct sockaddr_in sin;\n\n\tif (ctrl->data_sd > 0) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t}\n\n\t/* Convert PORT command's argument to IP address + port */\n\tsscanf(str, \"%d,%d,%d,%d,%d,%d\", &a, &b, &c, &d, &e, &f);\n\tsnprintf(addr, sizeof(addr), \"%d.%d.%d.%d\", a, b, c, d);\n\n\t/* Check IPv4 address using inet_aton(), throw away converted result */\n\tif (!inet_aton(addr, &(sin.sin_addr))) {\n\t\tERR(0, \"Invalid address '%s' given to PORT command\", addr);\n\t\tsend_msg(ctrl->sd, \"500 Illegal PORT command.\\r\\n\");\n\t\treturn;\n\t}\n\n\tstrlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));\n\tctrl->data_port = e * 256 + f;\n\n\tDBG(\"Client PORT command accepted for %s:%d\", ctrl->data_address, ctrl->data_port);\n\tsend_msg(ctrl->sd, \"200 PORT command successful.\\r\\n\");\n}", "line_changes": {"deleted": [{"line_no": 15, "char_start": 360, "char_end": 403, "line": "\tsprintf(addr, \"%d.%d.%d.%d\", a, b, c, d);\n"}], "added": [{"line_no": 15, "char_start": 360, "char_end": 418, "line": "\tsnprintf(addr, sizeof(addr), \"%d.%d.%d.%d\", a, b, c, d);\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 362, "char_end": 363, "chars": "n"}, {"char_start": 374, "char_end": 388, "chars": ", sizeof(addr)"}]}, "commit_link": "github.com/troglobit/uftpd/commit/0fb2c031ce0ace07cc19cd2cb2143c4b5a63c9dd", "file_name": "src/ftpcmd.c", "vul_type": "cwe-787"}
{"func_name": "rom_copy", "func_src_before": "int rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end) {\n            break;\n        }\n\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n\n        if (rom->romsize > rom->datasize) {\n            /* If datasize is less than romsize, it means that we didn't\n             * allocate all the ROM because the trailing data are only zeros.\n             */\n\n            d += l;\n            l = rom->romsize - rom->datasize;\n\n            if ((d + l) > (dest + size)) {\n                /* Rom size doesn't fit in the destination area. Adjust to avoid\n                 * overflow.\n                 */\n                l = dest - d;\n            }\n\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n\n    return (d + l) - dest;\n}", "func_src_after": "int rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end || rom->addr < addr) {\n            break;\n        }\n\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n\n        if (rom->romsize > rom->datasize) {\n            /* If datasize is less than romsize, it means that we didn't\n             * allocate all the ROM because the trailing data are only zeros.\n             */\n\n            d += l;\n            l = rom->romsize - rom->datasize;\n\n            if ((d + l) > (dest + size)) {\n                /* Rom size doesn't fit in the destination area. Adjust to avoid\n                 * overflow.\n                 */\n                l = dest - d;\n            }\n\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n\n    return (d + l) - dest;\n}", "line_changes": {"deleted": [{"line_no": 18, "char_start": 379, "char_end": 410, "line": "        if (rom->addr > end) {\n"}], "added": [{"line_no": 18, "char_start": 379, "char_end": 430, "line": "        if (rom->addr > end || rom->addr < addr) {\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 406, "char_end": 426, "chars": " || rom->addr < addr"}]}, "commit_link": "github.com/qemu/qemu/commit/4f1c6cb2f9afafda05eab150fd2bd284edce6676", "file_name": "hw/core/loader.c", "vul_type": "cwe-787"}
{"func_name": "NeXTDecode", "func_src_before": "NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"NeXTDecode\";\n\tunsigned char *bp, *op;\n\ttmsize_t cc;\n\tuint8* row;\n\ttmsize_t scanline, n;\n\n\t(void) s;\n\t/*\n\t * Each scanline is assumed to start off as all\n\t * white (we assume a PhotometricInterpretation\n\t * of ``min-is-black'').\n\t */\n\tfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\n\t\t*op++ = 0xff;\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\tscanline = tif->tif_scanlinesize;\n\tif (occ % scanline)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\n\t\treturn (0);\n\t}\n\tfor (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) {\n\t\tn = *bp++, cc--;\n\t\tswitch (n) {\n\t\tcase LITERALROW:\n\t\t\t/*\n\t\t\t * The entire scanline is given as literal values.\n\t\t\t */\n\t\t\tif (cc < scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row, bp, scanline);\n\t\t\tbp += scanline;\n\t\t\tcc -= scanline;\n\t\t\tbreak;\n\t\tcase LITERALSPAN: {\n\t\t\ttmsize_t off;\n\t\t\t/*\n\t\t\t * The scanline has a literal span that begins at some\n\t\t\t * offset.\n\t\t\t */\n\t\t\tif( cc < 4 )\n\t\t\t\tgoto bad;\n\t\t\toff = (bp[0] * 256) + bp[1];\n\t\t\tn = (bp[2] * 256) + bp[3];\n\t\t\tif (cc < 4+n || off+n > scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row+off, bp+4, n);\n\t\t\tbp += 4+n;\n\t\t\tcc -= 4+n;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tuint32 npixels = 0, grey;\n\t\t\tuint32 imagewidth = tif->tif_dir.td_imagewidth;\n            if( isTiled(tif) )\n                imagewidth = tif->tif_dir.td_tilewidth;\n\n\t\t\t/*\n\t\t\t * The scanline is composed of a sequence of constant\n\t\t\t * color ``runs''.  We shift into ``run mode'' and\n\t\t\t * interpret bytes as codes of the form\n\t\t\t * <color><npixels> until we've filled the scanline.\n\t\t\t */\n\t\t\top = row;\n\t\t\tfor (;;) {\n\t\t\t\tgrey = (uint32)((n>>6) & 0x3);\n\t\t\t\tn &= 0x3f;\n\t\t\t\t/*\n\t\t\t\t * Ensure the run does not exceed the scanline\n\t\t\t\t * bounds, potentially resulting in a security\n\t\t\t\t * issue.\n\t\t\t\t */\n\t\t\t\twhile (n-- > 0 && npixels < imagewidth)\n\t\t\t\t\tSETPIXEL(op, grey);\n\t\t\t\tif (npixels >= imagewidth)\n\t\t\t\t\tbreak;\n\t\t\t\tif (cc == 0)\n\t\t\t\t\tgoto bad;\n\t\t\t\tn = *bp++, cc--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\ttif->tif_rawcp = (uint8*) bp;\n\ttif->tif_rawcc = cc;\n\treturn (1);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\n\t    (long) tif->tif_row);\n\treturn (0);\n}", "func_src_after": "NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"NeXTDecode\";\n\tunsigned char *bp, *op;\n\ttmsize_t cc;\n\tuint8* row;\n\ttmsize_t scanline, n;\n\n\t(void) s;\n\t/*\n\t * Each scanline is assumed to start off as all\n\t * white (we assume a PhotometricInterpretation\n\t * of ``min-is-black'').\n\t */\n\tfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\n\t\t*op++ = 0xff;\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\tscanline = tif->tif_scanlinesize;\n\tif (occ % scanline)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\n\t\treturn (0);\n\t}\n\tfor (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) {\n\t\tn = *bp++, cc--;\n\t\tswitch (n) {\n\t\tcase LITERALROW:\n\t\t\t/*\n\t\t\t * The entire scanline is given as literal values.\n\t\t\t */\n\t\t\tif (cc < scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row, bp, scanline);\n\t\t\tbp += scanline;\n\t\t\tcc -= scanline;\n\t\t\tbreak;\n\t\tcase LITERALSPAN: {\n\t\t\ttmsize_t off;\n\t\t\t/*\n\t\t\t * The scanline has a literal span that begins at some\n\t\t\t * offset.\n\t\t\t */\n\t\t\tif( cc < 4 )\n\t\t\t\tgoto bad;\n\t\t\toff = (bp[0] * 256) + bp[1];\n\t\t\tn = (bp[2] * 256) + bp[3];\n\t\t\tif (cc < 4+n || off+n > scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row+off, bp+4, n);\n\t\t\tbp += 4+n;\n\t\t\tcc -= 4+n;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tuint32 npixels = 0, grey;\n\t\t\tuint32 imagewidth = tif->tif_dir.td_imagewidth;\n            if( isTiled(tif) )\n                imagewidth = tif->tif_dir.td_tilewidth;\n            tmsize_t op_offset = 0;\n\n\t\t\t/*\n\t\t\t * The scanline is composed of a sequence of constant\n\t\t\t * color ``runs''.  We shift into ``run mode'' and\n\t\t\t * interpret bytes as codes of the form\n\t\t\t * <color><npixels> until we've filled the scanline.\n\t\t\t */\n\t\t\top = row;\n\t\t\tfor (;;) {\n\t\t\t\tgrey = (uint32)((n>>6) & 0x3);\n\t\t\t\tn &= 0x3f;\n\t\t\t\t/*\n\t\t\t\t * Ensure the run does not exceed the scanline\n\t\t\t\t * bounds, potentially resulting in a security\n\t\t\t\t * issue.\n\t\t\t\t */\n\t\t\t\twhile (n-- > 0 && npixels < imagewidth && op_offset < scanline)\n\t\t\t\t\tSETPIXEL(op, grey);\n\t\t\t\tif (npixels >= imagewidth)\n\t\t\t\t\tbreak;\n                if (op_offset >= scanline ) {\n                    TIFFErrorExt(tif->tif_clientdata, module, \"Invalid data for scanline %ld\",\n                        (long) tif->tif_row);\n                    return (0);\n                }\n\t\t\t\tif (cc == 0)\n\t\t\t\t\tgoto bad;\n\t\t\t\tn = *bp++, cc--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\ttif->tif_rawcp = (uint8*) bp;\n\ttif->tif_rawcc = cc;\n\treturn (1);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\n\t    (long) tif->tif_row);\n\treturn (0);\n}", "line_changes": {"deleted": [{"line_no": 77, "char_start": 1882, "char_end": 1926, "line": "\t\t\t\twhile (n-- > 0 && npixels < imagewidth)\n"}], "added": [{"line_no": 61, "char_start": 1450, "char_end": 1486, "line": "            tmsize_t op_offset = 0;\n"}, {"line_no": 78, "char_start": 1918, "char_end": 1986, "line": "\t\t\t\twhile (n-- > 0 && npixels < imagewidth && op_offset < scanline)\n"}, {"line_no": 82, "char_start": 2054, "char_end": 2100, "line": "                if (op_offset >= scanline ) {\n"}, {"line_no": 83, "char_start": 2100, "char_end": 2195, "line": "                    TIFFErrorExt(tif->tif_clientdata, module, \"Invalid data for scanline %ld\",\n"}, {"line_no": 84, "char_start": 2195, "char_end": 2241, "line": "                        (long) tif->tif_row);\n"}, {"line_no": 85, "char_start": 2241, "char_end": 2273, "line": "                    return (0);\n"}, {"line_no": 86, "char_start": 2273, "char_end": 2291, "line": "                }\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1450, "char_end": 1486, "chars": "            tmsize_t op_offset = 0;\n"}, {"char_start": 1960, "char_end": 1984, "chars": " && op_offset < scanline"}, {"char_start": 2053, "char_end": 2290, "chars": "\n                if (op_offset >= scanline ) {\n                    TIFFErrorExt(tif->tif_clientdata, module, \"Invalid data for scanline %ld\",\n                        (long) tif->tif_row);\n                    return (0);\n                }"}]}, "commit_link": "github.com/vadz/libtiff/commit/b18012dae552f85dcc5c57d3bf4e997a15b1cc1c", "file_name": "libtiff/tif_next.c", "vul_type": "cwe-787"}
{"func_name": "TiledInputFile::rawTileData", "func_src_before": "TiledInputFile::rawTileData (int &dx, int &dy,\n\t\t\t     int &lx, int &ly,\n                             const char *&pixelData,\n\t\t\t     int &pixelDataSize)\n{\n    try\n    {\n        Lock lock (*_data->_streamData);\n\n        if (!isValidTile (dx, dy, lx, ly))\n            throw IEX_NAMESPACE::ArgExc (\"Tried to read a tile outside \"\n\t\t\t       \"the image file's data window.\");\n\n        TileBuffer *tileBuffer = _data->getTileBuffer (0);\n\n        //\n        // if file is a multipart file, we have to seek to the required tile\n        // since we don't know where the file pointer is\n        //\n        int old_dx=dx;\n        int old_dy=dy;\n        int old_lx=lx;\n        int old_ly=ly;\n        if(isMultiPart(version()))\n        {\n            _data->_streamData->is->seekg(_data->tileOffsets(dx,dy,lx,ly));\n        }\n        readNextTileData (_data->_streamData, _data, dx, dy, lx, ly,\n\t\t\t  tileBuffer->buffer,\n                          pixelDataSize);\n        if(isMultiPart(version()))\n        {\n            if (old_dx!=dx || old_dy !=dy || old_lx!=lx || old_ly!=ly)\n            {\n                throw IEX_NAMESPACE::ArgExc (\"rawTileData read the wrong tile\");\n            }\n        }\n        pixelData = tileBuffer->buffer;\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        REPLACE_EXC (e, \"Error reading pixel data from image \"\n                     \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n        throw;\n    }\n}", "func_src_after": "TiledInputFile::rawTileData (int &dx, int &dy,\n\t\t\t     int &lx, int &ly,\n                             const char *&pixelData,\n\t\t\t     int &pixelDataSize)\n{\n    try\n    {\n        Lock lock (*_data->_streamData);\n\n        if (!isValidTile (dx, dy, lx, ly))\n            throw IEX_NAMESPACE::ArgExc (\"Tried to read a tile outside \"\n\t\t\t       \"the image file's data window.\");\n\n        TileBuffer *tileBuffer = _data->getTileBuffer (0);\n\n        //\n        // if file is a multipart file, we have to seek to the required tile\n        // since we don't know where the file pointer is\n        //\n        int old_dx=dx;\n        int old_dy=dy;\n        int old_lx=lx;\n        int old_ly=ly;\n        if(isMultiPart(version()))\n        {\n            _data->_streamData->is->seekg(_data->tileOffsets(dx,dy,lx,ly));\n        }\n        readNextTileData (_data->_streamData, _data, dx, dy, lx, ly,\n\t\t\t  tileBuffer->buffer,\n                          pixelDataSize);\n        if(isMultiPart(version()))\n        {\n            if (old_dx!=dx || old_dy !=dy || old_lx!=lx || old_ly!=ly)\n            {\n                throw IEX_NAMESPACE::ArgExc (\"rawTileData read the wrong tile\");\n            }\n        }\n        else\n        {\n             if(!isValidTile (dx, dy, lx, ly) )\n             {\n                 throw IEX_NAMESPACE::IoExc (\"rawTileData read an invalid tile\");\n             }\n        }\n        pixelData = tileBuffer->buffer;\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        REPLACE_EXC (e, \"Error reading pixel data from image \"\n                     \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n        throw;\n    }\n}", "line_changes": {"deleted": [], "added": [{"line_no": 38, "char_start": 1183, "char_end": 1196, "line": "        else\n"}, {"line_no": 39, "char_start": 1196, "char_end": 1206, "line": "        {\n"}, {"line_no": 40, "char_start": 1206, "char_end": 1254, "line": "             if(!isValidTile (dx, dy, lx, ly) )\n"}, {"line_no": 41, "char_start": 1254, "char_end": 1269, "line": "             {\n"}, {"line_no": 42, "char_start": 1269, "char_end": 1351, "line": "                 throw IEX_NAMESPACE::IoExc (\"rawTileData read an invalid tile\");\n"}, {"line_no": 43, "char_start": 1351, "char_end": 1366, "line": "             }\n"}, {"line_no": 44, "char_start": 1366, "char_end": 1376, "line": "        }\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1191, "char_end": 1384, "chars": "else\n        {\n             if(!isValidTile (dx, dy, lx, ly) )\n             {\n                 throw IEX_NAMESPACE::IoExc (\"rawTileData read an invalid tile\");\n             }\n        }\n        "}]}, "commit_link": "github.com/AcademySoftwareFoundation/openexr/commit/6bb36714528a9563dd3b92720c5063a1284b86f8", "file_name": "OpenEXR/IlmImf/ImfTiledInputFile.cpp", "vul_type": "cwe-787"}
{"func_name": "tcos_decipher", "func_src_before": "static int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\ttcos_data *data;\n\tint tcos3, r;\n\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t\t\"TCOS3:%d PKCS1:%d\\n\",tcos3,\n\t\t!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\n\tsc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = crgram_len;\n\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = crgram_len+1;\n\tsbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);\n\tmemcpy(sbuf+1, crgram, crgram_len);\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;\n\t\tunsigned int offset=0;\n\t\tif(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) {\n\t\t\toffset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;\n\t\t\toffset=(offset<len-1) ? offset+1 : 0;\n\t\t}\n\t\tmemcpy(out, apdu.resp+offset, len-offset);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}", "func_src_after": "static int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\ttcos_data *data;\n\tint tcos3, r;\n\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t\t\"TCOS3:%d PKCS1:%d\\n\",tcos3,\n\t\t!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\n\tsc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = crgram_len;\n\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = crgram_len+1;\n\tsbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);\n\tif (sizeof sbuf - 1 < crgram_len)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tmemcpy(sbuf+1, crgram, crgram_len);\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;\n\t\tunsigned int offset=0;\n\t\tif(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) {\n\t\t\toffset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;\n\t\t\toffset=(offset<len-1) ? offset+1 : 0;\n\t\t}\n\t\tmemcpy(out, apdu.resp+offset, len-offset);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}", "line_changes": {"deleted": [], "added": [{"line_no": 28, "char_start": 852, "char_end": 887, "line": "\tif (sizeof sbuf - 1 < crgram_len)\n"}, {"line_no": 29, "char_start": 887, "char_end": 924, "line": "\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 853, "char_end": 925, "chars": "if (sizeof sbuf - 1 < crgram_len)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t"}]}, "commit_link": "github.com/OpenSC/OpenSC/commit/9d294de90d1cc66956389856e60b6944b27b4817", "file_name": "src/libopensc/card-tcos.c", "vul_type": "cwe-787"}
{"func_name": "decode_zbuf", "func_src_before": "static int decode_zbuf(AVBPrint *bp, const uint8_t *data,\n                       const uint8_t *data_end)\n{\n    z_stream zstream;\n    unsigned char *buf;\n    unsigned buf_size;\n    int ret;\n\n    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n    av_bprint_init(bp, 0, -1);\n\n    while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 1, &buf, &buf_size);\n        if (!buf_size) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        zstream.next_out  = buf;\n        zstream.avail_out = buf_size;\n        ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);\n    bp->str[bp->len] = 0;\n    return 0;\n\nfail:\n    inflateEnd(&zstream);\n    av_bprint_finalize(bp, NULL);\n    return ret;\n}", "func_src_after": "static int decode_zbuf(AVBPrint *bp, const uint8_t *data,\n                       const uint8_t *data_end)\n{\n    z_stream zstream;\n    unsigned char *buf;\n    unsigned buf_size;\n    int ret;\n\n    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n    av_bprint_init(bp, 0, -1);\n\n    while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 2, &buf, &buf_size);\n        if (buf_size < 2) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        zstream.next_out  = buf;\n        zstream.avail_out = buf_size - 1;\n        ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);\n    bp->str[bp->len] = 0;\n    return 0;\n\nfail:\n    inflateEnd(&zstream);\n    av_bprint_finalize(bp, NULL);\n    return ret;\n}", "line_changes": {"deleted": [{"line_no": 19, "char_start": 514, "char_end": 568, "line": "        av_bprint_get_buffer(bp, 1, &buf, &buf_size);\n"}, {"line_no": 20, "char_start": 568, "char_end": 593, "line": "        if (!buf_size) {\n"}, {"line_no": 25, "char_start": 694, "char_end": 732, "line": "        zstream.avail_out = buf_size;\n"}], "added": [{"line_no": 19, "char_start": 514, "char_end": 568, "line": "        av_bprint_get_buffer(bp, 2, &buf, &buf_size);\n"}, {"line_no": 20, "char_start": 568, "char_end": 596, "line": "        if (buf_size < 2) {\n"}, {"line_no": 25, "char_start": 697, "char_end": 739, "line": "        zstream.avail_out = buf_size - 1;\n"}]}, "char_changes": {"deleted": [{"char_start": 547, "char_end": 548, "chars": "1"}, {"char_start": 580, "char_end": 581, "chars": "!"}], "added": [{"char_start": 547, "char_end": 548, "chars": "2"}, {"char_start": 588, "char_end": 592, "chars": " < 2"}, {"char_start": 733, "char_end": 737, "chars": " - 1"}]}, "commit_link": "github.com/FFmpeg/FFmpeg/commit/e371f031b942d73e02c090170975561fabd5c264", "file_name": "libavcodec/pngdec.c", "vul_type": "cwe-787"}
{"func_name": "MultiPartInputFile::Data::chunkOffsetReconstruction", "func_src_before": "MultiPartInputFile::Data::chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const vector<InputPartData*>& parts)\n{\n    //\n    // Reconstruct broken chunk offset tables. Stop once we received any exception.\n    //\n\n    Int64 position = is.tellg();\n\n    \n    //\n    // check we understand all the parts available: if not, we cannot continue\n    // exceptions thrown here should trickle back up to the constructor\n    //\n    \n    for (size_t i = 0; i < parts.size(); i++)\n    {\n        Header& header=parts[i]->header;\n        \n        //\n        // do we have a valid type entry?\n        // we only need them for true multipart files or single part non-image (deep) files\n        //\n        if(!header.hasType() && (isMultiPart(version) || isNonImage(version)))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with missing type\");\n        }\n        if(!isSupportedType(header.type()))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with unknown type \"+header.type());\n        }\n    }\n    \n    \n    // how many chunks should we read? We should stop when we reach the end\n    size_t total_chunks = 0;\n        \n    // for tiled-based parts, array of (pointers to) tileOffsets objects\n    // to create mapping between tile coordinates and chunk table indices\n    \n    \n    vector<TileOffsets*> tileOffsets(parts.size());\n    \n    // for scanline-based parts, number of scanlines in each chunk\n    vector<int> rowsizes(parts.size());\n        \n    for(size_t i = 0 ; i < parts.size() ; i++)\n    {\n        total_chunks += parts[i]->chunkOffsets.size();\n        if (isTiled(parts[i]->header.type()))\n        {\n            tileOffsets[i] = createTileOffsets(parts[i]->header);\n        }else{\n            tileOffsets[i] = NULL;\n            // (TODO) fix this so that it doesn't need to be revised for future compression types.\n            switch(parts[i]->header.compression())\n            {\n                case DWAB_COMPRESSION :\n                    rowsizes[i] = 256;\n                    break;\n                case PIZ_COMPRESSION :\n                case B44_COMPRESSION :\n                case B44A_COMPRESSION :\n                case DWAA_COMPRESSION :\n                    rowsizes[i]=32;\n                    break;\n                case ZIP_COMPRESSION :\n                case PXR24_COMPRESSION :\n                    rowsizes[i]=16;\n                    break;\n                case ZIPS_COMPRESSION :\n                case RLE_COMPRESSION :\n                case NO_COMPRESSION :\n                    rowsizes[i]=1;\n                    break;\n                default :\n                    throw(IEX_NAMESPACE::ArgExc(\"Unknown compression method in chunk offset reconstruction\"));\n            }\n        }\n     }\n        \n     try\n     {\n            \n        //\n        // \n        //\n        \n        Int64 chunk_start = position;\n        for (size_t i = 0; i < total_chunks ; i++)\n        {\n            //\n            // do we have a part number?\n            //\n            \n            int partNumber = 0;\n            if(isMultiPart(version))\n            {\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, partNumber);\n            }\n            \n            \n            \n            if(partNumber<0 || partNumber> static_cast<int>(parts.size()))\n            {\n                throw IEX_NAMESPACE::IoExc(\"part number out of range\");\n            }\n            \n            Header& header = parts[partNumber]->header;\n\n            // size of chunk NOT including multipart field\n            \n            Int64 size_of_chunk=0;\n\n            if (isTiled(header.type()))\n            {\n                //\n                // \n                //\n                int tilex,tiley,levelx,levely;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tilex);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tiley);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levelx);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levely);\n                \n                //std::cout << \"chunk_start for \" << tilex <<',' << tiley << ',' << levelx << ' ' << levely << ':' << chunk_start << std::endl;\n                    \n                \n                if(!tileOffsets[partNumber])\n                {\n                    // this shouldn't actually happen - we should have allocated a valid\n                    // tileOffsets for any part which isTiled\n                    throw IEX_NAMESPACE::IoExc(\"part not tiled\");\n                    \n                }\n                \n                if(!tileOffsets[partNumber]->isValidTile(tilex,tiley,levelx,levely))\n                {\n                    throw IEX_NAMESPACE::IoExc(\"invalid tile coordinates\");\n                }\n                \n                (*tileOffsets[partNumber])(tilex,tiley,levelx,levely)=chunk_start;\n                \n                // compute chunk sizes - different procedure for deep tiles and regular\n                // ones\n                if(header.type()==DEEPTILE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    //add 40 byte header to packed sizes (tile coordinates, packed sizes, unpacked size)\n                    size_of_chunk=packed_offset+packed_sample+40;\n                }\n                else\n                {\n                    \n                    // regular image has 20 bytes of header, 4 byte chunksize;\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);\n                    size_of_chunk=chunksize+20;\n                }\n            }\n            else\n            {\n                int y_coordinate;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, y_coordinate);\n                \n                \n                if(y_coordinate < header.dataWindow().min.y || y_coordinate > header.dataWindow().max.y)\n                {\n                   throw IEX_NAMESPACE::IoExc(\"y out of range\");\n                }\n                y_coordinate -= header.dataWindow().min.y;\n                y_coordinate /= rowsizes[partNumber];   \n                \n                if(y_coordinate < 0 || y_coordinate >= int(parts[partNumber]->chunkOffsets.size()))\n                {\n                   throw IEX_NAMESPACE::IoExc(\"chunk index out of range\");\n                }\n                \n                parts[partNumber]->chunkOffsets[y_coordinate]=chunk_start;\n                \n                if(header.type()==DEEPSCANLINE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    \n                    size_of_chunk=packed_offset+packed_sample+28;\n                }\n                else\n                {\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);   \n                    size_of_chunk=chunksize+8;\n                }\n                \n            }\n            \n            if(isMultiPart(version))\n            {\n                chunk_start+=4;\n            }\n            \n            chunk_start+=size_of_chunk;\n            \n            is.seekg(chunk_start);\n            \n        }\n        \n    }\n    catch (...)\n    {\n        //\n        // Suppress all exceptions.  This functions is\n        // called only to reconstruct the line offset\n        // table for incomplete files, and exceptions\n        // are likely.\n        //\n    }\n\n    // copy tiled part data back to chunk offsets\n    \n    for(size_t partNumber=0;partNumber<parts.size();partNumber++)\n    {\n        if(tileOffsets[partNumber])\n        {\n            size_t pos=0;\n            vector<vector<vector <Int64> > > offsets = tileOffsets[partNumber]->getOffsets();\n            for (size_t l = 0; l < offsets.size(); l++)\n                for (size_t y = 0; y < offsets[l].size(); y++)\n                    for (size_t x = 0; x < offsets[l][y].size(); x++)\n                    {\n                        parts[ partNumber ]->chunkOffsets[pos] = offsets[l][y][x];\n                        pos++;\n                    }\n           delete tileOffsets[partNumber];\n        }\n    }\n\n    is.clear();\n    is.seekg (position);\n}", "func_src_after": "MultiPartInputFile::Data::chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const vector<InputPartData*>& parts)\n{\n    //\n    // Reconstruct broken chunk offset tables. Stop once we received any exception.\n    //\n\n    Int64 position = is.tellg();\n\n    \n    //\n    // check we understand all the parts available: if not, we cannot continue\n    // exceptions thrown here should trickle back up to the constructor\n    //\n    \n    for (size_t i = 0; i < parts.size(); i++)\n    {\n        Header& header=parts[i]->header;\n        \n        //\n        // do we have a valid type entry?\n        // we only need them for true multipart files or single part non-image (deep) files\n        //\n        if(!header.hasType() && (isMultiPart(version) || isNonImage(version)))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with missing type\");\n        }\n        if(!isSupportedType(header.type()))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with unknown type \"+header.type());\n        }\n    }\n    \n    \n    // how many chunks should we read? We should stop when we reach the end\n    size_t total_chunks = 0;\n        \n    // for tiled-based parts, array of (pointers to) tileOffsets objects\n    // to create mapping between tile coordinates and chunk table indices\n    \n    \n    vector<TileOffsets*> tileOffsets(parts.size());\n    \n    // for scanline-based parts, number of scanlines in each chunk\n    vector<int> rowsizes(parts.size());\n        \n    for(size_t i = 0 ; i < parts.size() ; i++)\n    {\n        total_chunks += parts[i]->chunkOffsets.size();\n        if (isTiled(parts[i]->header.type()))\n        {\n            tileOffsets[i] = createTileOffsets(parts[i]->header);\n        }else{\n            tileOffsets[i] = NULL;\n            // (TODO) fix this so that it doesn't need to be revised for future compression types.\n            switch(parts[i]->header.compression())\n            {\n                case DWAB_COMPRESSION :\n                    rowsizes[i] = 256;\n                    break;\n                case PIZ_COMPRESSION :\n                case B44_COMPRESSION :\n                case B44A_COMPRESSION :\n                case DWAA_COMPRESSION :\n                    rowsizes[i]=32;\n                    break;\n                case ZIP_COMPRESSION :\n                case PXR24_COMPRESSION :\n                    rowsizes[i]=16;\n                    break;\n                case ZIPS_COMPRESSION :\n                case RLE_COMPRESSION :\n                case NO_COMPRESSION :\n                    rowsizes[i]=1;\n                    break;\n                default :\n                    throw(IEX_NAMESPACE::ArgExc(\"Unknown compression method in chunk offset reconstruction\"));\n            }\n        }\n     }\n        \n     try\n     {\n            \n        //\n        // \n        //\n        \n        Int64 chunk_start = position;\n        for (size_t i = 0; i < total_chunks ; i++)\n        {\n            //\n            // do we have a part number?\n            //\n            \n            int partNumber = 0;\n            if(isMultiPart(version))\n            {\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, partNumber);\n            }\n            \n            \n            \n            if(partNumber<0 || partNumber>= static_cast<int>(parts.size()))\n            {\n                throw IEX_NAMESPACE::IoExc(\"part number out of range\");\n            }\n            \n            Header& header = parts[partNumber]->header;\n\n            // size of chunk NOT including multipart field\n            \n            Int64 size_of_chunk=0;\n\n            if (isTiled(header.type()))\n            {\n                //\n                // \n                //\n                int tilex,tiley,levelx,levely;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tilex);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tiley);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levelx);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levely);\n                \n                //std::cout << \"chunk_start for \" << tilex <<',' << tiley << ',' << levelx << ' ' << levely << ':' << chunk_start << std::endl;\n                    \n                \n                if(!tileOffsets[partNumber])\n                {\n                    // this shouldn't actually happen - we should have allocated a valid\n                    // tileOffsets for any part which isTiled\n                    throw IEX_NAMESPACE::IoExc(\"part not tiled\");\n                    \n                }\n                \n                if(!tileOffsets[partNumber]->isValidTile(tilex,tiley,levelx,levely))\n                {\n                    throw IEX_NAMESPACE::IoExc(\"invalid tile coordinates\");\n                }\n                \n                (*tileOffsets[partNumber])(tilex,tiley,levelx,levely)=chunk_start;\n                \n                // compute chunk sizes - different procedure for deep tiles and regular\n                // ones\n                if(header.type()==DEEPTILE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    //add 40 byte header to packed sizes (tile coordinates, packed sizes, unpacked size)\n                    size_of_chunk=packed_offset+packed_sample+40;\n                }\n                else\n                {\n                    \n                    // regular image has 20 bytes of header, 4 byte chunksize;\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);\n                    size_of_chunk=chunksize+20;\n                }\n            }\n            else\n            {\n                int y_coordinate;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, y_coordinate);\n                \n                \n                if(y_coordinate < header.dataWindow().min.y || y_coordinate > header.dataWindow().max.y)\n                {\n                   throw IEX_NAMESPACE::IoExc(\"y out of range\");\n                }\n                y_coordinate -= header.dataWindow().min.y;\n                y_coordinate /= rowsizes[partNumber];   \n                \n                if(y_coordinate < 0 || y_coordinate >= int(parts[partNumber]->chunkOffsets.size()))\n                {\n                   throw IEX_NAMESPACE::IoExc(\"chunk index out of range\");\n                }\n                \n                parts[partNumber]->chunkOffsets[y_coordinate]=chunk_start;\n                \n                if(header.type()==DEEPSCANLINE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    \n                    size_of_chunk=packed_offset+packed_sample+28;\n                }\n                else\n                {\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);   \n                    size_of_chunk=chunksize+8;\n                }\n                \n            }\n            \n            if(isMultiPart(version))\n            {\n                chunk_start+=4;\n            }\n            \n            chunk_start+=size_of_chunk;\n            \n            is.seekg(chunk_start);\n            \n        }\n        \n    }\n    catch (...)\n    {\n        //\n        // Suppress all exceptions.  This functions is\n        // called only to reconstruct the line offset\n        // table for incomplete files, and exceptions\n        // are likely.\n        //\n    }\n\n    // copy tiled part data back to chunk offsets\n    \n    for(size_t partNumber=0;partNumber<parts.size();partNumber++)\n    {\n        if(tileOffsets[partNumber])\n        {\n            size_t pos=0;\n            vector<vector<vector <Int64> > > offsets = tileOffsets[partNumber]->getOffsets();\n            for (size_t l = 0; l < offsets.size(); l++)\n                for (size_t y = 0; y < offsets[l].size(); y++)\n                    for (size_t x = 0; x < offsets[l][y].size(); x++)\n                    {\n                        parts[ partNumber ]->chunkOffsets[pos] = offsets[l][y][x];\n                        pos++;\n                    }\n           delete tileOffsets[partNumber];\n        }\n    }\n\n    is.clear();\n    is.seekg (position);\n}", "line_changes": {"deleted": [{"line_no": 103, "char_start": 3326, "char_end": 3401, "line": "            if(partNumber<0 || partNumber> static_cast<int>(parts.size()))\n"}], "added": [{"line_no": 103, "char_start": 3326, "char_end": 3402, "line": "            if(partNumber<0 || partNumber>= static_cast<int>(parts.size()))\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 3368, "char_end": 3369, "chars": "="}]}, "commit_link": "github.com/AcademySoftwareFoundation/openexr/commit/8b5370c688a7362673c3a5256d93695617a4cd9a", "file_name": "OpenEXR/IlmImf/ImfMultiPartInputFile.cpp", "vul_type": "cwe-787"}
{"func_name": "make_canonical", "func_src_before": "make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2)\n{\n    const uint16_t buf_len = 511;\n    char buf[buf_len + 1];\n    struct lys_type_bit **bits = NULL;\n    struct lyxp_expr *exp;\n    const char *module_name, *cur_expr, *end;\n    int i, j, count;\n    int64_t num;\n    uint64_t unum;\n    uint8_t c;\n\n#define LOGBUF(str) LOGERR(ctx, LY_EINVAL, \"Value \\\"%s\\\" is too long.\", str)\n\n    switch (type) {\n    case LY_TYPE_BITS:\n        bits = (struct lys_type_bit **)data1;\n        count = *((int *)data2);\n        /* in canonical form, the bits are ordered by their position */\n        buf[0] = '\\0';\n        for (i = 0; i < count; i++) {\n            if (!bits[i]) {\n                /* bit not set */\n                continue;\n            }\n            if (buf[0]) {\n                LY_CHECK_ERR_RETURN(strlen(buf) + 1 + strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);\n                sprintf(buf + strlen(buf), \" %s\", bits[i]->name);\n            } else {\n                LY_CHECK_ERR_RETURN(strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);\n                strcpy(buf, bits[i]->name);\n            }\n        }\n        break;\n\n    case LY_TYPE_IDENT:\n        module_name = (const char *)data1;\n        /* identity must always have a prefix */\n        if (!strchr(*value, ':')) {\n            sprintf(buf, \"%s:%s\", module_name, *value);\n        } else {\n            strcpy(buf, *value);\n        }\n        break;\n\n    case LY_TYPE_INST:\n        exp = lyxp_parse_expr(ctx, *value);\n        LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), -1);\n\n        module_name = NULL;\n        count = 0;\n        for (i = 0; (unsigned)i < exp->used; ++i) {\n            cur_expr = &exp->expr[exp->expr_pos[i]];\n\n            /* copy WS */\n            if (i && ((end = exp->expr + exp->expr_pos[i - 1] + exp->tok_len[i - 1]) != cur_expr)) {\n                if (count + (cur_expr - end) > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(end);\n                    return -1;\n                }\n                strncpy(&buf[count], end, cur_expr - end);\n                count += cur_expr - end;\n            }\n\n            if ((exp->tokens[i] == LYXP_TOKEN_NAMETEST) && (end = strnchr(cur_expr, ':', exp->tok_len[i]))) {\n                /* get the module name with \":\" */\n                ++end;\n                j = end - cur_expr;\n\n                if (!module_name || strncmp(cur_expr, module_name, j)) {\n                    /* print module name with colon, it does not equal to the parent one */\n                    if (count + j > buf_len) {\n                        lyxp_expr_free(exp);\n                        LOGBUF(cur_expr);\n                        return -1;\n                    }\n                    strncpy(&buf[count], cur_expr, j);\n                    count += j;\n                }\n                module_name = cur_expr;\n\n                /* copy the rest */\n                if (count + (exp->tok_len[i] - j) > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(end);\n                    return -1;\n                }\n                strncpy(&buf[count], end, exp->tok_len[i] - j);\n                count += exp->tok_len[i] - j;\n            } else {\n                if (count + exp->tok_len[i] > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(&exp->expr[exp->expr_pos[i]]);\n                    return -1;\n                }\n                strncpy(&buf[count], &exp->expr[exp->expr_pos[i]], exp->tok_len[i]);\n                count += exp->tok_len[i];\n            }\n        }\n        if (count > buf_len) {\n            LOGINT(ctx);\n            lyxp_expr_free(exp);\n            return -1;\n        }\n        buf[count] = '\\0';\n\n        lyxp_expr_free(exp);\n        break;\n\n    case LY_TYPE_DEC64:\n        num = *((int64_t *)data1);\n        c = *((uint8_t *)data2);\n        if (num) {\n            count = sprintf(buf, \"%\"PRId64\" \", num);\n            if ( (num > 0 && (count - 1) <= c)\n                 || (count - 2) <= c ) {\n                /* we have 0. value, print the value with the leading zeros\n                 * (one for 0. and also keep the correct with of num according\n                 * to fraction-digits value)\n                 * for (num<0) - extra character for '-' sign */\n                count = sprintf(buf, \"%0*\"PRId64\" \", (num > 0) ? (c + 1) : (c + 2), num);\n            }\n            for (i = c, j = 1; i > 0 ; i--) {\n                if (j && i > 1 && buf[count - 2] == '0') {\n                    /* we have trailing zero to skip */\n                    buf[count - 1] = '\\0';\n                } else {\n                    j = 0;\n                    buf[count - 1] = buf[count - 2];\n                }\n                count--;\n            }\n            buf[count - 1] = '.';\n        } else {\n            /* zero */\n            sprintf(buf, \"0.0\");\n        }\n        break;\n\n    case LY_TYPE_INT8:\n    case LY_TYPE_INT16:\n    case LY_TYPE_INT32:\n    case LY_TYPE_INT64:\n        num = *((int64_t *)data1);\n        sprintf(buf, \"%\"PRId64, num);\n        break;\n\n    case LY_TYPE_UINT8:\n    case LY_TYPE_UINT16:\n    case LY_TYPE_UINT32:\n    case LY_TYPE_UINT64:\n        unum = *((uint64_t *)data1);\n        sprintf(buf, \"%\"PRIu64, unum);\n        break;\n\n    default:\n        /* should not be even called - just do nothing */\n        return 0;\n    }\n\n    if (strcmp(buf, *value)) {\n        lydict_remove(ctx, *value);\n        *value = lydict_insert(ctx, buf, 0);\n        return 1;\n    }\n\n    return 0;\n\n#undef LOGBUF\n}", "func_src_after": "make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2)\n{\n    const uint16_t buf_len = 511;\n    char buf[buf_len + 1];\n    struct lys_type_bit **bits = NULL;\n    struct lyxp_expr *exp;\n    const char *module_name, *cur_expr, *end;\n    int i, j, count;\n    int64_t num;\n    uint64_t unum;\n    uint8_t c;\n\n#define LOGBUF(str) LOGERR(ctx, LY_EINVAL, \"Value \\\"%s\\\" is too long.\", str)\n\n    switch (type) {\n    case LY_TYPE_BITS:\n        bits = (struct lys_type_bit **)data1;\n        count = *((int *)data2);\n        /* in canonical form, the bits are ordered by their position */\n        buf[0] = '\\0';\n        for (i = 0; i < count; i++) {\n            if (!bits[i]) {\n                /* bit not set */\n                continue;\n            }\n            if (buf[0]) {\n                LY_CHECK_ERR_RETURN(strlen(buf) + 1 + strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);\n                sprintf(buf + strlen(buf), \" %s\", bits[i]->name);\n            } else {\n                LY_CHECK_ERR_RETURN(strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);\n                strcpy(buf, bits[i]->name);\n            }\n        }\n        break;\n\n    case LY_TYPE_IDENT:\n        module_name = (const char *)data1;\n        /* identity must always have a prefix */\n        if (!strchr(*value, ':')) {\n            LY_CHECK_ERR_RETURN(strlen(module_name) + 1 + strlen(*value) > buf_len, LOGBUF(*value), -1);\n            sprintf(buf, \"%s:%s\", module_name, *value);\n        } else {\n            LY_CHECK_ERR_RETURN(strlen(*value) > buf_len, LOGBUF(*value), -1);\n            strcpy(buf, *value);\n        }\n        break;\n\n    case LY_TYPE_INST:\n        exp = lyxp_parse_expr(ctx, *value);\n        LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), -1);\n\n        module_name = NULL;\n        count = 0;\n        for (i = 0; (unsigned)i < exp->used; ++i) {\n            cur_expr = &exp->expr[exp->expr_pos[i]];\n\n            /* copy WS */\n            if (i && ((end = exp->expr + exp->expr_pos[i - 1] + exp->tok_len[i - 1]) != cur_expr)) {\n                if (count + (cur_expr - end) > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(end);\n                    return -1;\n                }\n                strncpy(&buf[count], end, cur_expr - end);\n                count += cur_expr - end;\n            }\n\n            if ((exp->tokens[i] == LYXP_TOKEN_NAMETEST) && (end = strnchr(cur_expr, ':', exp->tok_len[i]))) {\n                /* get the module name with \":\" */\n                ++end;\n                j = end - cur_expr;\n\n                if (!module_name || strncmp(cur_expr, module_name, j)) {\n                    /* print module name with colon, it does not equal to the parent one */\n                    if (count + j > buf_len) {\n                        lyxp_expr_free(exp);\n                        LOGBUF(cur_expr);\n                        return -1;\n                    }\n                    strncpy(&buf[count], cur_expr, j);\n                    count += j;\n                }\n                module_name = cur_expr;\n\n                /* copy the rest */\n                if (count + (exp->tok_len[i] - j) > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(end);\n                    return -1;\n                }\n                strncpy(&buf[count], end, exp->tok_len[i] - j);\n                count += exp->tok_len[i] - j;\n            } else {\n                if (count + exp->tok_len[i] > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(&exp->expr[exp->expr_pos[i]]);\n                    return -1;\n                }\n                strncpy(&buf[count], &exp->expr[exp->expr_pos[i]], exp->tok_len[i]);\n                count += exp->tok_len[i];\n            }\n        }\n        if (count > buf_len) {\n            LOGINT(ctx);\n            lyxp_expr_free(exp);\n            return -1;\n        }\n        buf[count] = '\\0';\n\n        lyxp_expr_free(exp);\n        break;\n\n    case LY_TYPE_DEC64:\n        num = *((int64_t *)data1);\n        c = *((uint8_t *)data2);\n        if (num) {\n            count = sprintf(buf, \"%\"PRId64\" \", num);\n            if ( (num > 0 && (count - 1) <= c)\n                 || (count - 2) <= c ) {\n                /* we have 0. value, print the value with the leading zeros\n                 * (one for 0. and also keep the correct with of num according\n                 * to fraction-digits value)\n                 * for (num<0) - extra character for '-' sign */\n                count = sprintf(buf, \"%0*\"PRId64\" \", (num > 0) ? (c + 1) : (c + 2), num);\n            }\n            for (i = c, j = 1; i > 0 ; i--) {\n                if (j && i > 1 && buf[count - 2] == '0') {\n                    /* we have trailing zero to skip */\n                    buf[count - 1] = '\\0';\n                } else {\n                    j = 0;\n                    buf[count - 1] = buf[count - 2];\n                }\n                count--;\n            }\n            buf[count - 1] = '.';\n        } else {\n            /* zero */\n            sprintf(buf, \"0.0\");\n        }\n        break;\n\n    case LY_TYPE_INT8:\n    case LY_TYPE_INT16:\n    case LY_TYPE_INT32:\n    case LY_TYPE_INT64:\n        num = *((int64_t *)data1);\n        sprintf(buf, \"%\"PRId64, num);\n        break;\n\n    case LY_TYPE_UINT8:\n    case LY_TYPE_UINT16:\n    case LY_TYPE_UINT32:\n    case LY_TYPE_UINT64:\n        unum = *((uint64_t *)data1);\n        sprintf(buf, \"%\"PRIu64, unum);\n        break;\n\n    default:\n        /* should not be even called - just do nothing */\n        return 0;\n    }\n\n    if (strcmp(buf, *value)) {\n        lydict_remove(ctx, *value);\n        *value = lydict_insert(ctx, buf, 0);\n        return 1;\n    }\n\n    return 0;\n\n#undef LOGBUF\n}", "line_changes": {"deleted": [], "added": [{"line_no": 40, "char_start": 1335, "char_end": 1440, "line": "            LY_CHECK_ERR_RETURN(strlen(module_name) + 1 + strlen(*value) > buf_len, LOGBUF(*value), -1);\n"}, {"line_no": 43, "char_start": 1513, "char_end": 1592, "line": "            LY_CHECK_ERR_RETURN(strlen(*value) > buf_len, LOGBUF(*value), -1);\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1347, "char_end": 1452, "chars": "LY_CHECK_ERR_RETURN(strlen(module_name) + 1 + strlen(*value) > buf_len, LOGBUF(*value), -1);\n            "}, {"char_start": 1512, "char_end": 1591, "chars": "\n            LY_CHECK_ERR_RETURN(strlen(*value) > buf_len, LOGBUF(*value), -1);"}]}, "commit_link": "github.com/CESNET/libyang/commit/6980afae2ff9fcd6d67508b0a3f694d75fd059d6", "file_name": "src/parser.c", "vul_type": "cwe-787"}
{"func_name": "decode_frame", "func_src_before": "static int decode_frame(AVCodecContext *avctx, void *data,\n                        int *got_frame, AVPacket *avpkt)\n{\n    EXRContext *s = avctx->priv_data;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    uint8_t *ptr;\n\n    int i, y, ret, ymax;\n    int planes;\n    int out_line_size;\n    int nb_blocks;   /* nb scanline or nb tile */\n    uint64_t start_offset_table;\n    uint64_t start_next_scanline;\n    PutByteContext offset_table_writer;\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n\n    if ((ret = decode_header(s, picture)) < 0)\n        return ret;\n\n    switch (s->pixel_type) {\n    case EXR_FLOAT:\n    case EXR_HALF:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            } else {\n                /* todo: change this when a floating point pixel format with luma with alpha is implemented */\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRPF32;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAYF32;\n            }\n        }\n        break;\n    case EXR_UINT:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGBA64;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_YA16;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGB48;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n            }\n        }\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Missing channel list.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->apply_trc_type != AVCOL_TRC_UNSPECIFIED)\n        avctx->color_trc = s->apply_trc_type;\n\n    switch (s->compression) {\n    case EXR_RAW:\n    case EXR_RLE:\n    case EXR_ZIP1:\n        s->scan_lines_per_block = 1;\n        break;\n    case EXR_PXR24:\n    case EXR_ZIP16:\n        s->scan_lines_per_block = 16;\n        break;\n    case EXR_PIZ:\n    case EXR_B44:\n    case EXR_B44A:\n        s->scan_lines_per_block = 32;\n        break;\n    default:\n        avpriv_report_missing_feature(avctx, \"Compression %d\", s->compression);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /* Verify the xmin, xmax, ymin and ymax before setting the actual image size.\n     * It's possible for the data window can larger or outside the display window */\n    if (s->xmin > s->xmax  || s->ymin > s->ymax ||\n        s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) {\n        av_log(avctx, AV_LOG_ERROR, \"Wrong or missing size information.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0)\n        return ret;\n\n    s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt);\n    if (!s->desc)\n        return AVERROR_INVALIDDATA;\n\n    if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {\n        planes           = s->desc->nb_components;\n        out_line_size    = avctx->width * 4;\n    } else {\n        planes           = 1;\n        out_line_size    = avctx->width * 2 * s->desc->nb_components;\n    }\n\n    if (s->is_tile) {\n        nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) *\n        ((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize);\n    } else { /* scanline */\n        nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) /\n        s->scan_lines_per_block;\n    }\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        return ret;\n\n    if (bytestream2_get_bytes_left(&s->gb)/8 < nb_blocks)\n        return AVERROR_INVALIDDATA;\n\n    // check offset table and recreate it if need\n    if (!s->is_tile && bytestream2_peek_le64(&s->gb) == 0) {\n        av_log(s->avctx, AV_LOG_DEBUG, \"recreating invalid scanline offset table\\n\");\n\n        start_offset_table = bytestream2_tell(&s->gb);\n        start_next_scanline = start_offset_table + nb_blocks * 8;\n        bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8);\n\n        for (y = 0; y < nb_blocks; y++) {\n            /* write offset of prev scanline in offset table */\n            bytestream2_put_le64(&offset_table_writer, start_next_scanline);\n\n            /* get len of next scanline */\n            bytestream2_seek(&s->gb, start_next_scanline + 4, SEEK_SET);/* skip line number */\n            start_next_scanline += (bytestream2_get_le32(&s->gb) + 8);\n        }\n        bytestream2_seek(&s->gb, start_offset_table, SEEK_SET);\n    }\n\n    // save pointer we are going to use in decode_block\n    s->buf      = avpkt->data;\n    s->buf_size = avpkt->size;\n\n    // Zero out the start if ymin is not 0\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i];\n        for (y = 0; y < s->ymin; y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    s->picture = picture;\n\n    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);\n\n    ymax = FFMAX(0, s->ymax + 1);\n    // Zero out the end if ymax+1 is not h\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i] + (ymax * picture->linesize[i]);\n        for (y = ymax; y < avctx->height; y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    *got_frame = 1;\n\n    return avpkt->size;\n}", "func_src_after": "static int decode_frame(AVCodecContext *avctx, void *data,\n                        int *got_frame, AVPacket *avpkt)\n{\n    EXRContext *s = avctx->priv_data;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    uint8_t *ptr;\n\n    int i, y, ret, ymax;\n    int planes;\n    int out_line_size;\n    int nb_blocks;   /* nb scanline or nb tile */\n    uint64_t start_offset_table;\n    uint64_t start_next_scanline;\n    PutByteContext offset_table_writer;\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n\n    if ((ret = decode_header(s, picture)) < 0)\n        return ret;\n\n    switch (s->pixel_type) {\n    case EXR_FLOAT:\n    case EXR_HALF:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            } else {\n                /* todo: change this when a floating point pixel format with luma with alpha is implemented */\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRPF32;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAYF32;\n            }\n        }\n        break;\n    case EXR_UINT:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGBA64;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_YA16;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGB48;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n            }\n        }\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Missing channel list.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->apply_trc_type != AVCOL_TRC_UNSPECIFIED)\n        avctx->color_trc = s->apply_trc_type;\n\n    switch (s->compression) {\n    case EXR_RAW:\n    case EXR_RLE:\n    case EXR_ZIP1:\n        s->scan_lines_per_block = 1;\n        break;\n    case EXR_PXR24:\n    case EXR_ZIP16:\n        s->scan_lines_per_block = 16;\n        break;\n    case EXR_PIZ:\n    case EXR_B44:\n    case EXR_B44A:\n        s->scan_lines_per_block = 32;\n        break;\n    default:\n        avpriv_report_missing_feature(avctx, \"Compression %d\", s->compression);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /* Verify the xmin, xmax, ymin and ymax before setting the actual image size.\n     * It's possible for the data window can larger or outside the display window */\n    if (s->xmin > s->xmax  || s->ymin > s->ymax ||\n        s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) {\n        av_log(avctx, AV_LOG_ERROR, \"Wrong or missing size information.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0)\n        return ret;\n\n    s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt);\n    if (!s->desc)\n        return AVERROR_INVALIDDATA;\n\n    if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {\n        planes           = s->desc->nb_components;\n        out_line_size    = avctx->width * 4;\n    } else {\n        planes           = 1;\n        out_line_size    = avctx->width * 2 * s->desc->nb_components;\n    }\n\n    if (s->is_tile) {\n        nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) *\n        ((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize);\n    } else { /* scanline */\n        nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) /\n        s->scan_lines_per_block;\n    }\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        return ret;\n\n    if (bytestream2_get_bytes_left(&s->gb)/8 < nb_blocks)\n        return AVERROR_INVALIDDATA;\n\n    // check offset table and recreate it if need\n    if (!s->is_tile && bytestream2_peek_le64(&s->gb) == 0) {\n        av_log(s->avctx, AV_LOG_DEBUG, \"recreating invalid scanline offset table\\n\");\n\n        start_offset_table = bytestream2_tell(&s->gb);\n        start_next_scanline = start_offset_table + nb_blocks * 8;\n        bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8);\n\n        for (y = 0; y < nb_blocks; y++) {\n            /* write offset of prev scanline in offset table */\n            bytestream2_put_le64(&offset_table_writer, start_next_scanline);\n\n            /* get len of next scanline */\n            bytestream2_seek(&s->gb, start_next_scanline + 4, SEEK_SET);/* skip line number */\n            start_next_scanline += (bytestream2_get_le32(&s->gb) + 8);\n        }\n        bytestream2_seek(&s->gb, start_offset_table, SEEK_SET);\n    }\n\n    // save pointer we are going to use in decode_block\n    s->buf      = avpkt->data;\n    s->buf_size = avpkt->size;\n\n    // Zero out the start if ymin is not 0\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i];\n        for (y = 0; y < FFMIN(s->ymin, s->h); y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    s->picture = picture;\n\n    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);\n\n    ymax = FFMAX(0, s->ymax + 1);\n    // Zero out the end if ymax+1 is not h\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i] + (ymax * picture->linesize[i]);\n        for (y = ymax; y < avctx->height; y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    *got_frame = 1;\n\n    return avpkt->size;\n}", "line_changes": {"deleted": [{"line_no": 146, "char_start": 4801, "char_end": 4841, "line": "        for (y = 0; y < s->ymin; y++) {\n"}], "added": [{"line_no": 146, "char_start": 4801, "char_end": 4854, "line": "        for (y = 0; y < FFMIN(s->ymin, s->h); y++) {\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 4825, "char_end": 4831, "chars": "FFMIN("}, {"char_start": 4838, "char_end": 4845, "chars": ", s->h)"}]}, "commit_link": "github.com/FFmpeg/FFmpeg/commit/3e5959b3457f7f1856d997261e6ac672bba49e8b", "file_name": "libavcodec/exr.c", "vul_type": "cwe-787"}
{"func_name": "add_password", "func_src_before": "static void add_password(AUTH_HDR *request, unsigned char type, CONST char *password, char *secret)\n{\n\tMD5_CTX md5_secret, my_md5;\n\tunsigned char misc[AUTH_VECTOR_LEN];\n\tint i;\n\tint length = strlen(password);\n\tunsigned char hashed[256 + AUTH_PASS_LEN];\t/* can't be longer than this */\n\tunsigned char *vector;\n\tattribute_t *attr;\n\n\tif (length > MAXPASS) {\t\t\t\t/* shorten the password for now */\n\t\tlength = MAXPASS;\n\t}\n\n\tif (length == 0) {\n\t\tlength = AUTH_PASS_LEN;\t\t\t/* 0 maps to 16 */\n\t} if ((length & (AUTH_PASS_LEN - 1)) != 0) {\n\t\tlength += (AUTH_PASS_LEN - 1);\t\t/* round it up */\n\t\tlength &= ~(AUTH_PASS_LEN - 1);\t\t/* chop it off */\n\t}\t\t\t\t\t\t/* 16*N maps to itself */\n\n\tmemset(hashed, 0, length);\n\tmemcpy(hashed, password, strlen(password));\n\n\tattr = find_attribute(request, PW_PASSWORD);\n\n\tif (type == PW_PASSWORD) {\n\t\tvector = request->vector;\n\t} else {\n\t\tvector = attr->data;\t\t\t/* attr CANNOT be NULL here. */\n\t}\n\n\t/* ************************************************************ */\n\t/* encrypt the password */\n\t/* password : e[0] = p[0] ^ MD5(secret + vector) */\n\tMD5Init(&md5_secret);\n\tMD5Update(&md5_secret, (unsigned char *) secret, strlen(secret));\n\tmy_md5 = md5_secret;\t\t\t\t/* so we won't re-do the hash later */\n\tMD5Update(&my_md5, vector, AUTH_VECTOR_LEN);\n\tMD5Final(misc, &my_md5);\t\t\t/* set the final vector */\n\txor(hashed, misc, AUTH_PASS_LEN);\n\n\t/* For each step through, e[i] = p[i] ^ MD5(secret + e[i-1]) */\n\tfor (i = 1; i < (length >> 4); i++) {\n\t\tmy_md5 = md5_secret;\t\t\t/* grab old value of the hash */\n\t\tMD5Update(&my_md5, &hashed[(i-1) * AUTH_PASS_LEN], AUTH_PASS_LEN);\n\t\tMD5Final(misc, &my_md5);\t\t\t/* set the final vector */\n\t\txor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN);\n\t}\n\n\tif (type == PW_OLD_PASSWORD) {\n\t\tattr = find_attribute(request, PW_OLD_PASSWORD);\n\t}\n\n\tif (!attr) {\n\t\tadd_attribute(request, type, hashed, length);\n\t} else {\n\t\tmemcpy(attr->data, hashed, length); /* overwrite the packet */\n\t}\n}", "func_src_after": "static void add_password(AUTH_HDR *request, unsigned char type, CONST char *password, char *secret)\n{\n\tMD5_CTX md5_secret, my_md5;\n\tunsigned char misc[AUTH_VECTOR_LEN];\n\tint i;\n\tint length = strlen(password);\n\tunsigned char hashed[256 + AUTH_PASS_LEN];\t/* can't be longer than this */\n\tunsigned char *vector;\n\tattribute_t *attr;\n\n\tif (length > MAXPASS) {\t\t\t\t/* shorten the password for now */\n\t\tlength = MAXPASS;\n\t}\n\n\tif (length == 0) {\n\t\tlength = AUTH_PASS_LEN;\t\t\t/* 0 maps to 16 */\n\t} if ((length & (AUTH_PASS_LEN - 1)) != 0) {\n\t\tlength += (AUTH_PASS_LEN - 1);\t\t/* round it up */\n\t\tlength &= ~(AUTH_PASS_LEN - 1);\t\t/* chop it off */\n\t}\t\t\t\t\t\t/* 16*N maps to itself */\n\n\tmemset(hashed, 0, length);\n\tmemcpy(hashed, password, length);\n\n\tattr = find_attribute(request, PW_PASSWORD);\n\n\tif (type == PW_PASSWORD) {\n\t\tvector = request->vector;\n\t} else {\n\t\tvector = attr->data;\t\t\t/* attr CANNOT be NULL here. */\n\t}\n\n\t/* ************************************************************ */\n\t/* encrypt the password */\n\t/* password : e[0] = p[0] ^ MD5(secret + vector) */\n\tMD5Init(&md5_secret);\n\tMD5Update(&md5_secret, (unsigned char *) secret, strlen(secret));\n\tmy_md5 = md5_secret;\t\t\t\t/* so we won't re-do the hash later */\n\tMD5Update(&my_md5, vector, AUTH_VECTOR_LEN);\n\tMD5Final(misc, &my_md5);\t\t\t/* set the final vector */\n\txor(hashed, misc, AUTH_PASS_LEN);\n\n\t/* For each step through, e[i] = p[i] ^ MD5(secret + e[i-1]) */\n\tfor (i = 1; i < (length >> 4); i++) {\n\t\tmy_md5 = md5_secret;\t\t\t/* grab old value of the hash */\n\t\tMD5Update(&my_md5, &hashed[(i-1) * AUTH_PASS_LEN], AUTH_PASS_LEN);\n\t\tMD5Final(misc, &my_md5);\t\t\t/* set the final vector */\n\t\txor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN);\n\t}\n\n\tif (type == PW_OLD_PASSWORD) {\n\t\tattr = find_attribute(request, PW_OLD_PASSWORD);\n\t}\n\n\tif (!attr) {\n\t\tadd_attribute(request, type, hashed, length);\n\t} else {\n\t\tmemcpy(attr->data, hashed, length); /* overwrite the packet */\n\t}\n}", "line_changes": {"deleted": [{"line_no": 23, "char_start": 698, "char_end": 743, "line": "\tmemcpy(hashed, password, strlen(password));\n"}], "added": [{"line_no": 23, "char_start": 698, "char_end": 733, "line": "\tmemcpy(hashed, password, length);\n"}]}, "char_changes": {"deleted": [{"char_start": 724, "char_end": 727, "chars": "str"}, {"char_start": 730, "char_end": 740, "chars": "(password)"}], "added": [{"char_start": 727, "char_end": 730, "chars": "gth"}]}, "commit_link": "github.com/FreeRADIUS/pam_radius/commit/01173ec2426627dbb1e0d96c06c3ffa0b14d36d0", "file_name": "src/pam_radius_auth.c", "vul_type": "cwe-787"}
{"func_name": "unicode_unfold_key", "func_src_before": "unicode_unfold_key(OnigCodePoint code)\n{\n  static const struct ByUnfoldKey wordlist[] =\n    {\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0},\n\n      {0x1040a, 3267, 1},\n\n      {0x1e0a, 1727, 1},\n\n      {0x040a, 1016, 1},\n\n      {0x010a, 186, 1},\n\n      {0x1f0a, 2088, 1},\n\n      {0x2c0a, 2451, 1},\n\n      {0x0189, 619, 1},\n\n      {0x1f89, 134, 2},\n\n      {0x1f85, 154, 2},\n\n      {0x0389, 733, 1},\n\n      {0x03ff, 724, 1},\n\n      {0xab89, 1523, 1},\n\n      {0xab85, 1511, 1},\n\n      {0x10c89, 3384, 1},\n\n      {0x10c85, 3372, 1},\n\n      {0x1e84, 1911, 1},\n\n      {0x03f5, 752, 1},\n\n      {0x0184, 360, 1},\n\n      {0x1f84, 149, 2},\n\n      {0x2c84, 2592, 1},\n\n      {0x017d, 351, 1},\n\n      {0x1ff3, 96, 2},\n\n      {0xab84, 1508, 1},\n\n      {0xa784, 3105, 1},\n\n      {0x10c84, 3369, 1},\n\n      {0xab7d, 1487, 1},\n\n      {0xa77d, 1706, 1},\n\n      {0x1e98, 38, 2},\n\n      {0x0498, 1106, 1},\n\n      {0x0198, 375, 1},\n\n      {0x1f98, 169, 2},\n\n      {0x2c98, 2622, 1},\n\n      {0x0398, 762, 1},\n\n      {0xa684, 2940, 1},\n\n      {0xab98, 1568, 1},\n\n      {0xa798, 3123, 1},\n\n      {0x10c98, 3429, 1},\n\n      {0x050a, 1277, 1},\n\n      {0x1ffb, 2265, 1},\n\n      {0x1e96, 16, 2},\n\n      {0x0496, 1103, 1},\n\n      {0x0196, 652, 1},\n\n      {0x1f96, 199, 2},\n\n      {0x2c96, 2619, 1},\n\n      {0x0396, 756, 1},\n\n      {0xa698, 2970, 1},\n\n      {0xab96, 1562, 1},\n\n      {0xa796, 3120, 1},\n\n      {0x10c96, 3423, 1},\n\n      {0x1feb, 2259, 1},\n\n      {0x2ceb, 2736, 1},\n\n      {0x1e90, 1929, 1},\n\n      {0x0490, 1094, 1},\n\n      {0x0190, 628, 1},\n\n      {0x1f90, 169, 2},\n\n      {0x2c90, 2610, 1},\n\n      {0x0390, 25, 3},\n\n      {0xa696, 2967, 1},\n\n      {0xab90, 1544, 1},\n\n      {0xa790, 3114, 1},\n\n      {0x10c90, 3405, 1},\n\n      {0x01d7, 444, 1},\n\n      {0x1fd7, 31, 3},\n\n      {0x1ea6, 1947, 1},\n\n      {0x04a6, 1127, 1},\n\n      {0x01a6, 676, 1},\n\n      {0x1fa6, 239, 2},\n\n      {0x2ca6, 2643, 1},\n\n      {0x03a6, 810, 1},\n\n      {0xa690, 2958, 1},\n\n      {0xaba6, 1610, 1},\n\n      {0xa7a6, 3144, 1},\n\n      {0x10ca6, 3471, 1},\n\n      {0x1ea4, 1944, 1},\n\n      {0x04a4, 1124, 1},\n\n      {0x01a4, 390, 1},\n\n      {0x1fa4, 229, 2},\n\n      {0x2ca4, 2640, 1},\n\n      {0x03a4, 804, 1},\n\n      {0x10a6, 2763, 1},\n\n      {0xaba4, 1604, 1},\n\n      {0xa7a4, 3141, 1},\n\n      {0x10ca4, 3465, 1},\n\n      {0x1ea0, 1938, 1},\n\n      {0x04a0, 1118, 1},\n\n      {0x01a0, 384, 1},\n\n      {0x1fa0, 209, 2},\n\n      {0x2ca0, 2634, 1},\n\n      {0x03a0, 792, 1},\n\n      {0x10a4, 2757, 1},\n\n      {0xaba0, 1592, 1},\n\n      {0xa7a0, 3135, 1},\n\n      {0x10ca0, 3453, 1},\n\n      {0x1eb2, 1965, 1},\n\n      {0x04b2, 1145, 1},\n\n      {0x01b2, 694, 1},\n\n      {0x1fb2, 249, 2},\n\n      {0x2cb2, 2661, 1},\n\n      {0x03fd, 718, 1},\n\n      {0x10a0, 2745, 1},\n\n      {0xabb2, 1646, 1},\n\n      {0xa7b2, 703, 1},\n\n      {0x10cb2, 3507, 1},\n\n      {0x1eac, 1956, 1},\n\n      {0x04ac, 1136, 1},\n\n      {0x01ac, 396, 1},\n\n      {0x1fac, 229, 2},\n\n      {0x2cac, 2652, 1},\n\n      {0x0537, 1352, 1},\n\n      {0x10b2, 2799, 1},\n\n      {0xabac, 1628, 1},\n\n      {0xa7ac, 637, 1},\n\n      {0x10cac, 3489, 1},\n\n      {0x1eaa, 1953, 1},\n\n      {0x04aa, 1133, 1},\n\n      {0x00dd, 162, 1},\n\n      {0x1faa, 219, 2},\n\n      {0x2caa, 2649, 1},\n\n      {0x03aa, 824, 1},\n\n      {0x10ac, 2781, 1},\n\n      {0xabaa, 1622, 1},\n\n      {0xa7aa, 646, 1},\n\n      {0x10caa, 3483, 1},\n\n      {0x1ea8, 1950, 1},\n\n      {0x04a8, 1130, 1},\n\n      {0x020a, 517, 1},\n\n      {0x1fa8, 209, 2},\n\n      {0x2ca8, 2646, 1},\n\n      {0x03a8, 817, 1},\n\n      {0x10aa, 2775, 1},\n\n      {0xaba8, 1616, 1},\n\n      {0xa7a8, 3147, 1},\n\n      {0x10ca8, 3477, 1},\n\n      {0x1ea2, 1941, 1},\n\n      {0x04a2, 1121, 1},\n\n      {0x01a2, 387, 1},\n\n      {0x1fa2, 219, 2},\n\n      {0x2ca2, 2637, 1},\n\n      {0x118a6, 3528, 1},\n\n      {0x10a8, 2769, 1},\n\n      {0xaba2, 1598, 1},\n\n      {0xa7a2, 3138, 1},\n\n      {0x10ca2, 3459, 1},\n\n      {0x2ced, 2739, 1},\n\n      {0x1fe9, 2283, 1},\n\n      {0x1fe7, 47, 3},\n\n      {0x1eb0, 1962, 1},\n\n      {0x04b0, 1142, 1},\n\n      {0x118a4, 3522, 1},\n\n      {0x10a2, 2751, 1},\n\n      {0x2cb0, 2658, 1},\n\n      {0x03b0, 41, 3},\n\n      {0x1fe3, 41, 3},\n\n      {0xabb0, 1640, 1},\n\n      {0xa7b0, 706, 1},\n\n      {0x10cb0, 3501, 1},\n\n      {0x01d9, 447, 1},\n\n      {0x1fd9, 2277, 1},\n\n      {0x118a0, 3510, 1},\n\n      {0x00df, 24, 2},\n\n      {0x00d9, 150, 1},\n\n      {0xab77, 1469, 1},\n\n      {0x10b0, 2793, 1},\n\n      {0x1eae, 1959, 1},\n\n      {0x04ae, 1139, 1},\n\n      {0x01ae, 685, 1},\n\n      {0x1fae, 239, 2},\n\n      {0x2cae, 2655, 1},\n\n      {0x118b2, 3564, 1},\n\n      {0xab73, 1457, 1},\n\n      {0xabae, 1634, 1},\n\n      {0xab71, 1451, 1},\n\n      {0x10cae, 3495, 1},\n\n      {0x1e2a, 1775, 1},\n\n      {0x042a, 968, 1},\n\n      {0x012a, 234, 1},\n\n      {0x1f2a, 2130, 1},\n\n      {0x2c2a, 2547, 1},\n\n      {0x118ac, 3546, 1},\n\n      {0x10ae, 2787, 1},\n\n      {0x0535, 1346, 1},\n\n      {0xa72a, 2988, 1},\n\n      {0x1e9a, 0, 2},\n\n      {0x049a, 1109, 1},\n\n      {0xff37, 3225, 1},\n\n      {0x1f9a, 179, 2},\n\n      {0x2c9a, 2625, 1},\n\n      {0x039a, 772, 1},\n\n      {0x118aa, 3540, 1},\n\n      {0xab9a, 1574, 1},\n\n      {0xa79a, 3126, 1},\n\n      {0x10c9a, 3435, 1},\n\n      {0x1e94, 1935, 1},\n\n      {0x0494, 1100, 1},\n\n      {0x0194, 640, 1},\n\n      {0x1f94, 189, 2},\n\n      {0x2c94, 2616, 1},\n\n      {0x0394, 749, 1},\n\n      {0x118a8, 3534, 1},\n\n      {0xab94, 1556, 1},\n\n      {0xa69a, 2973, 1},\n\n      {0x10c94, 3417, 1},\n\n      {0x10402, 3243, 1},\n\n      {0x1e02, 1715, 1},\n\n      {0x0402, 992, 1},\n\n      {0x0102, 174, 1},\n\n      {0x0533, 1340, 1},\n\n      {0x2c02, 2427, 1},\n\n      {0x118a2, 3516, 1},\n\n      {0x052a, 1325, 1},\n\n      {0xa694, 2964, 1},\n\n      {0x1e92, 1932, 1},\n\n      {0x0492, 1097, 1},\n\n      {0x2165, 2307, 1},\n\n      {0x1f92, 179, 2},\n\n      {0x2c92, 2613, 1},\n\n      {0x0392, 742, 1},\n\n      {0x2161, 2295, 1},\n\n      {0xab92, 1550, 1},\n\n      {0xa792, 3117, 1},\n\n      {0x10c92, 3411, 1},\n\n      {0x118b0, 3558, 1},\n\n      {0x1f5f, 2199, 1},\n\n      {0x1e8e, 1926, 1},\n\n      {0x048e, 1091, 1},\n\n      {0x018e, 453, 1},\n\n      {0x1f8e, 159, 2},\n\n      {0x2c8e, 2607, 1},\n\n      {0x038e, 833, 1},\n\n      {0xa692, 2961, 1},\n\n      {0xab8e, 1538, 1},\n\n      {0x0055, 59, 1},\n\n      {0x10c8e, 3399, 1},\n\n      {0x1f5d, 2196, 1},\n\n      {0x212a, 27, 1},\n\n      {0x04cb, 1181, 1},\n\n      {0x01cb, 425, 1},\n\n      {0x1fcb, 2241, 1},\n\n      {0x118ae, 3552, 1},\n\n      {0x0502, 1265, 1},\n\n      {0x00cb, 111, 1},\n\n      {0xa68e, 2955, 1},\n\n      {0x1e8a, 1920, 1},\n\n      {0x048a, 1085, 1},\n\n      {0x018a, 622, 1},\n\n      {0x1f8a, 139, 2},\n\n      {0x2c8a, 2601, 1},\n\n      {0x038a, 736, 1},\n\n      {0x2c67, 2571, 1},\n\n      {0xab8a, 1526, 1},\n\n      {0x1e86, 1914, 1},\n\n      {0x10c8a, 3387, 1},\n\n      {0x0186, 616, 1},\n\n      {0x1f86, 159, 2},\n\n      {0x2c86, 2595, 1},\n\n      {0x0386, 727, 1},\n\n      {0xff35, 3219, 1},\n\n      {0xab86, 1514, 1},\n\n      {0xa786, 3108, 1},\n\n      {0x10c86, 3375, 1},\n\n      {0xa68a, 2949, 1},\n\n      {0x0555, 1442, 1},\n\n      {0x1ebc, 1980, 1},\n\n      {0x04bc, 1160, 1},\n\n      {0x01bc, 411, 1},\n\n      {0x1fbc, 62, 2},\n\n      {0x2cbc, 2676, 1},\n\n      {0x1f5b, 2193, 1},\n\n      {0xa686, 2943, 1},\n\n      {0xabbc, 1676, 1},\n\n      {0x1eb8, 1974, 1},\n\n      {0x04b8, 1154, 1},\n\n      {0x01b8, 408, 1},\n\n      {0x1fb8, 2268, 1},\n\n      {0x2cb8, 2670, 1},\n\n      {0x01db, 450, 1},\n\n      {0x1fdb, 2247, 1},\n\n      {0xabb8, 1664, 1},\n\n      {0x10bc, 2829, 1},\n\n      {0x00db, 156, 1},\n\n      {0x1eb6, 1971, 1},\n\n      {0x04b6, 1151, 1},\n\n      {0xff33, 3213, 1},\n\n      {0x1fb6, 58, 2},\n\n      {0x2cb6, 2667, 1},\n\n      {0xff2a, 3186, 1},\n\n      {0x10b8, 2817, 1},\n\n      {0xabb6, 1658, 1},\n\n      {0xa7b6, 3153, 1},\n\n      {0x10426, 3351, 1},\n\n      {0x1e26, 1769, 1},\n\n      {0x0426, 956, 1},\n\n      {0x0126, 228, 1},\n\n      {0x0053, 52, 1},\n\n      {0x2c26, 2535, 1},\n\n      {0x0057, 65, 1},\n\n      {0x10b6, 2811, 1},\n\n      {0x022a, 562, 1},\n\n      {0xa726, 2982, 1},\n\n      {0x1e2e, 1781, 1},\n\n      {0x042e, 980, 1},\n\n      {0x012e, 240, 1},\n\n      {0x1f2e, 2142, 1},\n\n      {0x2c2e, 2559, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2167, 2313, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa72e, 2994, 1},\n\n      {0x1e2c, 1778, 1},\n\n      {0x042c, 974, 1},\n\n      {0x012c, 237, 1},\n\n      {0x1f2c, 2136, 1},\n\n      {0x2c2c, 2553, 1},\n\n      {0x1f6f, 2223, 1},\n\n      {0x2c6f, 604, 1},\n\n      {0xabbf, 1685, 1},\n\n      {0xa72c, 2991, 1},\n\n      {0x1e28, 1772, 1},\n\n      {0x0428, 962, 1},\n\n      {0x0128, 231, 1},\n\n      {0x1f28, 2124, 1},\n\n      {0x2c28, 2541, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0553, 1436, 1},\n\n      {0x10bf, 2838, 1},\n\n      {0xa728, 2985, 1},\n\n      {0x0526, 1319, 1},\n\n      {0x0202, 505, 1},\n\n      {0x1e40, 1808, 1},\n\n      {0x10424, 3345, 1},\n\n      {0x1e24, 1766, 1},\n\n      {0x0424, 950, 1},\n\n      {0x0124, 225, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c24, 2529, 1},\n\n      {0x052e, 1331, 1},\n\n      {0xa740, 3018, 1},\n\n      {0x118bc, 3594, 1},\n\n      {0xa724, 2979, 1},\n\n      {0x1ef2, 2061, 1},\n\n      {0x04f2, 1241, 1},\n\n      {0x01f2, 483, 1},\n\n      {0x1ff2, 257, 2},\n\n      {0x2cf2, 2742, 1},\n\n      {0x052c, 1328, 1},\n\n      {0x118b8, 3582, 1},\n\n      {0xa640, 2865, 1},\n\n      {0x10422, 3339, 1},\n\n      {0x1e22, 1763, 1},\n\n      {0x0422, 944, 1},\n\n      {0x0122, 222, 1},\n\n      {0x2126, 820, 1},\n\n      {0x2c22, 2523, 1},\n\n      {0x0528, 1322, 1},\n\n      {0x01f1, 483, 1},\n\n      {0x118b6, 3576, 1},\n\n      {0xa722, 2976, 1},\n\n      {0x03f1, 796, 1},\n\n      {0x1ebe, 1983, 1},\n\n      {0x04be, 1163, 1},\n\n      {0xfb02, 12, 2},\n\n      {0x1fbe, 767, 1},\n\n      {0x2cbe, 2679, 1},\n\n      {0x01b5, 405, 1},\n\n      {0x0540, 1379, 1},\n\n      {0xabbe, 1682, 1},\n\n      {0x0524, 1316, 1},\n\n      {0x00b5, 779, 1},\n\n      {0xabb5, 1655, 1},\n\n      {0x1eba, 1977, 1},\n\n      {0x04ba, 1157, 1},\n\n      {0x216f, 2337, 1},\n\n      {0x1fba, 2226, 1},\n\n      {0x2cba, 2673, 1},\n\n      {0x10be, 2835, 1},\n\n      {0x0051, 46, 1},\n\n      {0xabba, 1670, 1},\n\n      {0x10b5, 2808, 1},\n\n      {0x1e6e, 1878, 1},\n\n      {0x046e, 1055, 1},\n\n      {0x016e, 330, 1},\n\n      {0x1f6e, 2220, 1},\n\n      {0x2c6e, 664, 1},\n\n      {0x118bf, 3603, 1},\n\n      {0x0522, 1313, 1},\n\n      {0x10ba, 2823, 1},\n\n      {0xa76e, 3087, 1},\n\n      {0x1eb4, 1968, 1},\n\n      {0x04b4, 1148, 1},\n\n      {0x2c75, 2583, 1},\n\n      {0x1fb4, 50, 2},\n\n      {0x2cb4, 2664, 1},\n\n      {0xab75, 1463, 1},\n\n      {0x1ec2, 1989, 1},\n\n      {0xabb4, 1652, 1},\n\n      {0xa7b4, 3150, 1},\n\n      {0x1fc2, 253, 2},\n\n      {0x2cc2, 2685, 1},\n\n      {0x03c2, 800, 1},\n\n      {0x00c2, 83, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff26, 3174, 1},\n\n      {0x10b4, 2805, 1},\n\n      {0x1eca, 2001, 1},\n\n      {0x0551, 1430, 1},\n\n      {0x01ca, 425, 1},\n\n      {0x1fca, 2238, 1},\n\n      {0x2cca, 2697, 1},\n\n      {0x10c2, 2847, 1},\n\n      {0x00ca, 108, 1},\n\n      {0xff2e, 3198, 1},\n\n      {0x1e8c, 1923, 1},\n\n      {0x048c, 1088, 1},\n\n      {0x0226, 556, 1},\n\n      {0x1f8c, 149, 2},\n\n      {0x2c8c, 2604, 1},\n\n      {0x038c, 830, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab8c, 1532, 1},\n\n      {0xff2c, 3192, 1},\n\n      {0x10c8c, 3393, 1},\n\n      {0x1ec4, 1992, 1},\n\n      {0x022e, 568, 1},\n\n      {0x01c4, 417, 1},\n\n      {0x1fc4, 54, 2},\n\n      {0x2cc4, 2688, 1},\n      {0xffffffff, -1, 0},\n\n      {0x00c4, 89, 1},\n\n      {0xff28, 3180, 1},\n\n      {0xa68c, 2952, 1},\n\n      {0x01cf, 432, 1},\n\n      {0x022c, 565, 1},\n\n      {0x118be, 3600, 1},\n\n      {0x03cf, 839, 1},\n\n      {0x00cf, 123, 1},\n\n      {0x118b5, 3573, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c4, 2853, 1},\n\n      {0x216e, 2334, 1},\n\n      {0x24cb, 2406, 1},\n\n      {0x0228, 559, 1},\n\n      {0xff24, 3168, 1},\n      {0xffffffff, -1, 0},\n\n      {0x118ba, 3588, 1},\n\n      {0x1efe, 2079, 1},\n\n      {0x04fe, 1259, 1},\n\n      {0x01fe, 499, 1},\n\n      {0x1e9e, 24, 2},\n\n      {0x049e, 1115, 1},\n\n      {0x03fe, 721, 1},\n\n      {0x1f9e, 199, 2},\n\n      {0x2c9e, 2631, 1},\n\n      {0x039e, 786, 1},\n\n      {0x0224, 553, 1},\n\n      {0xab9e, 1586, 1},\n\n      {0xa79e, 3132, 1},\n\n      {0x10c9e, 3447, 1},\n\n      {0x01f7, 414, 1},\n\n      {0x1ff7, 67, 3},\n\n      {0xff22, 3162, 1},\n\n      {0x03f7, 884, 1},\n\n      {0x118b4, 3570, 1},\n\n      {0x049c, 1112, 1},\n\n      {0x019c, 661, 1},\n\n      {0x1f9c, 189, 2},\n\n      {0x2c9c, 2628, 1},\n\n      {0x039c, 779, 1},\n\n      {0x24bc, 2361, 1},\n\n      {0xab9c, 1580, 1},\n\n      {0xa79c, 3129, 1},\n\n      {0x10c9c, 3441, 1},\n\n      {0x0222, 550, 1},\n\n      {0x1e7c, 1899, 1},\n\n      {0x047c, 1076, 1},\n\n      {0x1e82, 1908, 1},\n\n      {0x24b8, 2349, 1},\n\n      {0x0182, 357, 1},\n\n      {0x1f82, 139, 2},\n\n      {0x2c82, 2589, 1},\n\n      {0xab7c, 1484, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab82, 1502, 1},\n\n      {0xa782, 3102, 1},\n\n      {0x10c82, 3363, 1},\n\n      {0x2c63, 1709, 1},\n\n      {0x24b6, 2343, 1},\n\n      {0x1e80, 1905, 1},\n\n      {0x0480, 1082, 1},\n\n      {0x1f59, 2190, 1},\n\n      {0x1f80, 129, 2},\n\n      {0x2c80, 2586, 1},\n\n      {0x0059, 71, 1},\n\n      {0xa682, 2937, 1},\n\n      {0xab80, 1496, 1},\n\n      {0xa780, 3099, 1},\n\n      {0x10c80, 3357, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1e4c, 1826, 1},\n\n      {0x0145, 270, 1},\n\n      {0x014c, 279, 1},\n\n      {0x1f4c, 2184, 1},\n\n      {0x0345, 767, 1},\n\n      {0x0045, 12, 1},\n\n      {0x004c, 31, 1},\n\n      {0xa680, 2934, 1},\n\n      {0xa74c, 3036, 1},\n\n      {0x1e4a, 1823, 1},\n\n      {0x01d5, 441, 1},\n\n      {0x014a, 276, 1},\n\n      {0x1f4a, 2178, 1},\n\n      {0x03d5, 810, 1},\n\n      {0x00d5, 141, 1},\n\n      {0x004a, 24, 1},\n\n      {0x24bf, 2370, 1},\n\n      {0xa74a, 3033, 1},\n\n      {0xa64c, 2883, 1},\n\n      {0x1041c, 3321, 1},\n\n      {0x1e1c, 1754, 1},\n\n      {0x041c, 926, 1},\n\n      {0x011c, 213, 1},\n\n      {0x1f1c, 2118, 1},\n\n      {0x2c1c, 2505, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xa64a, 2880, 1},\n\n      {0x1041a, 3315, 1},\n\n      {0x1e1a, 1751, 1},\n\n      {0x041a, 920, 1},\n\n      {0x011a, 210, 1},\n\n      {0x1f1a, 2112, 1},\n\n      {0x2c1a, 2499, 1},\n\n      {0xabbd, 1679, 1},\n\n      {0x0545, 1394, 1},\n\n      {0x054c, 1415, 1},\n\n      {0x10418, 3309, 1},\n\n      {0x1e18, 1748, 1},\n\n      {0x0418, 914, 1},\n\n      {0x0118, 207, 1},\n\n      {0x1f18, 2106, 1},\n\n      {0x2c18, 2493, 1},\n\n      {0x10bd, 2832, 1},\n\n      {0x2163, 2301, 1},\n\n      {0x054a, 1409, 1},\n\n      {0x1040e, 3279, 1},\n\n      {0x1e0e, 1733, 1},\n\n      {0x040e, 1028, 1},\n\n      {0x010e, 192, 1},\n\n      {0x1f0e, 2100, 1},\n\n      {0x2c0e, 2463, 1},\n\n      {0x1efc, 2076, 1},\n\n      {0x04fc, 1256, 1},\n\n      {0x01fc, 496, 1},\n\n      {0x1ffc, 96, 2},\n\n      {0x051c, 1304, 1},\n\n      {0x1040c, 3273, 1},\n\n      {0x1e0c, 1730, 1},\n\n      {0x040c, 1022, 1},\n\n      {0x010c, 189, 1},\n\n      {0x1f0c, 2094, 1},\n\n      {0x2c0c, 2457, 1},\n\n      {0x1f6d, 2217, 1},\n\n      {0x2c6d, 607, 1},\n\n      {0x051a, 1301, 1},\n\n      {0x24be, 2367, 1},\n\n      {0x10408, 3261, 1},\n\n      {0x1e08, 1724, 1},\n\n      {0x0408, 1010, 1},\n\n      {0x0108, 183, 1},\n\n      {0x1f08, 2082, 1},\n\n      {0x2c08, 2445, 1},\n\n      {0x04c9, 1178, 1},\n\n      {0x0518, 1298, 1},\n\n      {0x1fc9, 2235, 1},\n      {0xffffffff, -1, 0},\n\n      {0x24ba, 2355, 1},\n\n      {0x00c9, 105, 1},\n\n      {0x10416, 3303, 1},\n\n      {0x1e16, 1745, 1},\n\n      {0x0416, 908, 1},\n\n      {0x0116, 204, 1},\n\n      {0x050e, 1283, 1},\n\n      {0x2c16, 2487, 1},\n\n      {0x10414, 3297, 1},\n\n      {0x1e14, 1742, 1},\n\n      {0x0414, 902, 1},\n\n      {0x0114, 201, 1},\n\n      {0x042b, 971, 1},\n\n      {0x2c14, 2481, 1},\n\n      {0x1f2b, 2133, 1},\n\n      {0x2c2b, 2550, 1},\n      {0xffffffff, -1, 0},\n\n      {0x050c, 1280, 1},\n\n      {0x10406, 3255, 1},\n\n      {0x1e06, 1721, 1},\n\n      {0x0406, 1004, 1},\n\n      {0x0106, 180, 1},\n\n      {0x13fb, 1697, 1},\n\n      {0x2c06, 2439, 1},\n\n      {0x24c2, 2379, 1},\n\n      {0x118bd, 3597, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0508, 1274, 1},\n\n      {0x10404, 3249, 1},\n\n      {0x1e04, 1718, 1},\n\n      {0x0404, 998, 1},\n\n      {0x0104, 177, 1},\n\n      {0x1f95, 194, 2},\n\n      {0x2c04, 2433, 1},\n\n      {0x0395, 752, 1},\n\n      {0x24ca, 2403, 1},\n\n      {0xab95, 1559, 1},\n\n      {0x0531, 1334, 1},\n\n      {0x10c95, 3420, 1},\n\n      {0x0516, 1295, 1},\n\n      {0x1e6c, 1875, 1},\n\n      {0x046c, 1052, 1},\n\n      {0x016c, 327, 1},\n\n      {0x1f6c, 2214, 1},\n\n      {0x216d, 2331, 1},\n\n      {0x0514, 1292, 1},\n\n      {0x0245, 697, 1},\n\n      {0x024c, 598, 1},\n\n      {0xa76c, 3084, 1},\n\n      {0x10400, 3237, 1},\n\n      {0x1e00, 1712, 1},\n\n      {0x0400, 986, 1},\n\n      {0x0100, 171, 1},\n\n      {0x24c4, 2385, 1},\n\n      {0x2c00, 2421, 1},\n\n      {0x0506, 1271, 1},\n\n      {0x024a, 595, 1},\n\n      {0x1fab, 224, 2},\n\n      {0xa66c, 2931, 1},\n\n      {0x03ab, 827, 1},\n\n      {0x24cf, 2418, 1},\n\n      {0xabab, 1625, 1},\n\n      {0xa7ab, 631, 1},\n\n      {0x10cab, 3486, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0504, 1268, 1},\n      {0xffffffff, -1, 0},\n\n      {0x021c, 544, 1},\n\n      {0x01a9, 679, 1},\n\n      {0x1fa9, 214, 2},\n\n      {0x10ab, 2778, 1},\n\n      {0x03a9, 820, 1},\n\n      {0x212b, 92, 1},\n\n      {0xaba9, 1619, 1},\n\n      {0x1e88, 1917, 1},\n\n      {0x10ca9, 3480, 1},\n\n      {0x021a, 541, 1},\n\n      {0x1f88, 129, 2},\n\n      {0x2c88, 2598, 1},\n\n      {0x0388, 730, 1},\n\n      {0x13fd, 1703, 1},\n\n      {0xab88, 1520, 1},\n\n      {0x10a9, 2772, 1},\n\n      {0x10c88, 3381, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0218, 538, 1},\n\n      {0x0500, 1262, 1},\n\n      {0x1f4d, 2187, 1},\n\n      {0x01a7, 393, 1},\n\n      {0x1fa7, 244, 2},\n\n      {0x004d, 34, 1},\n\n      {0x03a7, 814, 1},\n\n      {0xa688, 2946, 1},\n\n      {0xaba7, 1613, 1},\n\n      {0x020e, 523, 1},\n\n      {0x10ca7, 3474, 1},\n\n      {0x1e6a, 1872, 1},\n\n      {0x046a, 1049, 1},\n\n      {0x016a, 324, 1},\n\n      {0x1f6a, 2208, 1},\n      {0xffffffff, -1, 0},\n\n      {0x216c, 2328, 1},\n\n      {0x10a7, 2766, 1},\n\n      {0x01d1, 435, 1},\n\n      {0xa76a, 3081, 1},\n\n      {0x020c, 520, 1},\n\n      {0x03d1, 762, 1},\n\n      {0x00d1, 129, 1},\n\n      {0x1e68, 1869, 1},\n\n      {0x0468, 1046, 1},\n\n      {0x0168, 321, 1},\n\n      {0x1f68, 2202, 1},\n      {0xffffffff, -1, 0},\n\n      {0xff31, 3207, 1},\n\n      {0xa66a, 2928, 1},\n\n      {0x0208, 514, 1},\n\n      {0xa768, 3078, 1},\n\n      {0x1e64, 1863, 1},\n\n      {0x0464, 1040, 1},\n\n      {0x0164, 315, 1},\n\n      {0x054d, 1418, 1},\n\n      {0x2c64, 673, 1},\n      {0xffffffff, -1, 0},\n\n      {0xff2b, 3189, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa764, 3072, 1},\n\n      {0xa668, 2925, 1},\n\n      {0x0216, 535, 1},\n      {0xffffffff, -1, 0},\n\n      {0x118ab, 3543, 1},\n\n      {0x1e62, 1860, 1},\n\n      {0x0462, 1037, 1},\n\n      {0x0162, 312, 1},\n\n      {0x0214, 532, 1},\n\n      {0x2c62, 655, 1},\n\n      {0xa664, 2919, 1},\n\n      {0x1ed2, 2013, 1},\n\n      {0x04d2, 1193, 1},\n\n      {0xa762, 3069, 1},\n\n      {0x1fd2, 20, 3},\n\n      {0x2cd2, 2709, 1},\n\n      {0x118a9, 3537, 1},\n\n      {0x00d2, 132, 1},\n\n      {0x0206, 511, 1},\n\n      {0x10420, 3333, 1},\n\n      {0x1e20, 1760, 1},\n\n      {0x0420, 938, 1},\n\n      {0x0120, 219, 1},\n\n      {0xa662, 2916, 1},\n\n      {0x2c20, 2517, 1},\n\n      {0x1e60, 1856, 1},\n\n      {0x0460, 1034, 1},\n\n      {0x0160, 309, 1},\n\n      {0x0204, 508, 1},\n\n      {0x2c60, 2562, 1},\n      {0xffffffff, -1, 0},\n\n      {0x24bd, 2364, 1},\n\n      {0x216a, 2322, 1},\n\n      {0xa760, 3066, 1},\n      {0xffffffff, -1, 0},\n\n      {0xfb16, 125, 2},\n\n      {0x118a7, 3531, 1},\n\n      {0x1efa, 2073, 1},\n\n      {0x04fa, 1253, 1},\n\n      {0x01fa, 493, 1},\n\n      {0x1ffa, 2262, 1},\n\n      {0xfb14, 109, 2},\n\n      {0x03fa, 887, 1},\n\n      {0xa660, 2913, 1},\n\n      {0x2168, 2316, 1},\n\n      {0x01b7, 700, 1},\n\n      {0x1fb7, 10, 3},\n\n      {0x1f6b, 2211, 1},\n\n      {0x2c6b, 2577, 1},\n\n      {0x0200, 502, 1},\n\n      {0xabb7, 1661, 1},\n\n      {0xfb06, 29, 2},\n\n      {0x1e56, 1841, 1},\n\n      {0x2164, 2304, 1},\n\n      {0x0156, 294, 1},\n\n      {0x1f56, 62, 3},\n\n      {0x0520, 1310, 1},\n\n      {0x004f, 40, 1},\n\n      {0x0056, 62, 1},\n\n      {0x10b7, 2814, 1},\n\n      {0xa756, 3051, 1},\n\n      {0xfb04, 5, 3},\n\n      {0x1e78, 1893, 1},\n\n      {0x0478, 1070, 1},\n\n      {0x0178, 168, 1},\n\n      {0x1e54, 1838, 1},\n\n      {0x2162, 2298, 1},\n\n      {0x0154, 291, 1},\n\n      {0x1f54, 57, 3},\n\n      {0xab78, 1472, 1},\n\n      {0xa656, 2898, 1},\n\n      {0x0054, 56, 1},\n\n      {0x1e52, 1835, 1},\n\n      {0xa754, 3048, 1},\n\n      {0x0152, 288, 1},\n\n      {0x1f52, 52, 3},\n\n      {0x24c9, 2400, 1},\n\n      {0x1e32, 1787, 1},\n\n      {0x0052, 49, 1},\n\n      {0x0132, 243, 1},\n\n      {0xa752, 3045, 1},\n      {0xffffffff, -1, 0},\n\n      {0xfb00, 4, 2},\n\n      {0xa654, 2895, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa732, 2997, 1},\n\n      {0x2160, 2292, 1},\n\n      {0x054f, 1424, 1},\n\n      {0x0556, 1445, 1},\n\n      {0x1e50, 1832, 1},\n\n      {0xa652, 2892, 1},\n\n      {0x0150, 285, 1},\n\n      {0x1f50, 84, 2},\n\n      {0x017b, 348, 1},\n\n      {0x1e4e, 1829, 1},\n\n      {0x0050, 43, 1},\n\n      {0x014e, 282, 1},\n\n      {0xa750, 3042, 1},\n\n      {0xab7b, 1481, 1},\n\n      {0xa77b, 3093, 1},\n\n      {0x004e, 37, 1},\n\n      {0x0554, 1439, 1},\n\n      {0xa74e, 3039, 1},\n\n      {0x1e48, 1820, 1},\n      {0xffffffff, -1, 0},\n\n      {0x216b, 2325, 1},\n\n      {0x1f48, 2172, 1},\n\n      {0xa650, 2889, 1},\n\n      {0x0552, 1433, 1},\n\n      {0x0048, 21, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa748, 3030, 1},\n\n      {0xa64e, 2886, 1},\n\n      {0x0532, 1337, 1},\n\n      {0x1041e, 3327, 1},\n\n      {0x1e1e, 1757, 1},\n\n      {0x041e, 932, 1},\n\n      {0x011e, 216, 1},\n\n      {0x118b7, 3579, 1},\n\n      {0x2c1e, 2511, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa648, 2877, 1},\n\n      {0x1ff9, 2253, 1},\n      {0xffffffff, -1, 0},\n\n      {0x03f9, 878, 1},\n\n      {0x0550, 1427, 1},\n\n      {0x10412, 3291, 1},\n\n      {0x1e12, 1739, 1},\n\n      {0x0412, 896, 1},\n\n      {0x0112, 198, 1},\n\n      {0x054e, 1421, 1},\n\n      {0x2c12, 2475, 1},\n\n      {0x10410, 3285, 1},\n\n      {0x1e10, 1736, 1},\n\n      {0x0410, 890, 1},\n\n      {0x0110, 195, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c10, 2469, 1},\n\n      {0x2132, 2289, 1},\n\n      {0x0548, 1403, 1},\n\n      {0x1ef8, 2070, 1},\n\n      {0x04f8, 1250, 1},\n\n      {0x01f8, 490, 1},\n\n      {0x1ff8, 2250, 1},\n\n      {0x0220, 381, 1},\n\n      {0x1ee2, 2037, 1},\n\n      {0x04e2, 1217, 1},\n\n      {0x01e2, 462, 1},\n\n      {0x1fe2, 36, 3},\n\n      {0x2ce2, 2733, 1},\n\n      {0x03e2, 857, 1},\n\n      {0x051e, 1307, 1},\n\n      {0x1ede, 2031, 1},\n\n      {0x04de, 1211, 1},\n\n      {0x01de, 456, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2cde, 2727, 1},\n\n      {0x03de, 851, 1},\n\n      {0x00de, 165, 1},\n\n      {0x1f69, 2205, 1},\n\n      {0x2c69, 2574, 1},\n\n      {0x1eda, 2025, 1},\n\n      {0x04da, 1205, 1},\n\n      {0x0512, 1289, 1},\n\n      {0x1fda, 2244, 1},\n\n      {0x2cda, 2721, 1},\n\n      {0x03da, 845, 1},\n\n      {0x00da, 153, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0510, 1286, 1},\n\n      {0x1ed8, 2022, 1},\n\n      {0x04d8, 1202, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fd8, 2274, 1},\n\n      {0x2cd8, 2718, 1},\n\n      {0x03d8, 842, 1},\n\n      {0x00d8, 147, 1},\n\n      {0x1ed6, 2019, 1},\n\n      {0x04d6, 1199, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fd6, 76, 2},\n\n      {0x2cd6, 2715, 1},\n\n      {0x03d6, 792, 1},\n\n      {0x00d6, 144, 1},\n\n      {0x1ec8, 1998, 1},\n      {0xffffffff, -1, 0},\n\n      {0x01c8, 421, 1},\n\n      {0x1fc8, 2232, 1},\n\n      {0x2cc8, 2694, 1},\n\n      {0xff32, 3210, 1},\n\n      {0x00c8, 102, 1},\n\n      {0x04c7, 1175, 1},\n\n      {0x01c7, 421, 1},\n\n      {0x1fc7, 15, 3},\n\n      {0x1ec0, 1986, 1},\n\n      {0x04c0, 1187, 1},\n\n      {0x00c7, 99, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2cc0, 2682, 1},\n\n      {0x0179, 345, 1},\n\n      {0x00c0, 77, 1},\n\n      {0x0232, 574, 1},\n\n      {0x01b3, 402, 1},\n\n      {0x1fb3, 62, 2},\n\n      {0xab79, 1475, 1},\n\n      {0xa779, 3090, 1},\n\n      {0x10c7, 2859, 1},\n\n      {0xabb3, 1649, 1},\n\n      {0xa7b3, 3156, 1},\n\n      {0x1fa5, 234, 2},\n\n      {0x10c0, 2841, 1},\n\n      {0x03a5, 807, 1},\n      {0xffffffff, -1, 0},\n\n      {0xaba5, 1607, 1},\n\n      {0x01b1, 691, 1},\n\n      {0x10ca5, 3468, 1},\n\n      {0x10b3, 2802, 1},\n\n      {0x2169, 2319, 1},\n\n      {0x024e, 601, 1},\n\n      {0xabb1, 1643, 1},\n\n      {0xa7b1, 682, 1},\n\n      {0x10cb1, 3504, 1},\n\n      {0x10a5, 2760, 1},\n      {0xffffffff, -1, 0},\n\n      {0x01af, 399, 1},\n\n      {0x1faf, 244, 2},\n      {0xffffffff, -1, 0},\n\n      {0x0248, 592, 1},\n\n      {0x10b1, 2796, 1},\n\n      {0xabaf, 1637, 1},\n\n      {0x1fad, 234, 2},\n\n      {0x10caf, 3498, 1},\n\n      {0x04cd, 1184, 1},\n\n      {0x01cd, 429, 1},\n\n      {0xabad, 1631, 1},\n\n      {0xa7ad, 658, 1},\n\n      {0x10cad, 3492, 1},\n\n      {0x00cd, 117, 1},\n\n      {0x10af, 2790, 1},\n\n      {0x021e, 547, 1},\n\n      {0x1fa3, 224, 2},\n      {0xffffffff, -1, 0},\n\n      {0x03a3, 800, 1},\n\n      {0x10ad, 2784, 1},\n\n      {0xaba3, 1601, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10ca3, 3462, 1},\n\n      {0x10cd, 2862, 1},\n\n      {0x1fa1, 214, 2},\n\n      {0x24b7, 2346, 1},\n\n      {0x03a1, 796, 1},\n\n      {0x0212, 529, 1},\n\n      {0xaba1, 1595, 1},\n\n      {0x10a3, 2754, 1},\n\n      {0x10ca1, 3456, 1},\n\n      {0x01d3, 438, 1},\n\n      {0x1fd3, 25, 3},\n\n      {0x0210, 526, 1},\n      {0xffffffff, -1, 0},\n\n      {0x00d3, 135, 1},\n\n      {0x1e97, 34, 2},\n\n      {0x10a1, 2748, 1},\n\n      {0x0197, 649, 1},\n\n      {0x1f97, 204, 2},\n      {0xffffffff, -1, 0},\n\n      {0x0397, 759, 1},\n\n      {0x1041d, 3324, 1},\n\n      {0xab97, 1565, 1},\n\n      {0x041d, 929, 1},\n\n      {0x10c97, 3426, 1},\n\n      {0x1f1d, 2121, 1},\n\n      {0x2c1d, 2508, 1},\n\n      {0x1e72, 1884, 1},\n\n      {0x0472, 1061, 1},\n\n      {0x0172, 336, 1},\n\n      {0x118b3, 3567, 1},\n\n      {0x2c72, 2580, 1},\n\n      {0x0372, 712, 1},\n\n      {0x1041b, 3318, 1},\n\n      {0xab72, 1454, 1},\n\n      {0x041b, 923, 1},\n\n      {0x118a5, 3525, 1},\n\n      {0x1f1b, 2115, 1},\n\n      {0x2c1b, 2502, 1},\n\n      {0x1e70, 1881, 1},\n\n      {0x0470, 1058, 1},\n\n      {0x0170, 333, 1},\n\n      {0x118b1, 3561, 1},\n\n      {0x2c70, 610, 1},\n\n      {0x0370, 709, 1},\n\n      {0x1e46, 1817, 1},\n\n      {0xab70, 1448, 1},\n\n      {0x1e66, 1866, 1},\n\n      {0x0466, 1043, 1},\n\n      {0x0166, 318, 1},\n\n      {0x1e44, 1814, 1},\n\n      {0x0046, 15, 1},\n\n      {0x118af, 3555, 1},\n\n      {0xa746, 3027, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa766, 3075, 1},\n\n      {0x0044, 9, 1},\n\n      {0x118ad, 3549, 1},\n\n      {0xa744, 3024, 1},\n\n      {0x1e7a, 1896, 1},\n\n      {0x047a, 1073, 1},\n\n      {0x1e3a, 1799, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa646, 2874, 1},\n\n      {0x1f3a, 2154, 1},\n\n      {0xa666, 2922, 1},\n\n      {0xab7a, 1478, 1},\n\n      {0x118a3, 3519, 1},\n\n      {0xa644, 2871, 1},\n\n      {0xa73a, 3009, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1ef4, 2064, 1},\n\n      {0x04f4, 1244, 1},\n\n      {0x01f4, 487, 1},\n\n      {0x1ff4, 101, 2},\n\n      {0x118a1, 3513, 1},\n\n      {0x03f4, 762, 1},\n\n      {0x1eec, 2052, 1},\n\n      {0x04ec, 1232, 1},\n\n      {0x01ec, 477, 1},\n\n      {0x1fec, 2286, 1},\n\n      {0x0546, 1397, 1},\n\n      {0x03ec, 872, 1},\n      {0xffffffff, -1, 0},\n\n      {0x013f, 261, 1},\n\n      {0x1f3f, 2169, 1},\n\n      {0x0544, 1391, 1},\n\n      {0x1eea, 2049, 1},\n\n      {0x04ea, 1229, 1},\n\n      {0x01ea, 474, 1},\n\n      {0x1fea, 2256, 1},\n      {0xffffffff, -1, 0},\n\n      {0x03ea, 869, 1},\n\n      {0x1ee8, 2046, 1},\n\n      {0x04e8, 1226, 1},\n\n      {0x01e8, 471, 1},\n\n      {0x1fe8, 2280, 1},\n\n      {0x053a, 1361, 1},\n\n      {0x03e8, 866, 1},\n\n      {0x1ee6, 2043, 1},\n\n      {0x04e6, 1223, 1},\n\n      {0x01e6, 468, 1},\n\n      {0x1fe6, 88, 2},\n\n      {0x1f4b, 2181, 1},\n\n      {0x03e6, 863, 1},\n\n      {0x1e5e, 1853, 1},\n\n      {0x004b, 27, 1},\n\n      {0x015e, 306, 1},\n\n      {0x2166, 2310, 1},\n\n      {0x1ee4, 2040, 1},\n\n      {0x04e4, 1220, 1},\n\n      {0x01e4, 465, 1},\n\n      {0x1fe4, 80, 2},\n\n      {0xa75e, 3063, 1},\n\n      {0x03e4, 860, 1},\n\n      {0x1ee0, 2034, 1},\n\n      {0x04e0, 1214, 1},\n\n      {0x01e0, 459, 1},\n\n      {0x053f, 1376, 1},\n\n      {0x2ce0, 2730, 1},\n\n      {0x03e0, 854, 1},\n\n      {0x1edc, 2028, 1},\n\n      {0x04dc, 1208, 1},\n\n      {0xa65e, 2910, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2cdc, 2724, 1},\n\n      {0x03dc, 848, 1},\n\n      {0x00dc, 159, 1},\n\n      {0x1ed0, 2010, 1},\n\n      {0x04d0, 1190, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0x2cd0, 2706, 1},\n\n      {0x03d0, 742, 1},\n\n      {0x00d0, 126, 1},\n\n      {0x1ecc, 2004, 1},\n\n      {0x054b, 1412, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fcc, 71, 2},\n\n      {0x2ccc, 2700, 1},\n\n      {0x1ec6, 1995, 1},\n\n      {0x00cc, 114, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fc6, 67, 2},\n\n      {0x2cc6, 2691, 1},\n\n      {0x24c8, 2397, 1},\n\n      {0x00c6, 96, 1},\n\n      {0x04c5, 1172, 1},\n\n      {0x01c5, 417, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fbb, 2229, 1},\n\n      {0x24c7, 2394, 1},\n\n      {0x00c5, 92, 1},\n\n      {0x1fb9, 2271, 1},\n\n      {0xabbb, 1673, 1},\n\n      {0x24c0, 2373, 1},\n\n      {0x04c3, 1169, 1},\n\n      {0xabb9, 1667, 1},\n\n      {0x1fc3, 71, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0x00c3, 86, 1},\n\n      {0x10c5, 2856, 1},\n\n      {0x10bb, 2826, 1},\n\n      {0x1ed4, 2016, 1},\n\n      {0x04d4, 1196, 1},\n\n      {0x10b9, 2820, 1},\n\n      {0x13fc, 1700, 1},\n\n      {0x2cd4, 2712, 1},\n\n      {0x0246, 589, 1},\n\n      {0x00d4, 138, 1},\n\n      {0x10c3, 2850, 1},\n      {0xffffffff, -1, 0},\n\n      {0xff3a, 3234, 1},\n\n      {0x0244, 688, 1},\n\n      {0x019f, 670, 1},\n\n      {0x1f9f, 204, 2},\n      {0xffffffff, -1, 0},\n\n      {0x039f, 789, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab9f, 1589, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c9f, 3450, 1},\n\n      {0x019d, 667, 1},\n\n      {0x1f9d, 194, 2},\n\n      {0x023a, 2565, 1},\n\n      {0x039d, 783, 1},\n\n      {0x1e5a, 1847, 1},\n\n      {0xab9d, 1583, 1},\n\n      {0x015a, 300, 1},\n\n      {0x10c9d, 3444, 1},\n\n      {0x1e9b, 1856, 1},\n\n      {0x24cd, 2412, 1},\n\n      {0x005a, 74, 1},\n\n      {0x1f9b, 184, 2},\n\n      {0xa75a, 3057, 1},\n\n      {0x039b, 776, 1},\n\n      {0x1ece, 2007, 1},\n\n      {0xab9b, 1577, 1},\n\n      {0x1e99, 42, 2},\n\n      {0x10c9b, 3438, 1},\n\n      {0x2cce, 2703, 1},\n\n      {0x1f99, 174, 2},\n\n      {0x00ce, 120, 1},\n\n      {0x0399, 767, 1},\n\n      {0xa65a, 2904, 1},\n\n      {0xab99, 1571, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c99, 3432, 1},\n\n      {0x0193, 634, 1},\n\n      {0x1f93, 184, 2},\n\n      {0x1e58, 1844, 1},\n\n      {0x0393, 746, 1},\n\n      {0x0158, 297, 1},\n\n      {0xab93, 1553, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c93, 3414, 1},\n\n      {0x0058, 68, 1},\n\n      {0x042d, 977, 1},\n\n      {0xa758, 3054, 1},\n\n      {0x1f2d, 2139, 1},\n\n      {0x2c2d, 2556, 1},\n\n      {0x118bb, 3591, 1},\n\n      {0x0191, 369, 1},\n\n      {0x1f91, 174, 2},\n\n      {0x118b9, 3585, 1},\n\n      {0x0391, 739, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab91, 1547, 1},\n\n      {0xa658, 2901, 1},\n\n      {0x10c91, 3408, 1},\n\n      {0x018f, 625, 1},\n\n      {0x1f8f, 164, 2},\n      {0xffffffff, -1, 0},\n\n      {0x038f, 836, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab8f, 1541, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c8f, 3402, 1},\n\n      {0x018b, 366, 1},\n\n      {0x1f8b, 144, 2},\n      {0xffffffff, -1, 0},\n\n      {0x0187, 363, 1},\n\n      {0x1f87, 164, 2},\n\n      {0xab8b, 1529, 1},\n\n      {0xa78b, 3111, 1},\n\n      {0x10c8b, 3390, 1},\n\n      {0xab87, 1517, 1},\n\n      {0x04c1, 1166, 1},\n\n      {0x10c87, 3378, 1},\n\n      {0x1e7e, 1902, 1},\n\n      {0x047e, 1079, 1},\n      {0xffffffff, -1, 0},\n\n      {0x00c1, 80, 1},\n\n      {0x2c7e, 580, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xab7e, 1490, 1},\n\n      {0xa77e, 3096, 1},\n\n      {0x1e76, 1890, 1},\n\n      {0x0476, 1067, 1},\n\n      {0x0176, 342, 1},\n\n      {0x1e42, 1811, 1},\n\n      {0x10c1, 2844, 1},\n\n      {0x0376, 715, 1},\n\n      {0x1e36, 1793, 1},\n\n      {0xab76, 1466, 1},\n\n      {0x0136, 249, 1},\n\n      {0x0042, 3, 1},\n\n      {0x1e3e, 1805, 1},\n\n      {0xa742, 3021, 1},\n\n      {0x1e38, 1796, 1},\n\n      {0x1f3e, 2166, 1},\n\n      {0xa736, 3003, 1},\n\n      {0x1f38, 2148, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0587, 105, 2},\n\n      {0xa73e, 3015, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa738, 3006, 1},\n\n      {0xa642, 2868, 1},\n\n      {0x1e5c, 1850, 1},\n\n      {0x1e34, 1790, 1},\n\n      {0x015c, 303, 1},\n\n      {0x0134, 246, 1},\n\n      {0x1ef6, 2067, 1},\n\n      {0x04f6, 1247, 1},\n\n      {0x01f6, 372, 1},\n\n      {0x1ff6, 92, 2},\n\n      {0xa75c, 3060, 1},\n\n      {0xa734, 3000, 1},\n\n      {0x1ef0, 2058, 1},\n\n      {0x04f0, 1238, 1},\n\n      {0x01f0, 20, 2},\n      {0xffffffff, -1, 0},\n\n      {0x1e30, 1784, 1},\n\n      {0x03f0, 772, 1},\n\n      {0x0130, 261, 2},\n\n      {0x0542, 1385, 1},\n\n      {0xa65c, 2907, 1},\n\n      {0x1f83, 144, 2},\n\n      {0x0536, 1349, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xab83, 1505, 1},\n\n      {0x053e, 1373, 1},\n\n      {0x10c83, 3366, 1},\n\n      {0x0538, 1355, 1},\n\n      {0x1eee, 2055, 1},\n\n      {0x04ee, 1235, 1},\n\n      {0x01ee, 480, 1},\n\n      {0x1f8d, 154, 2},\n      {0xffffffff, -1, 0},\n\n      {0x03ee, 875, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab8d, 1535, 1},\n\n      {0xa78d, 643, 1},\n\n      {0x10c8d, 3396, 1},\n\n      {0x0534, 1343, 1},\n\n      {0x0181, 613, 1},\n\n      {0x1f81, 134, 2},\n\n      {0x013d, 258, 1},\n\n      {0x1f3d, 2163, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab81, 1499, 1},\n\n      {0x017f, 52, 1},\n\n      {0x10c81, 3360, 1},\n\n      {0x2c7f, 583, 1},\n\n      {0x037f, 881, 1},\n\n      {0xff2d, 3195, 1},\n\n      {0xab7f, 1493, 1},\n\n      {0x1e74, 1887, 1},\n\n      {0x0474, 1064, 1},\n\n      {0x0174, 339, 1},\n\n      {0x1e3c, 1802, 1},\n\n      {0x0149, 46, 2},\n\n      {0x1f49, 2175, 1},\n\n      {0x1f3c, 2160, 1},\n\n      {0xab74, 1460, 1},\n\n      {0x0049, 3606, 1},\n\n      {0x0143, 267, 1},\n\n      {0x24cc, 2409, 1},\n\n      {0xa73c, 3012, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0043, 6, 1},\n\n      {0x0141, 264, 1},\n\n      {0x24c6, 2391, 1},\n\n      {0x013b, 255, 1},\n\n      {0x1f3b, 2157, 1},\n\n      {0x0041, 0, 1},\n\n      {0x0139, 252, 1},\n\n      {0x1f39, 2151, 1},\n\n      {0x24c5, 2388, 1},\n\n      {0x24bb, 2358, 1},\n\n      {0x13fa, 1694, 1},\n\n      {0x053d, 1370, 1},\n\n      {0x24b9, 2352, 1},\n\n      {0x0429, 965, 1},\n\n      {0x2183, 2340, 1},\n\n      {0x1f29, 2127, 1},\n\n      {0x2c29, 2544, 1},\n\n      {0x24c3, 2382, 1},\n\n      {0x10427, 3354, 1},\n\n      {0x10425, 3348, 1},\n\n      {0x0427, 959, 1},\n\n      {0x0425, 953, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c27, 2538, 1},\n\n      {0x2c25, 2532, 1},\n\n      {0x0549, 1406, 1},\n\n      {0x053c, 1367, 1},\n\n      {0x10423, 3342, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0423, 947, 1},\n\n      {0x0543, 1388, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c23, 2526, 1},\n\n      {0xff36, 3222, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0541, 1382, 1},\n\n      {0x10421, 3336, 1},\n\n      {0x053b, 1364, 1},\n\n      {0x0421, 941, 1},\n\n      {0xff38, 3228, 1},\n\n      {0x0539, 1358, 1},\n\n      {0x2c21, 2520, 1},\n\n      {0x10419, 3312, 1},\n\n      {0x10417, 3306, 1},\n\n      {0x0419, 917, 1},\n\n      {0x0417, 911, 1},\n\n      {0x1f19, 2109, 1},\n\n      {0x2c19, 2496, 1},\n\n      {0x2c17, 2490, 1},\n\n      {0x023e, 2568, 1},\n\n      {0xff34, 3216, 1},\n\n      {0x10415, 3300, 1},\n\n      {0x10413, 3294, 1},\n\n      {0x0415, 905, 1},\n\n      {0x0413, 899, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c15, 2484, 1},\n\n      {0x2c13, 2478, 1},\n      {0xffffffff, -1, 0},\n\n      {0x24ce, 2415, 1},\n\n      {0x1040f, 3282, 1},\n      {0xffffffff, -1, 0},\n\n      {0x040f, 1031, 1},\n\n      {0xff30, 3204, 1},\n\n      {0x1f0f, 2103, 1},\n\n      {0x2c0f, 2466, 1},\n\n      {0x1040d, 3276, 1},\n      {0xffffffff, -1, 0},\n\n      {0x040d, 1025, 1},\n\n      {0x0147, 273, 1},\n\n      {0x1f0d, 2097, 1},\n\n      {0x2c0d, 2460, 1},\n\n      {0x1040b, 3270, 1},\n\n      {0x0047, 18, 1},\n\n      {0x040b, 1019, 1},\n\n      {0x0230, 571, 1},\n\n      {0x1f0b, 2091, 1},\n\n      {0x2c0b, 2454, 1},\n\n      {0x10409, 3264, 1},\n\n      {0x10405, 3252, 1},\n\n      {0x0409, 1013, 1},\n\n      {0x0405, 1001, 1},\n\n      {0x1f09, 2085, 1},\n\n      {0x2c09, 2448, 1},\n\n      {0x2c05, 2436, 1},\n\n      {0x10403, 3246, 1},\n\n      {0x10401, 3240, 1},\n\n      {0x0403, 995, 1},\n\n      {0x0401, 989, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c03, 2430, 1},\n\n      {0x2c01, 2424, 1},\n\n      {0x13f9, 1691, 1},\n\n      {0x042f, 983, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1f2f, 2145, 1},\n\n      {0x1041f, 3330, 1},\n      {0xffffffff, -1, 0},\n\n      {0x041f, 935, 1},\n\n      {0x023d, 378, 1},\n\n      {0x10411, 3288, 1},\n\n      {0x2c1f, 2514, 1},\n\n      {0x0411, 893, 1},\n\n      {0x0547, 1400, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c11, 2472, 1},\n\n      {0x10407, 3258, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0407, 1007, 1},\n\n      {0x24c1, 2376, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c07, 2442, 1},\n      {0xffffffff, -1, 0},\n\n      {0x13f8, 1688, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff39, 3231, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0243, 354, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0x0241, 586, 1},\n\n      {0xff29, 3183, 1},\n\n      {0x023b, 577, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff27, 3177, 1},\n\n      {0xff25, 3171, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff23, 3165, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff21, 3159, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0},\n\n      {0xfb17, 117, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff2f, 3201, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xfb15, 113, 2},\n\n      {0xfb13, 121, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0},\n\n      {0xfb05, 29, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xfb03, 0, 3},\n\n      {0xfb01, 8, 2}\n    };\n\n  if (0 == 0)\n    {\n      int key = hash(&code);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          OnigCodePoint gcode = wordlist[key].code;\n\n          if (code == gcode)\n            return &wordlist[key];\n        }\n    }\n  return 0;\n}", "func_src_after": "unicode_unfold_key(OnigCodePoint code)\n{\n  static const struct ByUnfoldKey wordlist[] =\n    {\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0},\n\n      {0x1040a, 3267, 1},\n\n      {0x1e0a, 1727, 1},\n\n      {0x040a, 1016, 1},\n\n      {0x010a, 186, 1},\n\n      {0x1f0a, 2088, 1},\n\n      {0x2c0a, 2451, 1},\n\n      {0x0189, 619, 1},\n\n      {0x1f89, 134, 2},\n\n      {0x1f85, 154, 2},\n\n      {0x0389, 733, 1},\n\n      {0x03ff, 724, 1},\n\n      {0xab89, 1523, 1},\n\n      {0xab85, 1511, 1},\n\n      {0x10c89, 3384, 1},\n\n      {0x10c85, 3372, 1},\n\n      {0x1e84, 1911, 1},\n\n      {0x03f5, 752, 1},\n\n      {0x0184, 360, 1},\n\n      {0x1f84, 149, 2},\n\n      {0x2c84, 2592, 1},\n\n      {0x017d, 351, 1},\n\n      {0x1ff3, 96, 2},\n\n      {0xab84, 1508, 1},\n\n      {0xa784, 3105, 1},\n\n      {0x10c84, 3369, 1},\n\n      {0xab7d, 1487, 1},\n\n      {0xa77d, 1706, 1},\n\n      {0x1e98, 38, 2},\n\n      {0x0498, 1106, 1},\n\n      {0x0198, 375, 1},\n\n      {0x1f98, 169, 2},\n\n      {0x2c98, 2622, 1},\n\n      {0x0398, 762, 1},\n\n      {0xa684, 2940, 1},\n\n      {0xab98, 1568, 1},\n\n      {0xa798, 3123, 1},\n\n      {0x10c98, 3429, 1},\n\n      {0x050a, 1277, 1},\n\n      {0x1ffb, 2265, 1},\n\n      {0x1e96, 16, 2},\n\n      {0x0496, 1103, 1},\n\n      {0x0196, 652, 1},\n\n      {0x1f96, 199, 2},\n\n      {0x2c96, 2619, 1},\n\n      {0x0396, 756, 1},\n\n      {0xa698, 2970, 1},\n\n      {0xab96, 1562, 1},\n\n      {0xa796, 3120, 1},\n\n      {0x10c96, 3423, 1},\n\n      {0x1feb, 2259, 1},\n\n      {0x2ceb, 2736, 1},\n\n      {0x1e90, 1929, 1},\n\n      {0x0490, 1094, 1},\n\n      {0x0190, 628, 1},\n\n      {0x1f90, 169, 2},\n\n      {0x2c90, 2610, 1},\n\n      {0x0390, 25, 3},\n\n      {0xa696, 2967, 1},\n\n      {0xab90, 1544, 1},\n\n      {0xa790, 3114, 1},\n\n      {0x10c90, 3405, 1},\n\n      {0x01d7, 444, 1},\n\n      {0x1fd7, 31, 3},\n\n      {0x1ea6, 1947, 1},\n\n      {0x04a6, 1127, 1},\n\n      {0x01a6, 676, 1},\n\n      {0x1fa6, 239, 2},\n\n      {0x2ca6, 2643, 1},\n\n      {0x03a6, 810, 1},\n\n      {0xa690, 2958, 1},\n\n      {0xaba6, 1610, 1},\n\n      {0xa7a6, 3144, 1},\n\n      {0x10ca6, 3471, 1},\n\n      {0x1ea4, 1944, 1},\n\n      {0x04a4, 1124, 1},\n\n      {0x01a4, 390, 1},\n\n      {0x1fa4, 229, 2},\n\n      {0x2ca4, 2640, 1},\n\n      {0x03a4, 804, 1},\n\n      {0x10a6, 2763, 1},\n\n      {0xaba4, 1604, 1},\n\n      {0xa7a4, 3141, 1},\n\n      {0x10ca4, 3465, 1},\n\n      {0x1ea0, 1938, 1},\n\n      {0x04a0, 1118, 1},\n\n      {0x01a0, 384, 1},\n\n      {0x1fa0, 209, 2},\n\n      {0x2ca0, 2634, 1},\n\n      {0x03a0, 792, 1},\n\n      {0x10a4, 2757, 1},\n\n      {0xaba0, 1592, 1},\n\n      {0xa7a0, 3135, 1},\n\n      {0x10ca0, 3453, 1},\n\n      {0x1eb2, 1965, 1},\n\n      {0x04b2, 1145, 1},\n\n      {0x01b2, 694, 1},\n\n      {0x1fb2, 249, 2},\n\n      {0x2cb2, 2661, 1},\n\n      {0x03fd, 718, 1},\n\n      {0x10a0, 2745, 1},\n\n      {0xabb2, 1646, 1},\n\n      {0xa7b2, 703, 1},\n\n      {0x10cb2, 3507, 1},\n\n      {0x1eac, 1956, 1},\n\n      {0x04ac, 1136, 1},\n\n      {0x01ac, 396, 1},\n\n      {0x1fac, 229, 2},\n\n      {0x2cac, 2652, 1},\n\n      {0x0537, 1352, 1},\n\n      {0x10b2, 2799, 1},\n\n      {0xabac, 1628, 1},\n\n      {0xa7ac, 637, 1},\n\n      {0x10cac, 3489, 1},\n\n      {0x1eaa, 1953, 1},\n\n      {0x04aa, 1133, 1},\n\n      {0x00dd, 162, 1},\n\n      {0x1faa, 219, 2},\n\n      {0x2caa, 2649, 1},\n\n      {0x03aa, 824, 1},\n\n      {0x10ac, 2781, 1},\n\n      {0xabaa, 1622, 1},\n\n      {0xa7aa, 646, 1},\n\n      {0x10caa, 3483, 1},\n\n      {0x1ea8, 1950, 1},\n\n      {0x04a8, 1130, 1},\n\n      {0x020a, 517, 1},\n\n      {0x1fa8, 209, 2},\n\n      {0x2ca8, 2646, 1},\n\n      {0x03a8, 817, 1},\n\n      {0x10aa, 2775, 1},\n\n      {0xaba8, 1616, 1},\n\n      {0xa7a8, 3147, 1},\n\n      {0x10ca8, 3477, 1},\n\n      {0x1ea2, 1941, 1},\n\n      {0x04a2, 1121, 1},\n\n      {0x01a2, 387, 1},\n\n      {0x1fa2, 219, 2},\n\n      {0x2ca2, 2637, 1},\n\n      {0x118a6, 3528, 1},\n\n      {0x10a8, 2769, 1},\n\n      {0xaba2, 1598, 1},\n\n      {0xa7a2, 3138, 1},\n\n      {0x10ca2, 3459, 1},\n\n      {0x2ced, 2739, 1},\n\n      {0x1fe9, 2283, 1},\n\n      {0x1fe7, 47, 3},\n\n      {0x1eb0, 1962, 1},\n\n      {0x04b0, 1142, 1},\n\n      {0x118a4, 3522, 1},\n\n      {0x10a2, 2751, 1},\n\n      {0x2cb0, 2658, 1},\n\n      {0x03b0, 41, 3},\n\n      {0x1fe3, 41, 3},\n\n      {0xabb0, 1640, 1},\n\n      {0xa7b0, 706, 1},\n\n      {0x10cb0, 3501, 1},\n\n      {0x01d9, 447, 1},\n\n      {0x1fd9, 2277, 1},\n\n      {0x118a0, 3510, 1},\n\n      {0x00df, 24, 2},\n\n      {0x00d9, 150, 1},\n\n      {0xab77, 1469, 1},\n\n      {0x10b0, 2793, 1},\n\n      {0x1eae, 1959, 1},\n\n      {0x04ae, 1139, 1},\n\n      {0x01ae, 685, 1},\n\n      {0x1fae, 239, 2},\n\n      {0x2cae, 2655, 1},\n\n      {0x118b2, 3564, 1},\n\n      {0xab73, 1457, 1},\n\n      {0xabae, 1634, 1},\n\n      {0xab71, 1451, 1},\n\n      {0x10cae, 3495, 1},\n\n      {0x1e2a, 1775, 1},\n\n      {0x042a, 968, 1},\n\n      {0x012a, 234, 1},\n\n      {0x1f2a, 2130, 1},\n\n      {0x2c2a, 2547, 1},\n\n      {0x118ac, 3546, 1},\n\n      {0x10ae, 2787, 1},\n\n      {0x0535, 1346, 1},\n\n      {0xa72a, 2988, 1},\n\n      {0x1e9a, 0, 2},\n\n      {0x049a, 1109, 1},\n\n      {0xff37, 3225, 1},\n\n      {0x1f9a, 179, 2},\n\n      {0x2c9a, 2625, 1},\n\n      {0x039a, 772, 1},\n\n      {0x118aa, 3540, 1},\n\n      {0xab9a, 1574, 1},\n\n      {0xa79a, 3126, 1},\n\n      {0x10c9a, 3435, 1},\n\n      {0x1e94, 1935, 1},\n\n      {0x0494, 1100, 1},\n\n      {0x0194, 640, 1},\n\n      {0x1f94, 189, 2},\n\n      {0x2c94, 2616, 1},\n\n      {0x0394, 749, 1},\n\n      {0x118a8, 3534, 1},\n\n      {0xab94, 1556, 1},\n\n      {0xa69a, 2973, 1},\n\n      {0x10c94, 3417, 1},\n\n      {0x10402, 3243, 1},\n\n      {0x1e02, 1715, 1},\n\n      {0x0402, 992, 1},\n\n      {0x0102, 174, 1},\n\n      {0x0533, 1340, 1},\n\n      {0x2c02, 2427, 1},\n\n      {0x118a2, 3516, 1},\n\n      {0x052a, 1325, 1},\n\n      {0xa694, 2964, 1},\n\n      {0x1e92, 1932, 1},\n\n      {0x0492, 1097, 1},\n\n      {0x2165, 2307, 1},\n\n      {0x1f92, 179, 2},\n\n      {0x2c92, 2613, 1},\n\n      {0x0392, 742, 1},\n\n      {0x2161, 2295, 1},\n\n      {0xab92, 1550, 1},\n\n      {0xa792, 3117, 1},\n\n      {0x10c92, 3411, 1},\n\n      {0x118b0, 3558, 1},\n\n      {0x1f5f, 2199, 1},\n\n      {0x1e8e, 1926, 1},\n\n      {0x048e, 1091, 1},\n\n      {0x018e, 453, 1},\n\n      {0x1f8e, 159, 2},\n\n      {0x2c8e, 2607, 1},\n\n      {0x038e, 833, 1},\n\n      {0xa692, 2961, 1},\n\n      {0xab8e, 1538, 1},\n\n      {0x0055, 59, 1},\n\n      {0x10c8e, 3399, 1},\n\n      {0x1f5d, 2196, 1},\n\n      {0x212a, 27, 1},\n\n      {0x04cb, 1181, 1},\n\n      {0x01cb, 425, 1},\n\n      {0x1fcb, 2241, 1},\n\n      {0x118ae, 3552, 1},\n\n      {0x0502, 1265, 1},\n\n      {0x00cb, 111, 1},\n\n      {0xa68e, 2955, 1},\n\n      {0x1e8a, 1920, 1},\n\n      {0x048a, 1085, 1},\n\n      {0x018a, 622, 1},\n\n      {0x1f8a, 139, 2},\n\n      {0x2c8a, 2601, 1},\n\n      {0x038a, 736, 1},\n\n      {0x2c67, 2571, 1},\n\n      {0xab8a, 1526, 1},\n\n      {0x1e86, 1914, 1},\n\n      {0x10c8a, 3387, 1},\n\n      {0x0186, 616, 1},\n\n      {0x1f86, 159, 2},\n\n      {0x2c86, 2595, 1},\n\n      {0x0386, 727, 1},\n\n      {0xff35, 3219, 1},\n\n      {0xab86, 1514, 1},\n\n      {0xa786, 3108, 1},\n\n      {0x10c86, 3375, 1},\n\n      {0xa68a, 2949, 1},\n\n      {0x0555, 1442, 1},\n\n      {0x1ebc, 1980, 1},\n\n      {0x04bc, 1160, 1},\n\n      {0x01bc, 411, 1},\n\n      {0x1fbc, 62, 2},\n\n      {0x2cbc, 2676, 1},\n\n      {0x1f5b, 2193, 1},\n\n      {0xa686, 2943, 1},\n\n      {0xabbc, 1676, 1},\n\n      {0x1eb8, 1974, 1},\n\n      {0x04b8, 1154, 1},\n\n      {0x01b8, 408, 1},\n\n      {0x1fb8, 2268, 1},\n\n      {0x2cb8, 2670, 1},\n\n      {0x01db, 450, 1},\n\n      {0x1fdb, 2247, 1},\n\n      {0xabb8, 1664, 1},\n\n      {0x10bc, 2829, 1},\n\n      {0x00db, 156, 1},\n\n      {0x1eb6, 1971, 1},\n\n      {0x04b6, 1151, 1},\n\n      {0xff33, 3213, 1},\n\n      {0x1fb6, 58, 2},\n\n      {0x2cb6, 2667, 1},\n\n      {0xff2a, 3186, 1},\n\n      {0x10b8, 2817, 1},\n\n      {0xabb6, 1658, 1},\n\n      {0xa7b6, 3153, 1},\n\n      {0x10426, 3351, 1},\n\n      {0x1e26, 1769, 1},\n\n      {0x0426, 956, 1},\n\n      {0x0126, 228, 1},\n\n      {0x0053, 52, 1},\n\n      {0x2c26, 2535, 1},\n\n      {0x0057, 65, 1},\n\n      {0x10b6, 2811, 1},\n\n      {0x022a, 562, 1},\n\n      {0xa726, 2982, 1},\n\n      {0x1e2e, 1781, 1},\n\n      {0x042e, 980, 1},\n\n      {0x012e, 240, 1},\n\n      {0x1f2e, 2142, 1},\n\n      {0x2c2e, 2559, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2167, 2313, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa72e, 2994, 1},\n\n      {0x1e2c, 1778, 1},\n\n      {0x042c, 974, 1},\n\n      {0x012c, 237, 1},\n\n      {0x1f2c, 2136, 1},\n\n      {0x2c2c, 2553, 1},\n\n      {0x1f6f, 2223, 1},\n\n      {0x2c6f, 604, 1},\n\n      {0xabbf, 1685, 1},\n\n      {0xa72c, 2991, 1},\n\n      {0x1e28, 1772, 1},\n\n      {0x0428, 962, 1},\n\n      {0x0128, 231, 1},\n\n      {0x1f28, 2124, 1},\n\n      {0x2c28, 2541, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0553, 1436, 1},\n\n      {0x10bf, 2838, 1},\n\n      {0xa728, 2985, 1},\n\n      {0x0526, 1319, 1},\n\n      {0x0202, 505, 1},\n\n      {0x1e40, 1808, 1},\n\n      {0x10424, 3345, 1},\n\n      {0x1e24, 1766, 1},\n\n      {0x0424, 950, 1},\n\n      {0x0124, 225, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c24, 2529, 1},\n\n      {0x052e, 1331, 1},\n\n      {0xa740, 3018, 1},\n\n      {0x118bc, 3594, 1},\n\n      {0xa724, 2979, 1},\n\n      {0x1ef2, 2061, 1},\n\n      {0x04f2, 1241, 1},\n\n      {0x01f2, 483, 1},\n\n      {0x1ff2, 257, 2},\n\n      {0x2cf2, 2742, 1},\n\n      {0x052c, 1328, 1},\n\n      {0x118b8, 3582, 1},\n\n      {0xa640, 2865, 1},\n\n      {0x10422, 3339, 1},\n\n      {0x1e22, 1763, 1},\n\n      {0x0422, 944, 1},\n\n      {0x0122, 222, 1},\n\n      {0x2126, 820, 1},\n\n      {0x2c22, 2523, 1},\n\n      {0x0528, 1322, 1},\n\n      {0x01f1, 483, 1},\n\n      {0x118b6, 3576, 1},\n\n      {0xa722, 2976, 1},\n\n      {0x03f1, 796, 1},\n\n      {0x1ebe, 1983, 1},\n\n      {0x04be, 1163, 1},\n\n      {0xfb02, 12, 2},\n\n      {0x1fbe, 767, 1},\n\n      {0x2cbe, 2679, 1},\n\n      {0x01b5, 405, 1},\n\n      {0x0540, 1379, 1},\n\n      {0xabbe, 1682, 1},\n\n      {0x0524, 1316, 1},\n\n      {0x00b5, 779, 1},\n\n      {0xabb5, 1655, 1},\n\n      {0x1eba, 1977, 1},\n\n      {0x04ba, 1157, 1},\n\n      {0x216f, 2337, 1},\n\n      {0x1fba, 2226, 1},\n\n      {0x2cba, 2673, 1},\n\n      {0x10be, 2835, 1},\n\n      {0x0051, 46, 1},\n\n      {0xabba, 1670, 1},\n\n      {0x10b5, 2808, 1},\n\n      {0x1e6e, 1878, 1},\n\n      {0x046e, 1055, 1},\n\n      {0x016e, 330, 1},\n\n      {0x1f6e, 2220, 1},\n\n      {0x2c6e, 664, 1},\n\n      {0x118bf, 3603, 1},\n\n      {0x0522, 1313, 1},\n\n      {0x10ba, 2823, 1},\n\n      {0xa76e, 3087, 1},\n\n      {0x1eb4, 1968, 1},\n\n      {0x04b4, 1148, 1},\n\n      {0x2c75, 2583, 1},\n\n      {0x1fb4, 50, 2},\n\n      {0x2cb4, 2664, 1},\n\n      {0xab75, 1463, 1},\n\n      {0x1ec2, 1989, 1},\n\n      {0xabb4, 1652, 1},\n\n      {0xa7b4, 3150, 1},\n\n      {0x1fc2, 253, 2},\n\n      {0x2cc2, 2685, 1},\n\n      {0x03c2, 800, 1},\n\n      {0x00c2, 83, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff26, 3174, 1},\n\n      {0x10b4, 2805, 1},\n\n      {0x1eca, 2001, 1},\n\n      {0x0551, 1430, 1},\n\n      {0x01ca, 425, 1},\n\n      {0x1fca, 2238, 1},\n\n      {0x2cca, 2697, 1},\n\n      {0x10c2, 2847, 1},\n\n      {0x00ca, 108, 1},\n\n      {0xff2e, 3198, 1},\n\n      {0x1e8c, 1923, 1},\n\n      {0x048c, 1088, 1},\n\n      {0x0226, 556, 1},\n\n      {0x1f8c, 149, 2},\n\n      {0x2c8c, 2604, 1},\n\n      {0x038c, 830, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab8c, 1532, 1},\n\n      {0xff2c, 3192, 1},\n\n      {0x10c8c, 3393, 1},\n\n      {0x1ec4, 1992, 1},\n\n      {0x022e, 568, 1},\n\n      {0x01c4, 417, 1},\n\n      {0x1fc4, 54, 2},\n\n      {0x2cc4, 2688, 1},\n      {0xffffffff, -1, 0},\n\n      {0x00c4, 89, 1},\n\n      {0xff28, 3180, 1},\n\n      {0xa68c, 2952, 1},\n\n      {0x01cf, 432, 1},\n\n      {0x022c, 565, 1},\n\n      {0x118be, 3600, 1},\n\n      {0x03cf, 839, 1},\n\n      {0x00cf, 123, 1},\n\n      {0x118b5, 3573, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c4, 2853, 1},\n\n      {0x216e, 2334, 1},\n\n      {0x24cb, 2406, 1},\n\n      {0x0228, 559, 1},\n\n      {0xff24, 3168, 1},\n      {0xffffffff, -1, 0},\n\n      {0x118ba, 3588, 1},\n\n      {0x1efe, 2079, 1},\n\n      {0x04fe, 1259, 1},\n\n      {0x01fe, 499, 1},\n\n      {0x1e9e, 24, 2},\n\n      {0x049e, 1115, 1},\n\n      {0x03fe, 721, 1},\n\n      {0x1f9e, 199, 2},\n\n      {0x2c9e, 2631, 1},\n\n      {0x039e, 786, 1},\n\n      {0x0224, 553, 1},\n\n      {0xab9e, 1586, 1},\n\n      {0xa79e, 3132, 1},\n\n      {0x10c9e, 3447, 1},\n\n      {0x01f7, 414, 1},\n\n      {0x1ff7, 67, 3},\n\n      {0xff22, 3162, 1},\n\n      {0x03f7, 884, 1},\n\n      {0x118b4, 3570, 1},\n\n      {0x049c, 1112, 1},\n\n      {0x019c, 661, 1},\n\n      {0x1f9c, 189, 2},\n\n      {0x2c9c, 2628, 1},\n\n      {0x039c, 779, 1},\n\n      {0x24bc, 2361, 1},\n\n      {0xab9c, 1580, 1},\n\n      {0xa79c, 3129, 1},\n\n      {0x10c9c, 3441, 1},\n\n      {0x0222, 550, 1},\n\n      {0x1e7c, 1899, 1},\n\n      {0x047c, 1076, 1},\n\n      {0x1e82, 1908, 1},\n\n      {0x24b8, 2349, 1},\n\n      {0x0182, 357, 1},\n\n      {0x1f82, 139, 2},\n\n      {0x2c82, 2589, 1},\n\n      {0xab7c, 1484, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab82, 1502, 1},\n\n      {0xa782, 3102, 1},\n\n      {0x10c82, 3363, 1},\n\n      {0x2c63, 1709, 1},\n\n      {0x24b6, 2343, 1},\n\n      {0x1e80, 1905, 1},\n\n      {0x0480, 1082, 1},\n\n      {0x1f59, 2190, 1},\n\n      {0x1f80, 129, 2},\n\n      {0x2c80, 2586, 1},\n\n      {0x0059, 71, 1},\n\n      {0xa682, 2937, 1},\n\n      {0xab80, 1496, 1},\n\n      {0xa780, 3099, 1},\n\n      {0x10c80, 3357, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1e4c, 1826, 1},\n\n      {0x0145, 270, 1},\n\n      {0x014c, 279, 1},\n\n      {0x1f4c, 2184, 1},\n\n      {0x0345, 767, 1},\n\n      {0x0045, 12, 1},\n\n      {0x004c, 31, 1},\n\n      {0xa680, 2934, 1},\n\n      {0xa74c, 3036, 1},\n\n      {0x1e4a, 1823, 1},\n\n      {0x01d5, 441, 1},\n\n      {0x014a, 276, 1},\n\n      {0x1f4a, 2178, 1},\n\n      {0x03d5, 810, 1},\n\n      {0x00d5, 141, 1},\n\n      {0x004a, 24, 1},\n\n      {0x24bf, 2370, 1},\n\n      {0xa74a, 3033, 1},\n\n      {0xa64c, 2883, 1},\n\n      {0x1041c, 3321, 1},\n\n      {0x1e1c, 1754, 1},\n\n      {0x041c, 926, 1},\n\n      {0x011c, 213, 1},\n\n      {0x1f1c, 2118, 1},\n\n      {0x2c1c, 2505, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xa64a, 2880, 1},\n\n      {0x1041a, 3315, 1},\n\n      {0x1e1a, 1751, 1},\n\n      {0x041a, 920, 1},\n\n      {0x011a, 210, 1},\n\n      {0x1f1a, 2112, 1},\n\n      {0x2c1a, 2499, 1},\n\n      {0xabbd, 1679, 1},\n\n      {0x0545, 1394, 1},\n\n      {0x054c, 1415, 1},\n\n      {0x10418, 3309, 1},\n\n      {0x1e18, 1748, 1},\n\n      {0x0418, 914, 1},\n\n      {0x0118, 207, 1},\n\n      {0x1f18, 2106, 1},\n\n      {0x2c18, 2493, 1},\n\n      {0x10bd, 2832, 1},\n\n      {0x2163, 2301, 1},\n\n      {0x054a, 1409, 1},\n\n      {0x1040e, 3279, 1},\n\n      {0x1e0e, 1733, 1},\n\n      {0x040e, 1028, 1},\n\n      {0x010e, 192, 1},\n\n      {0x1f0e, 2100, 1},\n\n      {0x2c0e, 2463, 1},\n\n      {0x1efc, 2076, 1},\n\n      {0x04fc, 1256, 1},\n\n      {0x01fc, 496, 1},\n\n      {0x1ffc, 96, 2},\n\n      {0x051c, 1304, 1},\n\n      {0x1040c, 3273, 1},\n\n      {0x1e0c, 1730, 1},\n\n      {0x040c, 1022, 1},\n\n      {0x010c, 189, 1},\n\n      {0x1f0c, 2094, 1},\n\n      {0x2c0c, 2457, 1},\n\n      {0x1f6d, 2217, 1},\n\n      {0x2c6d, 607, 1},\n\n      {0x051a, 1301, 1},\n\n      {0x24be, 2367, 1},\n\n      {0x10408, 3261, 1},\n\n      {0x1e08, 1724, 1},\n\n      {0x0408, 1010, 1},\n\n      {0x0108, 183, 1},\n\n      {0x1f08, 2082, 1},\n\n      {0x2c08, 2445, 1},\n\n      {0x04c9, 1178, 1},\n\n      {0x0518, 1298, 1},\n\n      {0x1fc9, 2235, 1},\n      {0xffffffff, -1, 0},\n\n      {0x24ba, 2355, 1},\n\n      {0x00c9, 105, 1},\n\n      {0x10416, 3303, 1},\n\n      {0x1e16, 1745, 1},\n\n      {0x0416, 908, 1},\n\n      {0x0116, 204, 1},\n\n      {0x050e, 1283, 1},\n\n      {0x2c16, 2487, 1},\n\n      {0x10414, 3297, 1},\n\n      {0x1e14, 1742, 1},\n\n      {0x0414, 902, 1},\n\n      {0x0114, 201, 1},\n\n      {0x042b, 971, 1},\n\n      {0x2c14, 2481, 1},\n\n      {0x1f2b, 2133, 1},\n\n      {0x2c2b, 2550, 1},\n      {0xffffffff, -1, 0},\n\n      {0x050c, 1280, 1},\n\n      {0x10406, 3255, 1},\n\n      {0x1e06, 1721, 1},\n\n      {0x0406, 1004, 1},\n\n      {0x0106, 180, 1},\n\n      {0x13fb, 1697, 1},\n\n      {0x2c06, 2439, 1},\n\n      {0x24c2, 2379, 1},\n\n      {0x118bd, 3597, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0508, 1274, 1},\n\n      {0x10404, 3249, 1},\n\n      {0x1e04, 1718, 1},\n\n      {0x0404, 998, 1},\n\n      {0x0104, 177, 1},\n\n      {0x1f95, 194, 2},\n\n      {0x2c04, 2433, 1},\n\n      {0x0395, 752, 1},\n\n      {0x24ca, 2403, 1},\n\n      {0xab95, 1559, 1},\n\n      {0x0531, 1334, 1},\n\n      {0x10c95, 3420, 1},\n\n      {0x0516, 1295, 1},\n\n      {0x1e6c, 1875, 1},\n\n      {0x046c, 1052, 1},\n\n      {0x016c, 327, 1},\n\n      {0x1f6c, 2214, 1},\n\n      {0x216d, 2331, 1},\n\n      {0x0514, 1292, 1},\n\n      {0x0245, 697, 1},\n\n      {0x024c, 598, 1},\n\n      {0xa76c, 3084, 1},\n\n      {0x10400, 3237, 1},\n\n      {0x1e00, 1712, 1},\n\n      {0x0400, 986, 1},\n\n      {0x0100, 171, 1},\n\n      {0x24c4, 2385, 1},\n\n      {0x2c00, 2421, 1},\n\n      {0x0506, 1271, 1},\n\n      {0x024a, 595, 1},\n\n      {0x1fab, 224, 2},\n\n      {0xa66c, 2931, 1},\n\n      {0x03ab, 827, 1},\n\n      {0x24cf, 2418, 1},\n\n      {0xabab, 1625, 1},\n\n      {0xa7ab, 631, 1},\n\n      {0x10cab, 3486, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0504, 1268, 1},\n      {0xffffffff, -1, 0},\n\n      {0x021c, 544, 1},\n\n      {0x01a9, 679, 1},\n\n      {0x1fa9, 214, 2},\n\n      {0x10ab, 2778, 1},\n\n      {0x03a9, 820, 1},\n\n      {0x212b, 92, 1},\n\n      {0xaba9, 1619, 1},\n\n      {0x1e88, 1917, 1},\n\n      {0x10ca9, 3480, 1},\n\n      {0x021a, 541, 1},\n\n      {0x1f88, 129, 2},\n\n      {0x2c88, 2598, 1},\n\n      {0x0388, 730, 1},\n\n      {0x13fd, 1703, 1},\n\n      {0xab88, 1520, 1},\n\n      {0x10a9, 2772, 1},\n\n      {0x10c88, 3381, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0218, 538, 1},\n\n      {0x0500, 1262, 1},\n\n      {0x1f4d, 2187, 1},\n\n      {0x01a7, 393, 1},\n\n      {0x1fa7, 244, 2},\n\n      {0x004d, 34, 1},\n\n      {0x03a7, 814, 1},\n\n      {0xa688, 2946, 1},\n\n      {0xaba7, 1613, 1},\n\n      {0x020e, 523, 1},\n\n      {0x10ca7, 3474, 1},\n\n      {0x1e6a, 1872, 1},\n\n      {0x046a, 1049, 1},\n\n      {0x016a, 324, 1},\n\n      {0x1f6a, 2208, 1},\n      {0xffffffff, -1, 0},\n\n      {0x216c, 2328, 1},\n\n      {0x10a7, 2766, 1},\n\n      {0x01d1, 435, 1},\n\n      {0xa76a, 3081, 1},\n\n      {0x020c, 520, 1},\n\n      {0x03d1, 762, 1},\n\n      {0x00d1, 129, 1},\n\n      {0x1e68, 1869, 1},\n\n      {0x0468, 1046, 1},\n\n      {0x0168, 321, 1},\n\n      {0x1f68, 2202, 1},\n      {0xffffffff, -1, 0},\n\n      {0xff31, 3207, 1},\n\n      {0xa66a, 2928, 1},\n\n      {0x0208, 514, 1},\n\n      {0xa768, 3078, 1},\n\n      {0x1e64, 1863, 1},\n\n      {0x0464, 1040, 1},\n\n      {0x0164, 315, 1},\n\n      {0x054d, 1418, 1},\n\n      {0x2c64, 673, 1},\n      {0xffffffff, -1, 0},\n\n      {0xff2b, 3189, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa764, 3072, 1},\n\n      {0xa668, 2925, 1},\n\n      {0x0216, 535, 1},\n      {0xffffffff, -1, 0},\n\n      {0x118ab, 3543, 1},\n\n      {0x1e62, 1860, 1},\n\n      {0x0462, 1037, 1},\n\n      {0x0162, 312, 1},\n\n      {0x0214, 532, 1},\n\n      {0x2c62, 655, 1},\n\n      {0xa664, 2919, 1},\n\n      {0x1ed2, 2013, 1},\n\n      {0x04d2, 1193, 1},\n\n      {0xa762, 3069, 1},\n\n      {0x1fd2, 20, 3},\n\n      {0x2cd2, 2709, 1},\n\n      {0x118a9, 3537, 1},\n\n      {0x00d2, 132, 1},\n\n      {0x0206, 511, 1},\n\n      {0x10420, 3333, 1},\n\n      {0x1e20, 1760, 1},\n\n      {0x0420, 938, 1},\n\n      {0x0120, 219, 1},\n\n      {0xa662, 2916, 1},\n\n      {0x2c20, 2517, 1},\n\n      {0x1e60, 1856, 1},\n\n      {0x0460, 1034, 1},\n\n      {0x0160, 309, 1},\n\n      {0x0204, 508, 1},\n\n      {0x2c60, 2562, 1},\n      {0xffffffff, -1, 0},\n\n      {0x24bd, 2364, 1},\n\n      {0x216a, 2322, 1},\n\n      {0xa760, 3066, 1},\n      {0xffffffff, -1, 0},\n\n      {0xfb16, 125, 2},\n\n      {0x118a7, 3531, 1},\n\n      {0x1efa, 2073, 1},\n\n      {0x04fa, 1253, 1},\n\n      {0x01fa, 493, 1},\n\n      {0x1ffa, 2262, 1},\n\n      {0xfb14, 109, 2},\n\n      {0x03fa, 887, 1},\n\n      {0xa660, 2913, 1},\n\n      {0x2168, 2316, 1},\n\n      {0x01b7, 700, 1},\n\n      {0x1fb7, 10, 3},\n\n      {0x1f6b, 2211, 1},\n\n      {0x2c6b, 2577, 1},\n\n      {0x0200, 502, 1},\n\n      {0xabb7, 1661, 1},\n\n      {0xfb06, 29, 2},\n\n      {0x1e56, 1841, 1},\n\n      {0x2164, 2304, 1},\n\n      {0x0156, 294, 1},\n\n      {0x1f56, 62, 3},\n\n      {0x0520, 1310, 1},\n\n      {0x004f, 40, 1},\n\n      {0x0056, 62, 1},\n\n      {0x10b7, 2814, 1},\n\n      {0xa756, 3051, 1},\n\n      {0xfb04, 5, 3},\n\n      {0x1e78, 1893, 1},\n\n      {0x0478, 1070, 1},\n\n      {0x0178, 168, 1},\n\n      {0x1e54, 1838, 1},\n\n      {0x2162, 2298, 1},\n\n      {0x0154, 291, 1},\n\n      {0x1f54, 57, 3},\n\n      {0xab78, 1472, 1},\n\n      {0xa656, 2898, 1},\n\n      {0x0054, 56, 1},\n\n      {0x1e52, 1835, 1},\n\n      {0xa754, 3048, 1},\n\n      {0x0152, 288, 1},\n\n      {0x1f52, 52, 3},\n\n      {0x24c9, 2400, 1},\n\n      {0x1e32, 1787, 1},\n\n      {0x0052, 49, 1},\n\n      {0x0132, 243, 1},\n\n      {0xa752, 3045, 1},\n      {0xffffffff, -1, 0},\n\n      {0xfb00, 4, 2},\n\n      {0xa654, 2895, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa732, 2997, 1},\n\n      {0x2160, 2292, 1},\n\n      {0x054f, 1424, 1},\n\n      {0x0556, 1445, 1},\n\n      {0x1e50, 1832, 1},\n\n      {0xa652, 2892, 1},\n\n      {0x0150, 285, 1},\n\n      {0x1f50, 84, 2},\n\n      {0x017b, 348, 1},\n\n      {0x1e4e, 1829, 1},\n\n      {0x0050, 43, 1},\n\n      {0x014e, 282, 1},\n\n      {0xa750, 3042, 1},\n\n      {0xab7b, 1481, 1},\n\n      {0xa77b, 3093, 1},\n\n      {0x004e, 37, 1},\n\n      {0x0554, 1439, 1},\n\n      {0xa74e, 3039, 1},\n\n      {0x1e48, 1820, 1},\n      {0xffffffff, -1, 0},\n\n      {0x216b, 2325, 1},\n\n      {0x1f48, 2172, 1},\n\n      {0xa650, 2889, 1},\n\n      {0x0552, 1433, 1},\n\n      {0x0048, 21, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa748, 3030, 1},\n\n      {0xa64e, 2886, 1},\n\n      {0x0532, 1337, 1},\n\n      {0x1041e, 3327, 1},\n\n      {0x1e1e, 1757, 1},\n\n      {0x041e, 932, 1},\n\n      {0x011e, 216, 1},\n\n      {0x118b7, 3579, 1},\n\n      {0x2c1e, 2511, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa648, 2877, 1},\n\n      {0x1ff9, 2253, 1},\n      {0xffffffff, -1, 0},\n\n      {0x03f9, 878, 1},\n\n      {0x0550, 1427, 1},\n\n      {0x10412, 3291, 1},\n\n      {0x1e12, 1739, 1},\n\n      {0x0412, 896, 1},\n\n      {0x0112, 198, 1},\n\n      {0x054e, 1421, 1},\n\n      {0x2c12, 2475, 1},\n\n      {0x10410, 3285, 1},\n\n      {0x1e10, 1736, 1},\n\n      {0x0410, 890, 1},\n\n      {0x0110, 195, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c10, 2469, 1},\n\n      {0x2132, 2289, 1},\n\n      {0x0548, 1403, 1},\n\n      {0x1ef8, 2070, 1},\n\n      {0x04f8, 1250, 1},\n\n      {0x01f8, 490, 1},\n\n      {0x1ff8, 2250, 1},\n\n      {0x0220, 381, 1},\n\n      {0x1ee2, 2037, 1},\n\n      {0x04e2, 1217, 1},\n\n      {0x01e2, 462, 1},\n\n      {0x1fe2, 36, 3},\n\n      {0x2ce2, 2733, 1},\n\n      {0x03e2, 857, 1},\n\n      {0x051e, 1307, 1},\n\n      {0x1ede, 2031, 1},\n\n      {0x04de, 1211, 1},\n\n      {0x01de, 456, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2cde, 2727, 1},\n\n      {0x03de, 851, 1},\n\n      {0x00de, 165, 1},\n\n      {0x1f69, 2205, 1},\n\n      {0x2c69, 2574, 1},\n\n      {0x1eda, 2025, 1},\n\n      {0x04da, 1205, 1},\n\n      {0x0512, 1289, 1},\n\n      {0x1fda, 2244, 1},\n\n      {0x2cda, 2721, 1},\n\n      {0x03da, 845, 1},\n\n      {0x00da, 153, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0510, 1286, 1},\n\n      {0x1ed8, 2022, 1},\n\n      {0x04d8, 1202, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fd8, 2274, 1},\n\n      {0x2cd8, 2718, 1},\n\n      {0x03d8, 842, 1},\n\n      {0x00d8, 147, 1},\n\n      {0x1ed6, 2019, 1},\n\n      {0x04d6, 1199, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fd6, 76, 2},\n\n      {0x2cd6, 2715, 1},\n\n      {0x03d6, 792, 1},\n\n      {0x00d6, 144, 1},\n\n      {0x1ec8, 1998, 1},\n      {0xffffffff, -1, 0},\n\n      {0x01c8, 421, 1},\n\n      {0x1fc8, 2232, 1},\n\n      {0x2cc8, 2694, 1},\n\n      {0xff32, 3210, 1},\n\n      {0x00c8, 102, 1},\n\n      {0x04c7, 1175, 1},\n\n      {0x01c7, 421, 1},\n\n      {0x1fc7, 15, 3},\n\n      {0x1ec0, 1986, 1},\n\n      {0x04c0, 1187, 1},\n\n      {0x00c7, 99, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2cc0, 2682, 1},\n\n      {0x0179, 345, 1},\n\n      {0x00c0, 77, 1},\n\n      {0x0232, 574, 1},\n\n      {0x01b3, 402, 1},\n\n      {0x1fb3, 62, 2},\n\n      {0xab79, 1475, 1},\n\n      {0xa779, 3090, 1},\n\n      {0x10c7, 2859, 1},\n\n      {0xabb3, 1649, 1},\n\n      {0xa7b3, 3156, 1},\n\n      {0x1fa5, 234, 2},\n\n      {0x10c0, 2841, 1},\n\n      {0x03a5, 807, 1},\n      {0xffffffff, -1, 0},\n\n      {0xaba5, 1607, 1},\n\n      {0x01b1, 691, 1},\n\n      {0x10ca5, 3468, 1},\n\n      {0x10b3, 2802, 1},\n\n      {0x2169, 2319, 1},\n\n      {0x024e, 601, 1},\n\n      {0xabb1, 1643, 1},\n\n      {0xa7b1, 682, 1},\n\n      {0x10cb1, 3504, 1},\n\n      {0x10a5, 2760, 1},\n      {0xffffffff, -1, 0},\n\n      {0x01af, 399, 1},\n\n      {0x1faf, 244, 2},\n      {0xffffffff, -1, 0},\n\n      {0x0248, 592, 1},\n\n      {0x10b1, 2796, 1},\n\n      {0xabaf, 1637, 1},\n\n      {0x1fad, 234, 2},\n\n      {0x10caf, 3498, 1},\n\n      {0x04cd, 1184, 1},\n\n      {0x01cd, 429, 1},\n\n      {0xabad, 1631, 1},\n\n      {0xa7ad, 658, 1},\n\n      {0x10cad, 3492, 1},\n\n      {0x00cd, 117, 1},\n\n      {0x10af, 2790, 1},\n\n      {0x021e, 547, 1},\n\n      {0x1fa3, 224, 2},\n      {0xffffffff, -1, 0},\n\n      {0x03a3, 800, 1},\n\n      {0x10ad, 2784, 1},\n\n      {0xaba3, 1601, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10ca3, 3462, 1},\n\n      {0x10cd, 2862, 1},\n\n      {0x1fa1, 214, 2},\n\n      {0x24b7, 2346, 1},\n\n      {0x03a1, 796, 1},\n\n      {0x0212, 529, 1},\n\n      {0xaba1, 1595, 1},\n\n      {0x10a3, 2754, 1},\n\n      {0x10ca1, 3456, 1},\n\n      {0x01d3, 438, 1},\n\n      {0x1fd3, 25, 3},\n\n      {0x0210, 526, 1},\n      {0xffffffff, -1, 0},\n\n      {0x00d3, 135, 1},\n\n      {0x1e97, 34, 2},\n\n      {0x10a1, 2748, 1},\n\n      {0x0197, 649, 1},\n\n      {0x1f97, 204, 2},\n      {0xffffffff, -1, 0},\n\n      {0x0397, 759, 1},\n\n      {0x1041d, 3324, 1},\n\n      {0xab97, 1565, 1},\n\n      {0x041d, 929, 1},\n\n      {0x10c97, 3426, 1},\n\n      {0x1f1d, 2121, 1},\n\n      {0x2c1d, 2508, 1},\n\n      {0x1e72, 1884, 1},\n\n      {0x0472, 1061, 1},\n\n      {0x0172, 336, 1},\n\n      {0x118b3, 3567, 1},\n\n      {0x2c72, 2580, 1},\n\n      {0x0372, 712, 1},\n\n      {0x1041b, 3318, 1},\n\n      {0xab72, 1454, 1},\n\n      {0x041b, 923, 1},\n\n      {0x118a5, 3525, 1},\n\n      {0x1f1b, 2115, 1},\n\n      {0x2c1b, 2502, 1},\n\n      {0x1e70, 1881, 1},\n\n      {0x0470, 1058, 1},\n\n      {0x0170, 333, 1},\n\n      {0x118b1, 3561, 1},\n\n      {0x2c70, 610, 1},\n\n      {0x0370, 709, 1},\n\n      {0x1e46, 1817, 1},\n\n      {0xab70, 1448, 1},\n\n      {0x1e66, 1866, 1},\n\n      {0x0466, 1043, 1},\n\n      {0x0166, 318, 1},\n\n      {0x1e44, 1814, 1},\n\n      {0x0046, 15, 1},\n\n      {0x118af, 3555, 1},\n\n      {0xa746, 3027, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa766, 3075, 1},\n\n      {0x0044, 9, 1},\n\n      {0x118ad, 3549, 1},\n\n      {0xa744, 3024, 1},\n\n      {0x1e7a, 1896, 1},\n\n      {0x047a, 1073, 1},\n\n      {0x1e3a, 1799, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa646, 2874, 1},\n\n      {0x1f3a, 2154, 1},\n\n      {0xa666, 2922, 1},\n\n      {0xab7a, 1478, 1},\n\n      {0x118a3, 3519, 1},\n\n      {0xa644, 2871, 1},\n\n      {0xa73a, 3009, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1ef4, 2064, 1},\n\n      {0x04f4, 1244, 1},\n\n      {0x01f4, 487, 1},\n\n      {0x1ff4, 101, 2},\n\n      {0x118a1, 3513, 1},\n\n      {0x03f4, 762, 1},\n\n      {0x1eec, 2052, 1},\n\n      {0x04ec, 1232, 1},\n\n      {0x01ec, 477, 1},\n\n      {0x1fec, 2286, 1},\n\n      {0x0546, 1397, 1},\n\n      {0x03ec, 872, 1},\n      {0xffffffff, -1, 0},\n\n      {0x013f, 261, 1},\n\n      {0x1f3f, 2169, 1},\n\n      {0x0544, 1391, 1},\n\n      {0x1eea, 2049, 1},\n\n      {0x04ea, 1229, 1},\n\n      {0x01ea, 474, 1},\n\n      {0x1fea, 2256, 1},\n      {0xffffffff, -1, 0},\n\n      {0x03ea, 869, 1},\n\n      {0x1ee8, 2046, 1},\n\n      {0x04e8, 1226, 1},\n\n      {0x01e8, 471, 1},\n\n      {0x1fe8, 2280, 1},\n\n      {0x053a, 1361, 1},\n\n      {0x03e8, 866, 1},\n\n      {0x1ee6, 2043, 1},\n\n      {0x04e6, 1223, 1},\n\n      {0x01e6, 468, 1},\n\n      {0x1fe6, 88, 2},\n\n      {0x1f4b, 2181, 1},\n\n      {0x03e6, 863, 1},\n\n      {0x1e5e, 1853, 1},\n\n      {0x004b, 27, 1},\n\n      {0x015e, 306, 1},\n\n      {0x2166, 2310, 1},\n\n      {0x1ee4, 2040, 1},\n\n      {0x04e4, 1220, 1},\n\n      {0x01e4, 465, 1},\n\n      {0x1fe4, 80, 2},\n\n      {0xa75e, 3063, 1},\n\n      {0x03e4, 860, 1},\n\n      {0x1ee0, 2034, 1},\n\n      {0x04e0, 1214, 1},\n\n      {0x01e0, 459, 1},\n\n      {0x053f, 1376, 1},\n\n      {0x2ce0, 2730, 1},\n\n      {0x03e0, 854, 1},\n\n      {0x1edc, 2028, 1},\n\n      {0x04dc, 1208, 1},\n\n      {0xa65e, 2910, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2cdc, 2724, 1},\n\n      {0x03dc, 848, 1},\n\n      {0x00dc, 159, 1},\n\n      {0x1ed0, 2010, 1},\n\n      {0x04d0, 1190, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0x2cd0, 2706, 1},\n\n      {0x03d0, 742, 1},\n\n      {0x00d0, 126, 1},\n\n      {0x1ecc, 2004, 1},\n\n      {0x054b, 1412, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fcc, 71, 2},\n\n      {0x2ccc, 2700, 1},\n\n      {0x1ec6, 1995, 1},\n\n      {0x00cc, 114, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fc6, 67, 2},\n\n      {0x2cc6, 2691, 1},\n\n      {0x24c8, 2397, 1},\n\n      {0x00c6, 96, 1},\n\n      {0x04c5, 1172, 1},\n\n      {0x01c5, 417, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fbb, 2229, 1},\n\n      {0x24c7, 2394, 1},\n\n      {0x00c5, 92, 1},\n\n      {0x1fb9, 2271, 1},\n\n      {0xabbb, 1673, 1},\n\n      {0x24c0, 2373, 1},\n\n      {0x04c3, 1169, 1},\n\n      {0xabb9, 1667, 1},\n\n      {0x1fc3, 71, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0x00c3, 86, 1},\n\n      {0x10c5, 2856, 1},\n\n      {0x10bb, 2826, 1},\n\n      {0x1ed4, 2016, 1},\n\n      {0x04d4, 1196, 1},\n\n      {0x10b9, 2820, 1},\n\n      {0x13fc, 1700, 1},\n\n      {0x2cd4, 2712, 1},\n\n      {0x0246, 589, 1},\n\n      {0x00d4, 138, 1},\n\n      {0x10c3, 2850, 1},\n      {0xffffffff, -1, 0},\n\n      {0xff3a, 3234, 1},\n\n      {0x0244, 688, 1},\n\n      {0x019f, 670, 1},\n\n      {0x1f9f, 204, 2},\n      {0xffffffff, -1, 0},\n\n      {0x039f, 789, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab9f, 1589, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c9f, 3450, 1},\n\n      {0x019d, 667, 1},\n\n      {0x1f9d, 194, 2},\n\n      {0x023a, 2565, 1},\n\n      {0x039d, 783, 1},\n\n      {0x1e5a, 1847, 1},\n\n      {0xab9d, 1583, 1},\n\n      {0x015a, 300, 1},\n\n      {0x10c9d, 3444, 1},\n\n      {0x1e9b, 1856, 1},\n\n      {0x24cd, 2412, 1},\n\n      {0x005a, 74, 1},\n\n      {0x1f9b, 184, 2},\n\n      {0xa75a, 3057, 1},\n\n      {0x039b, 776, 1},\n\n      {0x1ece, 2007, 1},\n\n      {0xab9b, 1577, 1},\n\n      {0x1e99, 42, 2},\n\n      {0x10c9b, 3438, 1},\n\n      {0x2cce, 2703, 1},\n\n      {0x1f99, 174, 2},\n\n      {0x00ce, 120, 1},\n\n      {0x0399, 767, 1},\n\n      {0xa65a, 2904, 1},\n\n      {0xab99, 1571, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c99, 3432, 1},\n\n      {0x0193, 634, 1},\n\n      {0x1f93, 184, 2},\n\n      {0x1e58, 1844, 1},\n\n      {0x0393, 746, 1},\n\n      {0x0158, 297, 1},\n\n      {0xab93, 1553, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c93, 3414, 1},\n\n      {0x0058, 68, 1},\n\n      {0x042d, 977, 1},\n\n      {0xa758, 3054, 1},\n\n      {0x1f2d, 2139, 1},\n\n      {0x2c2d, 2556, 1},\n\n      {0x118bb, 3591, 1},\n\n      {0x0191, 369, 1},\n\n      {0x1f91, 174, 2},\n\n      {0x118b9, 3585, 1},\n\n      {0x0391, 739, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab91, 1547, 1},\n\n      {0xa658, 2901, 1},\n\n      {0x10c91, 3408, 1},\n\n      {0x018f, 625, 1},\n\n      {0x1f8f, 164, 2},\n      {0xffffffff, -1, 0},\n\n      {0x038f, 836, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab8f, 1541, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c8f, 3402, 1},\n\n      {0x018b, 366, 1},\n\n      {0x1f8b, 144, 2},\n      {0xffffffff, -1, 0},\n\n      {0x0187, 363, 1},\n\n      {0x1f87, 164, 2},\n\n      {0xab8b, 1529, 1},\n\n      {0xa78b, 3111, 1},\n\n      {0x10c8b, 3390, 1},\n\n      {0xab87, 1517, 1},\n\n      {0x04c1, 1166, 1},\n\n      {0x10c87, 3378, 1},\n\n      {0x1e7e, 1902, 1},\n\n      {0x047e, 1079, 1},\n      {0xffffffff, -1, 0},\n\n      {0x00c1, 80, 1},\n\n      {0x2c7e, 580, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xab7e, 1490, 1},\n\n      {0xa77e, 3096, 1},\n\n      {0x1e76, 1890, 1},\n\n      {0x0476, 1067, 1},\n\n      {0x0176, 342, 1},\n\n      {0x1e42, 1811, 1},\n\n      {0x10c1, 2844, 1},\n\n      {0x0376, 715, 1},\n\n      {0x1e36, 1793, 1},\n\n      {0xab76, 1466, 1},\n\n      {0x0136, 249, 1},\n\n      {0x0042, 3, 1},\n\n      {0x1e3e, 1805, 1},\n\n      {0xa742, 3021, 1},\n\n      {0x1e38, 1796, 1},\n\n      {0x1f3e, 2166, 1},\n\n      {0xa736, 3003, 1},\n\n      {0x1f38, 2148, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0587, 105, 2},\n\n      {0xa73e, 3015, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa738, 3006, 1},\n\n      {0xa642, 2868, 1},\n\n      {0x1e5c, 1850, 1},\n\n      {0x1e34, 1790, 1},\n\n      {0x015c, 303, 1},\n\n      {0x0134, 246, 1},\n\n      {0x1ef6, 2067, 1},\n\n      {0x04f6, 1247, 1},\n\n      {0x01f6, 372, 1},\n\n      {0x1ff6, 92, 2},\n\n      {0xa75c, 3060, 1},\n\n      {0xa734, 3000, 1},\n\n      {0x1ef0, 2058, 1},\n\n      {0x04f0, 1238, 1},\n\n      {0x01f0, 20, 2},\n      {0xffffffff, -1, 0},\n\n      {0x1e30, 1784, 1},\n\n      {0x03f0, 772, 1},\n\n      {0x0130, 261, 2},\n\n      {0x0542, 1385, 1},\n\n      {0xa65c, 2907, 1},\n\n      {0x1f83, 144, 2},\n\n      {0x0536, 1349, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xab83, 1505, 1},\n\n      {0x053e, 1373, 1},\n\n      {0x10c83, 3366, 1},\n\n      {0x0538, 1355, 1},\n\n      {0x1eee, 2055, 1},\n\n      {0x04ee, 1235, 1},\n\n      {0x01ee, 480, 1},\n\n      {0x1f8d, 154, 2},\n      {0xffffffff, -1, 0},\n\n      {0x03ee, 875, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab8d, 1535, 1},\n\n      {0xa78d, 643, 1},\n\n      {0x10c8d, 3396, 1},\n\n      {0x0534, 1343, 1},\n\n      {0x0181, 613, 1},\n\n      {0x1f81, 134, 2},\n\n      {0x013d, 258, 1},\n\n      {0x1f3d, 2163, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab81, 1499, 1},\n\n      {0x017f, 52, 1},\n\n      {0x10c81, 3360, 1},\n\n      {0x2c7f, 583, 1},\n\n      {0x037f, 881, 1},\n\n      {0xff2d, 3195, 1},\n\n      {0xab7f, 1493, 1},\n\n      {0x1e74, 1887, 1},\n\n      {0x0474, 1064, 1},\n\n      {0x0174, 339, 1},\n\n      {0x1e3c, 1802, 1},\n\n      {0x0149, 46, 2},\n\n      {0x1f49, 2175, 1},\n\n      {0x1f3c, 2160, 1},\n\n      {0xab74, 1460, 1},\n\n      {0x0049, 3606, 1},\n\n      {0x0143, 267, 1},\n\n      {0x24cc, 2409, 1},\n\n      {0xa73c, 3012, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0043, 6, 1},\n\n      {0x0141, 264, 1},\n\n      {0x24c6, 2391, 1},\n\n      {0x013b, 255, 1},\n\n      {0x1f3b, 2157, 1},\n\n      {0x0041, 0, 1},\n\n      {0x0139, 252, 1},\n\n      {0x1f39, 2151, 1},\n\n      {0x24c5, 2388, 1},\n\n      {0x24bb, 2358, 1},\n\n      {0x13fa, 1694, 1},\n\n      {0x053d, 1370, 1},\n\n      {0x24b9, 2352, 1},\n\n      {0x0429, 965, 1},\n\n      {0x2183, 2340, 1},\n\n      {0x1f29, 2127, 1},\n\n      {0x2c29, 2544, 1},\n\n      {0x24c3, 2382, 1},\n\n      {0x10427, 3354, 1},\n\n      {0x10425, 3348, 1},\n\n      {0x0427, 959, 1},\n\n      {0x0425, 953, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c27, 2538, 1},\n\n      {0x2c25, 2532, 1},\n\n      {0x0549, 1406, 1},\n\n      {0x053c, 1367, 1},\n\n      {0x10423, 3342, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0423, 947, 1},\n\n      {0x0543, 1388, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c23, 2526, 1},\n\n      {0xff36, 3222, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0541, 1382, 1},\n\n      {0x10421, 3336, 1},\n\n      {0x053b, 1364, 1},\n\n      {0x0421, 941, 1},\n\n      {0xff38, 3228, 1},\n\n      {0x0539, 1358, 1},\n\n      {0x2c21, 2520, 1},\n\n      {0x10419, 3312, 1},\n\n      {0x10417, 3306, 1},\n\n      {0x0419, 917, 1},\n\n      {0x0417, 911, 1},\n\n      {0x1f19, 2109, 1},\n\n      {0x2c19, 2496, 1},\n\n      {0x2c17, 2490, 1},\n\n      {0x023e, 2568, 1},\n\n      {0xff34, 3216, 1},\n\n      {0x10415, 3300, 1},\n\n      {0x10413, 3294, 1},\n\n      {0x0415, 905, 1},\n\n      {0x0413, 899, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c15, 2484, 1},\n\n      {0x2c13, 2478, 1},\n      {0xffffffff, -1, 0},\n\n      {0x24ce, 2415, 1},\n\n      {0x1040f, 3282, 1},\n      {0xffffffff, -1, 0},\n\n      {0x040f, 1031, 1},\n\n      {0xff30, 3204, 1},\n\n      {0x1f0f, 2103, 1},\n\n      {0x2c0f, 2466, 1},\n\n      {0x1040d, 3276, 1},\n      {0xffffffff, -1, 0},\n\n      {0x040d, 1025, 1},\n\n      {0x0147, 273, 1},\n\n      {0x1f0d, 2097, 1},\n\n      {0x2c0d, 2460, 1},\n\n      {0x1040b, 3270, 1},\n\n      {0x0047, 18, 1},\n\n      {0x040b, 1019, 1},\n\n      {0x0230, 571, 1},\n\n      {0x1f0b, 2091, 1},\n\n      {0x2c0b, 2454, 1},\n\n      {0x10409, 3264, 1},\n\n      {0x10405, 3252, 1},\n\n      {0x0409, 1013, 1},\n\n      {0x0405, 1001, 1},\n\n      {0x1f09, 2085, 1},\n\n      {0x2c09, 2448, 1},\n\n      {0x2c05, 2436, 1},\n\n      {0x10403, 3246, 1},\n\n      {0x10401, 3240, 1},\n\n      {0x0403, 995, 1},\n\n      {0x0401, 989, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c03, 2430, 1},\n\n      {0x2c01, 2424, 1},\n\n      {0x13f9, 1691, 1},\n\n      {0x042f, 983, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1f2f, 2145, 1},\n\n      {0x1041f, 3330, 1},\n      {0xffffffff, -1, 0},\n\n      {0x041f, 935, 1},\n\n      {0x023d, 378, 1},\n\n      {0x10411, 3288, 1},\n\n      {0x2c1f, 2514, 1},\n\n      {0x0411, 893, 1},\n\n      {0x0547, 1400, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c11, 2472, 1},\n\n      {0x10407, 3258, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0407, 1007, 1},\n\n      {0x24c1, 2376, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c07, 2442, 1},\n      {0xffffffff, -1, 0},\n\n      {0x13f8, 1688, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff39, 3231, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0243, 354, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0x0241, 586, 1},\n\n      {0xff29, 3183, 1},\n\n      {0x023b, 577, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff27, 3177, 1},\n\n      {0xff25, 3171, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff23, 3165, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff21, 3159, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0},\n\n      {0xfb17, 117, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff2f, 3201, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xfb15, 113, 2},\n\n      {0xfb13, 121, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0},\n\n      {0xfb05, 29, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xfb03, 0, 3},\n\n      {0xfb01, 8, 2}\n    };\n\n  if (0 == 0)\n    {\n      int key = hash(&code);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          OnigCodePoint gcode = wordlist[key].code;\n\n          if (code == gcode && wordlist[key].index >= 0)\n            return &wordlist[key];\n        }\n    }\n  return 0;\n}", "line_changes": {"deleted": [{"line_no": 2780, "char_start": 39629, "char_end": 39658, "line": "          if (code == gcode)\n"}], "added": [{"line_no": 2780, "char_start": 39629, "char_end": 39686, "line": "          if (code == gcode && wordlist[key].index >= 0)\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 39656, "char_end": 39684, "chars": " && wordlist[key].index >= 0"}]}, "commit_link": "github.com/kkos/oniguruma/commit/166a6c3999bf06b4de0ab4ce6b088a468cc4029f", "file_name": "src/unicode_unfold_key.c", "vul_type": "cwe-787"}
{"func_name": "PHP_FUNCTION", "func_src_before": "PHP_FUNCTION(imagegammacorrect)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tint i;\n\tdouble input, output;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdd\", &IM, &input, &output) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (gdImageTrueColor(im))\t{\n\t\tint x, y, c;\n\n\t\tfor (y = 0; y < gdImageSY(im); y++)\t{\n\t\t\tfor (x = 0; x < gdImageSX(im); x++)\t{\n\t\t\t\tc = gdImageGetPixel(im, x, y);\n\t\t\t\tgdImageSetPixel(im, x, y,\n\t\t\t\t\tgdTrueColorAlpha(\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetRed(c)   / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetGreen(c) / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetBlue(c)  / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\tgdTrueColorGetAlpha(c)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tRETURN_TRUE;\n\t}\n\n\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\tim->red[i]   = (int)((pow((pow((im->red[i]   / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->green[i] = (int)((pow((pow((im->green[i] / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->blue[i]  = (int)((pow((pow((im->blue[i]  / 255.0), input)), 1.0 / output) * 255) + .5);\n\t}\n\n\tRETURN_TRUE;\n}", "func_src_after": "PHP_FUNCTION(imagegammacorrect)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tint i;\n\tdouble input, output;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdd\", &IM, &input, &output) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ( input <= 0.0 || output <= 0.0 ) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Gamma values should be positive\");\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (gdImageTrueColor(im))\t{\n\t\tint x, y, c;\n\n\t\tfor (y = 0; y < gdImageSY(im); y++)\t{\n\t\t\tfor (x = 0; x < gdImageSX(im); x++)\t{\n\t\t\t\tc = gdImageGetPixel(im, x, y);\n\t\t\t\tgdImageSetPixel(im, x, y,\n\t\t\t\t\tgdTrueColorAlpha(\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetRed(c)   / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetGreen(c) / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetBlue(c)  / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\tgdTrueColorGetAlpha(c)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tRETURN_TRUE;\n\t}\n\n\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\tim->red[i]   = (int)((pow((pow((im->red[i]   / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->green[i] = (int)((pow((pow((im->green[i] / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->blue[i]  = (int)((pow((pow((im->blue[i]  / 255.0), input)), 1.0 / output) * 255) + .5);\n\t}\n\n\tRETURN_TRUE;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 12, "char_start": 204, "char_end": 244, "line": "\tif ( input <= 0.0 || output <= 0.0 ) {\n"}, {"line_no": 13, "char_start": 244, "char_end": 326, "line": "\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Gamma values should be positive\");\n"}, {"line_no": 14, "char_start": 326, "char_end": 342, "line": "\t\tRETURN_FALSE;\n"}, {"line_no": 15, "char_start": 342, "char_end": 345, "line": "\t}\n"}, {"line_no": 16, "char_start": 345, "char_end": 346, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 205, "char_end": 347, "chars": "if ( input <= 0.0 || output <= 0.0 ) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Gamma values should be positive\");\n\t\tRETURN_FALSE;\n\t}\n\n\t"}]}, "commit_link": "github.com/php/php-src/commit/1bd103df00f49cf4d4ade2cfe3f456ac058a4eae", "file_name": "ext/gd/gd.c", "vul_type": "cwe-787"}
{"func_name": "rfbProcessFileTransferReadBuffer", "func_src_before": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n    /*\n    rfbLog(\"rfbProcessFileTransferReadBuffer(%dlen)\\n\", length);\n    */\n    if (length>0) {\n        buffer=malloc((uint64_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                /* NOTE: don't forget to free(buffer) if you return early! */\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            /* Null Terminate */\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "func_src_after": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n\n    /*\n       We later alloc length+1, which might wrap around on 32-bit systems if length equals\n       0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF\n       will safely be allocated since this check will never trigger and malloc() can digest length+1\n       without problems as length is a uint32_t.\n    */\n    if(length == SIZE_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                /* NOTE: don't forget to free(buffer) if you return early! */\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            /* Null Terminate */\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "line_changes": {"deleted": [{"line_no": 8, "char_start": 177, "char_end": 242, "line": "    rfbLog(\"rfbProcessFileTransferReadBuffer(%dlen)\\n\", length);\n"}, {"line_no": 11, "char_start": 269, "char_end": 312, "line": "        buffer=malloc((uint64_t)length+1);\n"}], "added": [{"line_no": 7, "char_start": 170, "char_end": 171, "line": "\n"}, {"line_no": 9, "char_start": 178, "char_end": 269, "line": "       We later alloc length+1, which might wrap around on 32-bit systems if length equals\n"}, {"line_no": 10, "char_start": 269, "char_end": 364, "line": "       0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF\n"}, {"line_no": 11, "char_start": 364, "char_end": 465, "line": "       will safely be allocated since this check will never trigger and malloc() can digest length+1\n"}, {"line_no": 12, "char_start": 465, "char_end": 514, "line": "       without problems as length is a uint32_t.\n"}, {"line_no": 14, "char_start": 521, "char_end": 550, "line": "    if(length == SIZE_MAX) {\n"}, {"line_no": 15, "char_start": 550, "char_end": 661, "line": "\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n"}, {"line_no": 16, "char_start": 661, "char_end": 682, "line": "\trfbCloseClient(cl);\n"}, {"line_no": 17, "char_start": 682, "char_end": 696, "line": "\treturn NULL;\n"}, {"line_no": 18, "char_start": 696, "char_end": 702, "line": "    }\n"}, {"line_no": 19, "char_start": 702, "char_end": 703, "line": "\n"}, {"line_no": 21, "char_start": 723, "char_end": 764, "line": "        buffer=malloc((size_t)length+1);\n"}]}, "char_changes": {"deleted": [{"char_start": 184, "char_end": 185, "chars": "L"}, {"char_start": 221, "char_end": 224, "chars": "(%d"}, {"char_start": 227, "char_end": 229, "chars": ")\\"}, {"char_start": 246, "char_end": 248, "chars": "*/"}, {"char_start": 292, "char_end": 293, "chars": "u"}, {"char_start": 294, "char_end": 298, "chars": "nt64"}], "added": [{"char_start": 170, "char_end": 171, "chars": "\n"}, {"char_start": 182, "char_end": 192, "chars": "   We late"}, {"char_start": 193, "char_end": 253, "chars": " alloc length+1, which might wrap around on 32-bit systems i"}, {"char_start": 254, "char_end": 309, "chars": " length equals\n       0XFFFFFFFF, i.e. SIZE_MAX for 32-"}, {"char_start": 310, "char_end": 350, "chars": "it systems. On 64-bit systems, a length "}, {"char_start": 351, "char_end": 427, "chars": "f 0XFFFFFFFF\n       will safely be allocated since this check will never tri"}, {"char_start": 428, "char_end": 557, "chars": "ger and malloc() can digest length+1\n       without problems as length is a uint32_t.\n    */\n    if(length == SIZE_MAX) {\n\trfbErr"}, {"char_start": 591, "char_end": 603, "chars": ": too big fi"}, {"char_start": 605, "char_end": 609, "chars": " tra"}, {"char_start": 610, "char_end": 617, "chars": "sfer le"}, {"char_start": 618, "char_end": 635, "chars": "gth requested: %u"}, {"char_start": 638, "char_end": 652, "chars": "(unsigned int)"}, {"char_start": 661, "char_end": 689, "chars": "\trfbCloseClient(cl);\n\treturn"}, {"char_start": 690, "char_end": 696, "chars": "NULL;\n"}, {"char_start": 699, "char_end": 702, "chars": " }\n"}, {"char_start": 746, "char_end": 747, "chars": "s"}, {"char_start": 748, "char_end": 750, "chars": "ze"}]}, "commit_link": "github.com/LibVNC/libvncserver/commit/15bb719c03cc70f14c36a843dcb16ed69b405707", "file_name": "libvncserver/rfbserver.c", "vul_type": "cwe-787"}
{"func_name": "track_header", "func_src_before": "static int track_header(VividasDemuxContext *viv, AVFormatContext *s,  uint8_t *buf, int size)\n{\n    int i, j, ret;\n    int64_t off;\n    int val_1;\n    int num_video;\n    AVIOContext pb0, *pb = &pb0;\n\n    ffio_init_context(pb, buf, size, 0, NULL, NULL, NULL, NULL);\n\n    ffio_read_varlen(pb); // track_header_len\n    avio_r8(pb); // '1'\n\n    val_1 = ffio_read_varlen(pb);\n\n    for (i=0;i<val_1;i++) {\n        int c = avio_r8(pb);\n        if (avio_feof(pb))\n            return AVERROR_EOF;\n        for (j=0;j<c;j++) {\n            if (avio_feof(pb))\n                return AVERROR_EOF;\n            avio_r8(pb); // val_3\n            avio_r8(pb); // val_4\n        }\n    }\n\n    avio_r8(pb); // num_streams\n\n    off = avio_tell(pb);\n    off += ffio_read_varlen(pb); // val_5\n\n    avio_r8(pb); // '2'\n    num_video = avio_r8(pb);\n\n    avio_seek(pb, off, SEEK_SET);\n    if (num_video != 1) {\n        av_log(s, AV_LOG_ERROR, \"number of video tracks %d is not 1\\n\", num_video);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    for (i = 0; i < num_video; i++) {\n        AVStream *st = avformat_new_stream(s, NULL);\n        int num, den;\n\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        st->id = i;\n\n        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codecpar->codec_id = AV_CODEC_ID_VP6;\n\n        off = avio_tell(pb);\n        off += ffio_read_varlen(pb);\n        avio_r8(pb); // '3'\n        avio_r8(pb); // val_7\n        num = avio_rl32(pb); // frame_time\n        den = avio_rl32(pb); // time_base\n        avpriv_set_pts_info(st, 64, num, den);\n        st->nb_frames = avio_rl32(pb); // n frames\n        st->codecpar->width = avio_rl16(pb); // width\n        st->codecpar->height = avio_rl16(pb); // height\n        avio_r8(pb); // val_8\n        avio_rl32(pb); // val_9\n\n        avio_seek(pb, off, SEEK_SET);\n    }\n\n    off = avio_tell(pb);\n    off += ffio_read_varlen(pb); // val_10\n    avio_r8(pb); // '4'\n    viv->num_audio = avio_r8(pb);\n    avio_seek(pb, off, SEEK_SET);\n\n    if (viv->num_audio != 1)\n        av_log(s, AV_LOG_WARNING, \"number of audio tracks %d is not 1\\n\", viv->num_audio);\n\n    for(i=0;i<viv->num_audio;i++) {\n        int q;\n        AVStream *st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        st->id = num_video + i;\n\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id = AV_CODEC_ID_VORBIS;\n\n        off = avio_tell(pb);\n        off += ffio_read_varlen(pb); // length\n        avio_r8(pb); // '5'\n        avio_r8(pb); //codec_id\n        avio_rl16(pb); //codec_subid\n        st->codecpar->channels = avio_rl16(pb); // channels\n        st->codecpar->sample_rate = avio_rl32(pb); // sample_rate\n        avio_seek(pb, 10, SEEK_CUR); // data_1\n        q = avio_r8(pb);\n        avio_seek(pb, q, SEEK_CUR); // data_2\n        avio_r8(pb); // zeropad\n\n        if (avio_tell(pb) < off) {\n            int num_data;\n            int xd_size = 0;\n            int data_len[256];\n            int offset = 1;\n            uint8_t *p;\n            ffio_read_varlen(pb); // val_13\n            avio_r8(pb); // '19'\n            ffio_read_varlen(pb); // len_3\n            num_data = avio_r8(pb);\n            for (j = 0; j < num_data; j++) {\n                uint64_t len = ffio_read_varlen(pb);\n                if (len > INT_MAX/2 - xd_size) {\n                    return AVERROR_INVALIDDATA;\n                }\n                data_len[j] = len;\n                xd_size += len;\n            }\n\n            ret = ff_alloc_extradata(st->codecpar, 64 + xd_size + xd_size / 255);\n            if (ret < 0)\n                return ret;\n\n            p = st->codecpar->extradata;\n            p[0] = 2;\n\n            for (j = 0; j < num_data - 1; j++) {\n                unsigned delta = av_xiphlacing(&p[offset], data_len[j]);\n                if (delta > data_len[j]) {\n                    return AVERROR_INVALIDDATA;\n                }\n                offset += delta;\n            }\n\n            for (j = 0; j < num_data; j++) {\n                int ret = avio_read(pb, &p[offset], data_len[j]);\n                if (ret < data_len[j]) {\n                    st->codecpar->extradata_size = 0;\n                    av_freep(&st->codecpar->extradata);\n                    break;\n                }\n                offset += data_len[j];\n            }\n\n            if (offset < st->codecpar->extradata_size)\n                st->codecpar->extradata_size = offset;\n        }\n    }\n\n    return 0;\n}", "func_src_after": "static int track_header(VividasDemuxContext *viv, AVFormatContext *s,  uint8_t *buf, int size)\n{\n    int i, j, ret;\n    int64_t off;\n    int val_1;\n    int num_video;\n    AVIOContext pb0, *pb = &pb0;\n\n    ffio_init_context(pb, buf, size, 0, NULL, NULL, NULL, NULL);\n\n    ffio_read_varlen(pb); // track_header_len\n    avio_r8(pb); // '1'\n\n    val_1 = ffio_read_varlen(pb);\n\n    for (i=0;i<val_1;i++) {\n        int c = avio_r8(pb);\n        if (avio_feof(pb))\n            return AVERROR_EOF;\n        for (j=0;j<c;j++) {\n            if (avio_feof(pb))\n                return AVERROR_EOF;\n            avio_r8(pb); // val_3\n            avio_r8(pb); // val_4\n        }\n    }\n\n    avio_r8(pb); // num_streams\n\n    off = avio_tell(pb);\n    off += ffio_read_varlen(pb); // val_5\n\n    avio_r8(pb); // '2'\n    num_video = avio_r8(pb);\n\n    avio_seek(pb, off, SEEK_SET);\n    if (num_video != 1) {\n        av_log(s, AV_LOG_ERROR, \"number of video tracks %d is not 1\\n\", num_video);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    for (i = 0; i < num_video; i++) {\n        AVStream *st = avformat_new_stream(s, NULL);\n        int num, den;\n\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        st->id = i;\n\n        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codecpar->codec_id = AV_CODEC_ID_VP6;\n\n        off = avio_tell(pb);\n        off += ffio_read_varlen(pb);\n        avio_r8(pb); // '3'\n        avio_r8(pb); // val_7\n        num = avio_rl32(pb); // frame_time\n        den = avio_rl32(pb); // time_base\n        avpriv_set_pts_info(st, 64, num, den);\n        st->nb_frames = avio_rl32(pb); // n frames\n        st->codecpar->width = avio_rl16(pb); // width\n        st->codecpar->height = avio_rl16(pb); // height\n        avio_r8(pb); // val_8\n        avio_rl32(pb); // val_9\n\n        avio_seek(pb, off, SEEK_SET);\n    }\n\n    off = avio_tell(pb);\n    off += ffio_read_varlen(pb); // val_10\n    avio_r8(pb); // '4'\n    viv->num_audio = avio_r8(pb);\n    avio_seek(pb, off, SEEK_SET);\n\n    if (viv->num_audio != 1)\n        av_log(s, AV_LOG_WARNING, \"number of audio tracks %d is not 1\\n\", viv->num_audio);\n\n    for(i=0;i<viv->num_audio;i++) {\n        int q;\n        AVStream *st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        st->id = num_video + i;\n\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id = AV_CODEC_ID_VORBIS;\n\n        off = avio_tell(pb);\n        off += ffio_read_varlen(pb); // length\n        avio_r8(pb); // '5'\n        avio_r8(pb); //codec_id\n        avio_rl16(pb); //codec_subid\n        st->codecpar->channels = avio_rl16(pb); // channels\n        st->codecpar->sample_rate = avio_rl32(pb); // sample_rate\n        avio_seek(pb, 10, SEEK_CUR); // data_1\n        q = avio_r8(pb);\n        avio_seek(pb, q, SEEK_CUR); // data_2\n        avio_r8(pb); // zeropad\n\n        if (avio_tell(pb) < off) {\n            int num_data;\n            int xd_size = 1;\n            int data_len[256];\n            int offset = 1;\n            uint8_t *p;\n            ffio_read_varlen(pb); // val_13\n            avio_r8(pb); // '19'\n            ffio_read_varlen(pb); // len_3\n            num_data = avio_r8(pb);\n            for (j = 0; j < num_data; j++) {\n                uint64_t len = ffio_read_varlen(pb);\n                if (len > INT_MAX/2 - xd_size) {\n                    return AVERROR_INVALIDDATA;\n                }\n                data_len[j] = len;\n                xd_size += len + 1 + len/255;\n            }\n\n            ret = ff_alloc_extradata(st->codecpar, xd_size);\n            if (ret < 0)\n                return ret;\n\n            p = st->codecpar->extradata;\n            p[0] = 2;\n\n            for (j = 0; j < num_data - 1; j++) {\n                unsigned delta = av_xiphlacing(&p[offset], data_len[j]);\n                av_assert0(delta <= xd_size - offset);\n                offset += delta;\n            }\n\n            for (j = 0; j < num_data; j++) {\n                int ret = avio_read(pb, &p[offset], data_len[j]);\n                if (ret < data_len[j]) {\n                    st->codecpar->extradata_size = 0;\n                    av_freep(&st->codecpar->extradata);\n                    break;\n                }\n                av_assert0(data_len[j] <= xd_size - offset);\n                offset += data_len[j];\n            }\n\n            if (offset < st->codecpar->extradata_size)\n                st->codecpar->extradata_size = offset;\n        }\n    }\n\n    return 0;\n}", "line_changes": {"deleted": [{"line_no": 104, "char_start": 2925, "char_end": 2954, "line": "            int xd_size = 0;\n"}, {"line_no": 118, "char_start": 3441, "char_end": 3473, "line": "                xd_size += len;\n"}, {"line_no": 121, "char_start": 3488, "char_end": 3570, "line": "            ret = ff_alloc_extradata(st->codecpar, 64 + xd_size + xd_size / 255);\n"}, {"line_no": 130, "char_start": 3810, "char_end": 3853, "line": "                if (delta > data_len[j]) {\n"}, {"line_no": 131, "char_start": 3853, "char_end": 3901, "line": "                    return AVERROR_INVALIDDATA;\n"}, {"line_no": 132, "char_start": 3901, "char_end": 3919, "line": "                }\n"}], "added": [{"line_no": 104, "char_start": 2925, "char_end": 2954, "line": "            int xd_size = 1;\n"}, {"line_no": 118, "char_start": 3441, "char_end": 3487, "line": "                xd_size += len + 1 + len/255;\n"}, {"line_no": 121, "char_start": 3502, "char_end": 3563, "line": "            ret = ff_alloc_extradata(st->codecpar, xd_size);\n"}, {"line_no": 130, "char_start": 3803, "char_end": 3858, "line": "                av_assert0(delta <= xd_size - offset);\n"}, {"line_no": 141, "char_start": 4213, "char_end": 4274, "line": "                av_assert0(data_len[j] <= xd_size - offset);\n"}]}, "char_changes": {"deleted": [{"char_start": 2951, "char_end": 2952, "chars": "0"}, {"char_start": 3539, "char_end": 3544, "chars": "64 + "}, {"char_start": 3551, "char_end": 3567, "chars": " + xd_size / 255"}, {"char_start": 3826, "char_end": 3829, "chars": "if "}, {"char_start": 3836, "char_end": 3837, "chars": ">"}, {"char_start": 3839, "char_end": 3842, "chars": "ata"}, {"char_start": 3843, "char_end": 3844, "chars": "l"}, {"char_start": 3845, "char_end": 3870, "chars": "n[j]) {\n                 "}, {"char_start": 3872, "char_end": 3874, "chars": " r"}, {"char_start": 3876, "char_end": 3899, "chars": "urn AVERROR_INVALIDDATA"}, {"char_start": 3900, "char_end": 3918, "chars": "\n                }"}], "added": [{"char_start": 2951, "char_end": 2952, "chars": "1"}, {"char_start": 3471, "char_end": 3485, "chars": " + 1 + len/255"}, {"char_start": 3819, "char_end": 3829, "chars": "av_assert0"}, {"char_start": 3836, "char_end": 3838, "chars": "<="}, {"char_start": 3839, "char_end": 3840, "chars": "x"}, {"char_start": 3842, "char_end": 3845, "chars": "siz"}, {"char_start": 3847, "char_end": 3848, "chars": "-"}, {"char_start": 3849, "char_end": 3853, "chars": "offs"}, {"char_start": 3855, "char_end": 3856, "chars": ")"}, {"char_start": 4212, "char_end": 4273, "chars": "\n                av_assert0(data_len[j] <= xd_size - offset);"}]}, "commit_link": "github.com/FFmpeg/FFmpeg/commit/27a99e2c7d450fef15594671eef4465c8a166bd7", "file_name": "libavformat/vividas.c", "vul_type": "cwe-787"}
{"func_name": "yaffsfs_istat", "func_src_before": "    yaffsfs_istat(TSK_FS_INFO *fs, TSK_FS_ISTAT_FLAG_ENUM flags, FILE * hFile, TSK_INUM_T inum,\n    TSK_DADDR_T numblock, int32_t sec_skew)\n{\n    TSK_FS_META *fs_meta;\n    TSK_FS_FILE *fs_file;\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n    char ls[12];\n    YAFFSFS_PRINT_ADDR print;\n    char timeBuf[32];\n    YaffsCacheObject * obj = NULL;\n    YaffsCacheVersion * version = NULL;\n    YaffsHeader * header = NULL;\n\n    yaffscache_version_find_by_inode(yfs, inum, &version, &obj);\n\n    if ((fs_file = tsk_fs_file_open_meta(fs, NULL, inum)) == NULL) {\n        return 1;\n    }\n    fs_meta = fs_file->meta;\n\n    tsk_fprintf(hFile, \"inode: %\" PRIuINUM \"\\n\", inum);\n    tsk_fprintf(hFile, \"%sAllocated\\n\",\n        (fs_meta->flags & TSK_FS_META_FLAG_ALLOC) ? \"\" : \"Not \");\n\n    if (fs_meta->link)\n        tsk_fprintf(hFile, \"symbolic link to: %s\\n\", fs_meta->link);\n\n    tsk_fprintf(hFile, \"uid / gid: %\" PRIuUID \" / %\" PRIuGID \"\\n\",\n        fs_meta->uid, fs_meta->gid);\n\n    tsk_fs_meta_make_ls(fs_meta, ls, sizeof(ls));\n    tsk_fprintf(hFile, \"mode: %s\\n\", ls);\n\n    tsk_fprintf(hFile, \"size: %\" PRIdOFF \"\\n\", fs_meta->size);\n    tsk_fprintf(hFile, \"num of links: %d\\n\", fs_meta->nlink);\n\n    if(version != NULL){\n        yaffsfs_read_header(yfs, &header, version->ycv_header_chunk->ycc_offset);\n        if(header != NULL){\n            tsk_fprintf(hFile, \"Name: %s\\n\", header->name);\n        }\n    }\n\n    if (sec_skew != 0) {\n        tsk_fprintf(hFile, \"\\nAdjusted Inode Times:\\n\");\n        fs_meta->mtime -= sec_skew;\n        fs_meta->atime -= sec_skew;\n        fs_meta->ctime -= sec_skew;\n\n        tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n        tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n        tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n\n        fs_meta->mtime += sec_skew;\n        fs_meta->atime += sec_skew;\n        fs_meta->ctime += sec_skew;\n\n        tsk_fprintf(hFile, \"\\nOriginal Inode Times:\\n\");\n    }\n    else {\n        tsk_fprintf(hFile, \"\\nInode Times:\\n\");\n    }\n\n    tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n    tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n    tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n\n    if(version != NULL){\n        tsk_fprintf(hFile, \"\\nHeader Chunk:\\n\");\n        tsk_fprintf(hFile, \"%\" PRIuDADDR \"\\n\", (version->ycv_header_chunk->ycc_offset / (yfs->page_size + yfs->spare_size)));\n    }\n\n    if (numblock > 0) {\n        TSK_OFF_T lower_size = numblock * fs->block_size;\n        fs_meta->size = (lower_size < fs_meta->size)?(lower_size):(fs_meta->size);\n    }\n    tsk_fprintf(hFile, \"\\nData Chunks:\\n\");\n\n\n    if (flags & TSK_FS_ISTAT_RUNLIST){\n        const TSK_FS_ATTR *fs_attr_default =\n            tsk_fs_file_attr_get_type(fs_file,\n                TSK_FS_ATTR_TYPE_DEFAULT, 0, 0);\n        if (fs_attr_default && (fs_attr_default->flags & TSK_FS_ATTR_NONRES)) {\n            if (tsk_fs_attr_print(fs_attr_default, hFile)) {\n                tsk_fprintf(hFile, \"\\nError creating run lists  \");\n                tsk_error_print(hFile);\n                tsk_error_reset();\n            }\n        }\n    }\n    else {\n        print.idx = 0;\n        print.hFile = hFile;\n\n        if (tsk_fs_file_walk(fs_file, TSK_FS_FILE_WALK_FLAG_AONLY,\n            (TSK_FS_FILE_WALK_CB)print_addr_act, (void *)&print)) {\n            tsk_fprintf(hFile, \"\\nError reading file:  \");\n            tsk_error_print(hFile);\n            tsk_error_reset();\n        }\n        else if (print.idx != 0) {\n            tsk_fprintf(hFile, \"\\n\");\n        }\n    }\n\n    tsk_fs_file_close(fs_file);\n\n    return 0;\n}", "func_src_after": "    yaffsfs_istat(TSK_FS_INFO *fs, TSK_FS_ISTAT_FLAG_ENUM flags, FILE * hFile, TSK_INUM_T inum,\n    TSK_DADDR_T numblock, int32_t sec_skew)\n{\n    TSK_FS_META *fs_meta;\n    TSK_FS_FILE *fs_file;\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n    char ls[12];\n    YAFFSFS_PRINT_ADDR print;\n    char timeBuf[128];\n    YaffsCacheObject * obj = NULL;\n    YaffsCacheVersion * version = NULL;\n    YaffsHeader * header = NULL;\n\n    yaffscache_version_find_by_inode(yfs, inum, &version, &obj);\n\n    if ((fs_file = tsk_fs_file_open_meta(fs, NULL, inum)) == NULL) {\n        return 1;\n    }\n    fs_meta = fs_file->meta;\n\n    tsk_fprintf(hFile, \"inode: %\" PRIuINUM \"\\n\", inum);\n    tsk_fprintf(hFile, \"%sAllocated\\n\",\n        (fs_meta->flags & TSK_FS_META_FLAG_ALLOC) ? \"\" : \"Not \");\n\n    if (fs_meta->link)\n        tsk_fprintf(hFile, \"symbolic link to: %s\\n\", fs_meta->link);\n\n    tsk_fprintf(hFile, \"uid / gid: %\" PRIuUID \" / %\" PRIuGID \"\\n\",\n        fs_meta->uid, fs_meta->gid);\n\n    tsk_fs_meta_make_ls(fs_meta, ls, sizeof(ls));\n    tsk_fprintf(hFile, \"mode: %s\\n\", ls);\n\n    tsk_fprintf(hFile, \"size: %\" PRIdOFF \"\\n\", fs_meta->size);\n    tsk_fprintf(hFile, \"num of links: %d\\n\", fs_meta->nlink);\n\n    if(version != NULL){\n        yaffsfs_read_header(yfs, &header, version->ycv_header_chunk->ycc_offset);\n        if(header != NULL){\n            tsk_fprintf(hFile, \"Name: %s\\n\", header->name);\n        }\n    }\n\n    if (sec_skew != 0) {\n        tsk_fprintf(hFile, \"\\nAdjusted Inode Times:\\n\");\n        fs_meta->mtime -= sec_skew;\n        fs_meta->atime -= sec_skew;\n        fs_meta->ctime -= sec_skew;\n\n        tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n        tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n        tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n\n        fs_meta->mtime += sec_skew;\n        fs_meta->atime += sec_skew;\n        fs_meta->ctime += sec_skew;\n\n        tsk_fprintf(hFile, \"\\nOriginal Inode Times:\\n\");\n    }\n    else {\n        tsk_fprintf(hFile, \"\\nInode Times:\\n\");\n    }\n\n    tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n    tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n    tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n\n    if(version != NULL){\n        tsk_fprintf(hFile, \"\\nHeader Chunk:\\n\");\n        tsk_fprintf(hFile, \"%\" PRIuDADDR \"\\n\", (version->ycv_header_chunk->ycc_offset / (yfs->page_size + yfs->spare_size)));\n    }\n\n    if (numblock > 0) {\n        TSK_OFF_T lower_size = numblock * fs->block_size;\n        fs_meta->size = (lower_size < fs_meta->size)?(lower_size):(fs_meta->size);\n    }\n    tsk_fprintf(hFile, \"\\nData Chunks:\\n\");\n\n\n    if (flags & TSK_FS_ISTAT_RUNLIST){\n        const TSK_FS_ATTR *fs_attr_default =\n            tsk_fs_file_attr_get_type(fs_file,\n                TSK_FS_ATTR_TYPE_DEFAULT, 0, 0);\n        if (fs_attr_default && (fs_attr_default->flags & TSK_FS_ATTR_NONRES)) {\n            if (tsk_fs_attr_print(fs_attr_default, hFile)) {\n                tsk_fprintf(hFile, \"\\nError creating run lists  \");\n                tsk_error_print(hFile);\n                tsk_error_reset();\n            }\n        }\n    }\n    else {\n        print.idx = 0;\n        print.hFile = hFile;\n\n        if (tsk_fs_file_walk(fs_file, TSK_FS_FILE_WALK_FLAG_AONLY,\n            (TSK_FS_FILE_WALK_CB)print_addr_act, (void *)&print)) {\n            tsk_fprintf(hFile, \"\\nError reading file:  \");\n            tsk_error_print(hFile);\n            tsk_error_reset();\n        }\n        else if (print.idx != 0) {\n            tsk_fprintf(hFile, \"\\n\");\n        }\n    }\n\n    tsk_fs_file_close(fs_file);\n\n    return 0;\n}", "line_changes": {"deleted": [{"line_no": 9, "char_start": 285, "char_end": 307, "line": "    char timeBuf[32];\n"}], "added": [{"line_no": 9, "char_start": 285, "char_end": 308, "line": "    char timeBuf[128];\n"}]}, "char_changes": {"deleted": [{"char_start": 302, "char_end": 303, "chars": "3"}], "added": [{"char_start": 302, "char_end": 303, "chars": "1"}, {"char_start": 304, "char_end": 305, "chars": "8"}]}, "commit_link": "github.com/sleuthkit/sleuthkit/commit/459ae818fc8dae717549810150de4d191ce158f1", "file_name": "tsk/fs/yaffs.cpp", "vul_type": "cwe-787"}
{"func_name": "InsertRow", "func_src_before": "static void InsertRow(unsigned char *p,ssize_t y,Image *image, int bpp)\n{\n  ExceptionInfo\n    *exception;\n\n  int\n    bit;\n\n  ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  IndexPacket\n    index;\n\n  register IndexPacket\n    *indexes;\n\n  exception=(&image->exception);\n  switch (bpp)\n    {\n    case 1:  /* Convert bitmap scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n              {\n                index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n                SetPixelIndex(indexes+x+bit,index);\n                SetPixelRGBO(q,image->colormap+(ssize_t) index);\n                q++;\n              }\n            p++;\n          }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)\n              {\n                index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n                SetPixelIndex(indexes+x+bit,index);\n                SetPixelRGBO(q,image->colormap+(ssize_t) index);\n                q++;\n              }\n            p++;\n          }\n        if (!SyncAuthenticPixels(image,exception))\n          break;\n        break;\n      }\n    case 2:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n        {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            q++;\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            q++;\n            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            q++;\n            index=ConstrainColormapIndex(image,(*p) & 0x3);\n            SetPixelIndex(indexes+x+1,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n        }\n       if ((image->columns % 4) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            q++;\n            if ((image->columns % 4) >= 1)\n\n              {\n                index=ConstrainColormapIndex(image,(*p >> 4) & 0x3);\n                SetPixelIndex(indexes+x,index);\n                SetPixelRGBO(q,image->colormap+(ssize_t) index);\n                q++;\n                if ((image->columns % 4) >= 2)\n\n                  {\n                    index=ConstrainColormapIndex(image,(*p >> 2) & 0x3);\n                    SetPixelIndex(indexes+x,index);\n                    SetPixelRGBO(q,image->colormap+(ssize_t) index);\n                    q++;\n                  }\n              }\n            p++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        break;\n      }\n\n    case 4:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            q++;\n            index=ConstrainColormapIndex(image,(*p) & 0x0f);\n            SetPixelIndex(indexes+x+1,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n          }\n        if ((image->columns % 2) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        break;\n      }\n    case 8: /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL) break;\n        indexes=GetAuthenticIndexQueue(image);\n\n        for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,*p);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      break;\n\n    case 24:     /*  Convert DirectColor scanline.  */\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelRed(q,ScaleCharToQuantum(*p++));\n          SetPixelGreen(q,ScaleCharToQuantum(*p++));\n          SetPixelBlue(q,ScaleCharToQuantum(*p++));\n          q++;\n        }\n      if (!SyncAuthenticPixels(image,exception))\n        break;\n      break;\n    }\n}", "func_src_after": "static void InsertRow(unsigned char *p,ssize_t y,Image *image, int bpp)\n{\n  ExceptionInfo\n    *exception;\n\n  int\n    bit;\n\n  ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  IndexPacket\n    index;\n\n  register IndexPacket\n    *indexes;\n\n  exception=(&image->exception);\n  switch (bpp)\n    {\n    case 1:  /* Convert bitmap scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n              {\n                index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n                SetPixelIndex(indexes+x+bit,index);\n                SetPixelRGBO(q,image->colormap+(ssize_t) index);\n                q++;\n              }\n            p++;\n          }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)\n              {\n                index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n                SetPixelIndex(indexes+x+bit,index);\n                SetPixelRGBO(q,image->colormap+(ssize_t) index);\n                q++;\n              }\n            p++;\n          }\n        if (!SyncAuthenticPixels(image,exception))\n          break;\n        break;\n      }\n    case 2:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-1); x+=4)\n        {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            q++;\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            q++;\n            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            q++;\n            index=ConstrainColormapIndex(image,(*p) & 0x3);\n            SetPixelIndex(indexes+x+1,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n        }\n       if ((image->columns % 4) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            q++;\n            if ((image->columns % 4) >= 1)\n\n              {\n                index=ConstrainColormapIndex(image,(*p >> 4) & 0x3);\n                SetPixelIndex(indexes+x,index);\n                SetPixelRGBO(q,image->colormap+(ssize_t) index);\n                q++;\n                if ((image->columns % 4) >= 2)\n\n                  {\n                    index=ConstrainColormapIndex(image,(*p >> 2) & 0x3);\n                    SetPixelIndex(indexes+x,index);\n                    SetPixelRGBO(q,image->colormap+(ssize_t) index);\n                    q++;\n                  }\n              }\n            p++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        break;\n      }\n\n    case 4:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            q++;\n            index=ConstrainColormapIndex(image,(*p) & 0x0f);\n            SetPixelIndex(indexes+x+1,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n          }\n        if ((image->columns % 2) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        break;\n      }\n    case 8: /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL) break;\n        indexes=GetAuthenticIndexQueue(image);\n\n        for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,*p);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      break;\n\n    case 24:     /*  Convert DirectColor scanline.  */\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelRed(q,ScaleCharToQuantum(*p++));\n          SetPixelGreen(q,ScaleCharToQuantum(*p++));\n          SetPixelBlue(q,ScaleCharToQuantum(*p++));\n          q++;\n        }\n      if (!SyncAuthenticPixels(image,exception))\n        break;\n      break;\n    }\n}", "line_changes": {"deleted": [{"line_no": 62, "char_start": 1585, "char_end": 1643, "line": "        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n"}], "added": [{"line_no": 62, "char_start": 1585, "char_end": 1643, "line": "        for (x=0; x < ((ssize_t) image->columns-1); x+=4)\n"}]}, "char_changes": {"deleted": [{"char_start": 1640, "char_end": 1641, "chars": "2"}], "added": [{"char_start": 1640, "char_end": 1641, "chars": "4"}]}, "commit_link": "github.com/ImageMagick/ImageMagick/commit/b6ae2f9e0ab13343c0281732d479757a8e8979c7", "file_name": "coders/wpg.c", "vul_type": "cwe-787"}
{"func_name": "rds_rdma_extra_size", "func_src_before": "int rds_rdma_extra_size(struct rds_rdma_args *args)\n{\n\tstruct rds_iovec vec;\n\tstruct rds_iovec __user *local_vec;\n\tint tot_pages = 0;\n\tunsigned int nr_pages;\n\tunsigned int i;\n\n\tlocal_vec = (struct rds_iovec __user *)(unsigned long) args->local_vec_addr;\n\n\t/* figure out the number of pages in the vector */\n\tfor (i = 0; i < args->nr_local; i++) {\n\t\tif (copy_from_user(&vec, &local_vec[i],\n\t\t\t\t   sizeof(struct rds_iovec)))\n\t\t\treturn -EFAULT;\n\n\t\tnr_pages = rds_pages_in_vec(&vec);\n\t\tif (nr_pages == 0)\n\t\t\treturn -EINVAL;\n\n\t\ttot_pages += nr_pages;\n\n\t\t/*\n\t\t * nr_pages for one entry is limited to (UINT_MAX>>PAGE_SHIFT)+1,\n\t\t * so tot_pages cannot overflow without first going negative.\n\t\t */\n\t\tif (tot_pages < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn tot_pages * sizeof(struct scatterlist);\n}", "func_src_after": "int rds_rdma_extra_size(struct rds_rdma_args *args)\n{\n\tstruct rds_iovec vec;\n\tstruct rds_iovec __user *local_vec;\n\tint tot_pages = 0;\n\tunsigned int nr_pages;\n\tunsigned int i;\n\n\tlocal_vec = (struct rds_iovec __user *)(unsigned long) args->local_vec_addr;\n\n\tif (args->nr_local == 0)\n\t\treturn -EINVAL;\n\n\t/* figure out the number of pages in the vector */\n\tfor (i = 0; i < args->nr_local; i++) {\n\t\tif (copy_from_user(&vec, &local_vec[i],\n\t\t\t\t   sizeof(struct rds_iovec)))\n\t\t\treturn -EFAULT;\n\n\t\tnr_pages = rds_pages_in_vec(&vec);\n\t\tif (nr_pages == 0)\n\t\t\treturn -EINVAL;\n\n\t\ttot_pages += nr_pages;\n\n\t\t/*\n\t\t * nr_pages for one entry is limited to (UINT_MAX>>PAGE_SHIFT)+1,\n\t\t * so tot_pages cannot overflow without first going negative.\n\t\t */\n\t\tif (tot_pages < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn tot_pages * sizeof(struct scatterlist);\n}", "line_changes": {"deleted": [], "added": [{"line_no": 11, "char_start": 255, "char_end": 281, "line": "\tif (args->nr_local == 0)\n"}, {"line_no": 12, "char_start": 281, "char_end": 299, "line": "\t\treturn -EINVAL;\n"}, {"line_no": 13, "char_start": 299, "char_end": 300, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 256, "char_end": 301, "chars": "if (args->nr_local == 0)\n\t\treturn -EINVAL;\n\n\t"}]}, "commit_link": "github.com/torvalds/linux/commit/c095508770aebf1b9218e77026e48345d719b17c", "file_name": "net/rds/rdma.c", "vul_type": "cwe-787"}
{"func_name": "decode_frame", "func_src_before": "static int decode_frame(AVCodecContext *avctx,\n                        void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    PicContext *s = avctx->priv_data;\n    AVFrame *frame = data;\n    uint32_t *palette;\n    int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;\n    int i, x, y, plane, tmp, ret, val;\n\n    bytestream2_init(&s->g, avpkt->data, avpkt->size);\n\n    if (bytestream2_get_bytes_left(&s->g) < 11)\n        return AVERROR_INVALIDDATA;\n\n    if (bytestream2_get_le16u(&s->g) != 0x1234)\n        return AVERROR_INVALIDDATA;\n\n    s->width       = bytestream2_get_le16u(&s->g);\n    s->height      = bytestream2_get_le16u(&s->g);\n    bytestream2_skip(&s->g, 4);\n    tmp            = bytestream2_get_byteu(&s->g);\n    bits_per_plane = tmp & 0xF;\n    s->nb_planes   = (tmp >> 4) + 1;\n    bpp            = bits_per_plane * s->nb_planes;\n    if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {\n        avpriv_request_sample(avctx, \"Unsupported bit depth\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (bytestream2_peek_byte(&s->g) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8) {\n        bytestream2_skip(&s->g, 2);\n        etype = bytestream2_get_le16(&s->g);\n        esize = bytestream2_get_le16(&s->g);\n        if (bytestream2_get_bytes_left(&s->g) < esize)\n            return AVERROR_INVALIDDATA;\n    } else {\n        etype = -1;\n        esize = 0;\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    if (av_image_check_size(s->width, s->height, 0, avctx) < 0)\n        return -1;\n    if (s->width != avctx->width && s->height != avctx->height) {\n        ret = ff_set_dimensions(avctx, s->width, s->height);\n        if (ret < 0)\n            return ret;\n    }\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;\n    memset(frame->data[0], 0, s->height * frame->linesize[0]);\n    frame->pict_type           = AV_PICTURE_TYPE_I;\n    frame->palette_has_changed = 1;\n\n    pos_after_pal = bytestream2_tell(&s->g) + esize;\n    palette = (uint32_t*)frame->data[1];\n    if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {\n        int idx = bytestream2_get_byte(&s->g);\n        npal = 4;\n        for (i = 0; i < npal; i++)\n            palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];\n    } else if (etype == 2) {\n        npal = FFMIN(esize, 16);\n        for (i = 0; i < npal; i++) {\n            int pal_idx = bytestream2_get_byte(&s->g);\n            palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];\n        }\n    } else if (etype == 3) {\n        npal = FFMIN(esize, 16);\n        for (i = 0; i < npal; i++) {\n            int pal_idx = bytestream2_get_byte(&s->g);\n            palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];\n        }\n    } else if (etype == 4 || etype == 5) {\n        npal = FFMIN(esize / 3, 256);\n        for (i = 0; i < npal; i++) {\n            palette[i] = bytestream2_get_be24(&s->g) << 2;\n            palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;\n        }\n    } else {\n        if (bpp == 1) {\n            npal = 2;\n            palette[0] = 0xFF000000;\n            palette[1] = 0xFFFFFFFF;\n        } else if (bpp == 2) {\n            npal = 4;\n            for (i = 0; i < npal; i++)\n                palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];\n        } else {\n            npal = 16;\n            memcpy(palette, ff_cga_palette, npal * 4);\n        }\n    }\n    // fill remaining palette entries\n    memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);\n    // skip remaining palette bytes\n    bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);\n\n    val = 0;\n    y = s->height - 1;\n    if (bytestream2_get_le16(&s->g)) {\n        x = 0;\n        plane = 0;\n        while (bytestream2_get_bytes_left(&s->g) >= 6) {\n            int stop_size, marker, t1, t2;\n\n            t1        = bytestream2_get_bytes_left(&s->g);\n            t2        = bytestream2_get_le16(&s->g);\n            stop_size = t1 - FFMIN(t1, t2);\n            // ignore uncompressed block size\n            bytestream2_skip(&s->g, 2);\n            marker    = bytestream2_get_byte(&s->g);\n\n            while (plane < s->nb_planes &&\n                   bytestream2_get_bytes_left(&s->g) > stop_size) {\n                int run = 1;\n                val = bytestream2_get_byte(&s->g);\n                if (val == marker) {\n                    run = bytestream2_get_byte(&s->g);\n                    if (run == 0)\n                        run = bytestream2_get_le16(&s->g);\n                    val = bytestream2_get_byte(&s->g);\n                }\n                if (!bytestream2_get_bytes_left(&s->g))\n                    break;\n\n                if (bits_per_plane == 8) {\n                    picmemset_8bpp(s, frame, val, run, &x, &y);\n                    if (y < 0)\n                        goto finish;\n                } else {\n                    picmemset(s, frame, val, run, &x, &y, &plane, bits_per_plane);\n                }\n            }\n        }\n\n        if (x < avctx->width) {\n            int run = (y + 1) * avctx->width - x;\n            if (bits_per_plane == 8)\n                picmemset_8bpp(s, frame, val, run, &x, &y);\n            else\n                picmemset(s, frame, val, run / (8 / bits_per_plane), &x, &y, &plane, bits_per_plane);\n        }\n    } else {\n        while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {\n            memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));\n            bytestream2_skip(&s->g, avctx->width);\n            y--;\n        }\n    }\nfinish:\n\n    *got_frame      = 1;\n    return avpkt->size;\n}", "func_src_after": "static int decode_frame(AVCodecContext *avctx,\n                        void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    PicContext *s = avctx->priv_data;\n    AVFrame *frame = data;\n    uint32_t *palette;\n    int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;\n    int i, x, y, plane, tmp, ret, val;\n\n    bytestream2_init(&s->g, avpkt->data, avpkt->size);\n\n    if (bytestream2_get_bytes_left(&s->g) < 11)\n        return AVERROR_INVALIDDATA;\n\n    if (bytestream2_get_le16u(&s->g) != 0x1234)\n        return AVERROR_INVALIDDATA;\n\n    s->width       = bytestream2_get_le16u(&s->g);\n    s->height      = bytestream2_get_le16u(&s->g);\n    bytestream2_skip(&s->g, 4);\n    tmp            = bytestream2_get_byteu(&s->g);\n    bits_per_plane = tmp & 0xF;\n    s->nb_planes   = (tmp >> 4) + 1;\n    bpp            = bits_per_plane * s->nb_planes;\n    if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {\n        avpriv_request_sample(avctx, \"Unsupported bit depth\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (bytestream2_peek_byte(&s->g) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8) {\n        bytestream2_skip(&s->g, 2);\n        etype = bytestream2_get_le16(&s->g);\n        esize = bytestream2_get_le16(&s->g);\n        if (bytestream2_get_bytes_left(&s->g) < esize)\n            return AVERROR_INVALIDDATA;\n    } else {\n        etype = -1;\n        esize = 0;\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    if (av_image_check_size(s->width, s->height, 0, avctx) < 0)\n        return -1;\n    if (s->width != avctx->width || s->height != avctx->height) {\n        ret = ff_set_dimensions(avctx, s->width, s->height);\n        if (ret < 0)\n            return ret;\n    }\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;\n    memset(frame->data[0], 0, s->height * frame->linesize[0]);\n    frame->pict_type           = AV_PICTURE_TYPE_I;\n    frame->palette_has_changed = 1;\n\n    pos_after_pal = bytestream2_tell(&s->g) + esize;\n    palette = (uint32_t*)frame->data[1];\n    if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {\n        int idx = bytestream2_get_byte(&s->g);\n        npal = 4;\n        for (i = 0; i < npal; i++)\n            palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];\n    } else if (etype == 2) {\n        npal = FFMIN(esize, 16);\n        for (i = 0; i < npal; i++) {\n            int pal_idx = bytestream2_get_byte(&s->g);\n            palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];\n        }\n    } else if (etype == 3) {\n        npal = FFMIN(esize, 16);\n        for (i = 0; i < npal; i++) {\n            int pal_idx = bytestream2_get_byte(&s->g);\n            palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];\n        }\n    } else if (etype == 4 || etype == 5) {\n        npal = FFMIN(esize / 3, 256);\n        for (i = 0; i < npal; i++) {\n            palette[i] = bytestream2_get_be24(&s->g) << 2;\n            palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;\n        }\n    } else {\n        if (bpp == 1) {\n            npal = 2;\n            palette[0] = 0xFF000000;\n            palette[1] = 0xFFFFFFFF;\n        } else if (bpp == 2) {\n            npal = 4;\n            for (i = 0; i < npal; i++)\n                palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];\n        } else {\n            npal = 16;\n            memcpy(palette, ff_cga_palette, npal * 4);\n        }\n    }\n    // fill remaining palette entries\n    memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);\n    // skip remaining palette bytes\n    bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);\n\n    val = 0;\n    y = s->height - 1;\n    if (bytestream2_get_le16(&s->g)) {\n        x = 0;\n        plane = 0;\n        while (bytestream2_get_bytes_left(&s->g) >= 6) {\n            int stop_size, marker, t1, t2;\n\n            t1        = bytestream2_get_bytes_left(&s->g);\n            t2        = bytestream2_get_le16(&s->g);\n            stop_size = t1 - FFMIN(t1, t2);\n            // ignore uncompressed block size\n            bytestream2_skip(&s->g, 2);\n            marker    = bytestream2_get_byte(&s->g);\n\n            while (plane < s->nb_planes &&\n                   bytestream2_get_bytes_left(&s->g) > stop_size) {\n                int run = 1;\n                val = bytestream2_get_byte(&s->g);\n                if (val == marker) {\n                    run = bytestream2_get_byte(&s->g);\n                    if (run == 0)\n                        run = bytestream2_get_le16(&s->g);\n                    val = bytestream2_get_byte(&s->g);\n                }\n                if (!bytestream2_get_bytes_left(&s->g))\n                    break;\n\n                if (bits_per_plane == 8) {\n                    picmemset_8bpp(s, frame, val, run, &x, &y);\n                    if (y < 0)\n                        goto finish;\n                } else {\n                    picmemset(s, frame, val, run, &x, &y, &plane, bits_per_plane);\n                }\n            }\n        }\n\n        if (x < avctx->width) {\n            int run = (y + 1) * avctx->width - x;\n            if (bits_per_plane == 8)\n                picmemset_8bpp(s, frame, val, run, &x, &y);\n            else\n                picmemset(s, frame, val, run / (8 / bits_per_plane), &x, &y, &plane, bits_per_plane);\n        }\n    } else {\n        while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {\n            memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));\n            bytestream2_skip(&s->g, avctx->width);\n            y--;\n        }\n    }\nfinish:\n\n    *got_frame      = 1;\n    return avpkt->size;\n}", "line_changes": {"deleted": [{"line_no": 46, "char_start": 1512, "char_end": 1578, "line": "    if (s->width != avctx->width && s->height != avctx->height) {\n"}], "added": [{"line_no": 46, "char_start": 1512, "char_end": 1578, "line": "    if (s->width != avctx->width || s->height != avctx->height) {\n"}]}, "char_changes": {"deleted": [{"char_start": 1545, "char_end": 1547, "chars": "&&"}], "added": [{"char_start": 1545, "char_end": 1547, "chars": "||"}]}, "commit_link": "github.com/FFmpeg/FFmpeg/commit/8c2ea3030af7b40a3c4275696fb5c76cdb80950a", "file_name": "libavcodec/pictordec.c", "vul_type": "cwe-787"}
{"func_name": "concat_opt_exact_str", "func_src_before": "concat_opt_exact_str(OptStr* to, UChar* s, UChar* end, OnigEncoding enc)\n{\n  int i, j, len;\n  UChar *p;\n\n  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {\n    len = enclen(enc, p);\n    if (i + len > OPT_EXACT_MAXLEN) break;\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n\n  to->len = i;\n\n  if (p >= end)\n    to->reach_end = 1;\n}", "func_src_after": "concat_opt_exact_str(OptStr* to, UChar* s, UChar* end, OnigEncoding enc)\n{\n  int i, j, len;\n  UChar *p;\n\n  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {\n    len = enclen(enc, p);\n    if (i + len >= OPT_EXACT_MAXLEN) break;\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n\n  to->len = i;\n\n  if (p >= end)\n    to->reach_end = 1;\n}", "line_changes": {"deleted": [{"line_no": 8, "char_start": 195, "char_end": 238, "line": "    if (i + len > OPT_EXACT_MAXLEN) break;\n"}], "added": [{"line_no": 8, "char_start": 195, "char_end": 239, "line": "    if (i + len >= OPT_EXACT_MAXLEN) break;\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 212, "char_end": 213, "chars": "="}]}, "commit_link": "github.com/kkos/oniguruma/commit/cbe9f8bd9cfc6c3c87a60fbae58fa1a85db59df0", "file_name": "src/regcomp.c", "vul_type": "cwe-787"}
