{"func_name": "disk_seqf_stop", "func_src_before": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\n\t/* stop is called even after start failed :-( */\n\tif (iter) {\n\t\tclass_dev_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n}", "func_src_after": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\n\t/* stop is called even after start failed :-( */\n\tif (iter) {\n\t\tclass_dev_iter_exit(iter);\n\t\tkfree(iter);\n\t\tseqf->private = NULL;\n\t}\n}", "line_changes": {"deleted": [], "added": [{"line_no": 9, "char_start": 215, "char_end": 239, "line": "\t\tseqf->private = NULL;\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 216, "char_end": 240, "chars": "\tseqf->private = NULL;\n\t"}]}, "commit_link": "github.com/torvalds/linux/commit/77da160530dd1dc94f6ae15a981f24e5f0021e84", "file_name": "block/genhd.c", "vul_type": "cwe-416"}
{"func_name": "dbd_st_fetch", "func_src_before": "dbd_st_fetch(SV *sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  int num_fields, ChopBlanks, i, rc;\n  unsigned long *lengths;\n  AV *av;\n  int av_length, av_readonly;\n  MYSQL_ROW cols;\n  D_imp_dbh_from_sth;\n  MYSQL* svsock= imp_dbh->pmysql;\n  imp_sth_fbh_t *fbh;\n  D_imp_xxh(sth);\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  MYSQL_BIND *buffer;\n#endif\n  MYSQL_FIELD *fields;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t-> dbd_st_fetch\\n\");\n\n#if MYSQL_ASYNC\n  if(imp_dbh->async_query_in_flight) {\n      if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {\n        return Nullav;\n      }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (!DBIc_ACTIVE(imp_sth) )\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"no statement executing\\n\",NULL);\n      return Nullav;\n    }\n\n    if (imp_sth->fetch_done)\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"fetch() but fetch already done\",NULL);\n      return Nullav;\n    }\n\n    if (!imp_sth->done_desc)\n    {\n      if (!dbd_describe(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE, \"Error while describe result set.\",\n                 NULL);\n        return Nullav;\n      }\n    }\n  }\n#endif\n\n  ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tdbd_st_fetch for %p, chopblanks %d\\n\",\n                  sth, ChopBlanks);\n\n  if (!imp_sth->result)\n  {\n    do_error(sth, JW_ERR_SEQUENCE, \"fetch() without execute()\" ,NULL);\n    return Nullav;\n  }\n\n  /* fix from 2.9008 */\n  imp_dbh->pmysql->net.last_errno = 0;\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch calling mysql_fetch\\n\");\n\n    if ((rc= mysql_stmt_fetch(imp_sth->stmt)))\n    {\n      if (rc == 1)\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_stmt_sqlstate(imp_sth->stmt));\n\n#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 \n      if (rc == MYSQL_DATA_TRUNCATED) {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch data truncated\\n\");\n        goto process;\n      }\n#endif\n\n      if (rc == MYSQL_NO_DATA)\n      {\n        /* Update row_num to affected_rows value */\n        imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);\n        imp_sth->fetch_done=1;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch no data\\n\");\n      }\n\n      dbd_st_finish(sth, imp_sth);\n\n      return Nullav;\n    }\n\nprocess:\n    imp_sth->currow++;\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n    num_fields=mysql_stmt_field_count(imp_sth->stmt);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\\n\",\n                    rc, num_fields);\n\n    for (\n         buffer= imp_sth->buffer,\n         fbh= imp_sth->fbh,\n         i= 0;\n         i < num_fields;\n         i++,\n         fbh++,\n         buffer++\n        )\n    {\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n      STRLEN len;\n\n      /* This is wrong, null is not being set correctly\n       * This is not the way to determine length (this would break blobs!)\n       */\n      if (fbh->is_null)\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n      else\n      {\n        /* In case of BLOB/TEXT fields we allocate only 8192 bytes\n           in dbd_describe() for data. Here we know real size of field\n           so we should increase buffer size and refetch column value\n        */\n        if (fbh->length > buffer->buffer_length || fbh->error)\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n              \"\\t\\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\\n\",\n              i, fbh->length, fbh->error);\n\n          Renew(fbh->data, fbh->length, char);\n          buffer->buffer_length= fbh->length;\n          buffer->buffer= (char *) fbh->data;\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tbefore buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n\n          /*TODO: Use offset instead of 0 to fetch only remain part of data*/\n          if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))\n            do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                     mysql_stmt_error(imp_sth->stmt),\n                     mysql_stmt_sqlstate(imp_sth->stmt));\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tafter buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n        }\n\n        /* This does look a lot like Georg's PHP driver doesn't it?  --Brian */\n        /* Credit due to Georg - mysqli_api.c  ;) --PMG */\n        switch (buffer->buffer_type) {\n        case MYSQL_TYPE_DOUBLE:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch double data %f\\n\", fbh->ddata);\n          sv_setnv(sv, fbh->ddata);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch int data %\"IVdf\", unsigned? %d\\n\",\n                          fbh->ldata, buffer->is_unsigned);\n          if (buffer->is_unsigned)\n            sv_setuv(sv, fbh->ldata);\n          else\n            sv_setiv(sv, fbh->ldata);\n\n          break;\n\n        case MYSQL_TYPE_BIT:\n          sv_setpvn(sv, fbh->data, fbh->length);\n\n          break;\n\n        default:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tERROR IN st_fetch_string\");\n          len= fbh->length;\n\t  /* ChopBlanks server-side prepared statement */\n          if (ChopBlanks)\n          {\n            /* \n              see bottom of:\n              http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html\n            */\n            if (fbh->charsetnr != 63)\n              while (len && fbh->data[len-1] == ' ') { --len; }\n          }\n\t  /* END OF ChopBlanks */\n\n          sv_setpvn(sv, fbh->data, len);\n\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION \n  /* SHOW COLLATION WHERE Id = 63; -- 63 == charset binary, collation binary */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fbh->charsetnr != 63)\n#else\n\tif ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && !(fbh->flags & BINARY_FLAG))\n#endif\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n\n        }\n\n      }\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n\n    return av;\n  }\n  else\n  {\n#endif\n\n    imp_sth->currow++;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    {\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch result set details\\n\");\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\timp_sth->result=%p\\n\", imp_sth->result);\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_fields=%u\\n\",\n                    mysql_num_fields(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_rows=%llu\\n\",\n                    mysql_num_rows(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_affected_rows=%llu\\n\",\n                    mysql_affected_rows(imp_dbh->pmysql));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch for %p, currow= %d\\n\",\n                    sth,imp_sth->currow);\n    }\n\n    if (!(cols= mysql_fetch_row(imp_sth->result)))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch, no more rows to fetch\");\n      }\n      if (mysql_errno(imp_dbh->pmysql))\n        do_error(sth, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql),\n                 mysql_sqlstate(imp_dbh->pmysql));\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (!mysql_more_results(svsock))\n#endif\n        dbd_st_finish(sth, imp_sth);\n      return Nullav;\n    }\n\n    num_fields= mysql_num_fields(imp_sth->result);\n    fields= mysql_fetch_fields(imp_sth->result);\n    lengths= mysql_fetch_lengths(imp_sth->result);\n\n    if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)\n    {\n      av_length= av_len(av)+1;\n\n      if (av_length != num_fields)              /* Resize array if necessary */\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\\n\",\n                                   av_length, num_fields);\n\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, result fields(%d)\\n\",\n                                   DBIc_NUM_FIELDS(imp_sth));\n\n        av_readonly = SvREADONLY(av);\n\n        if (av_readonly)\n          SvREADONLY_off( av );              /* DBI sets this readonly */\n\n        while (av_length < num_fields)\n        {\n          av_store(av, av_length++, newSV(0));\n        }\n\n        while (av_length > num_fields)\n        {\n          SvREFCNT_dec(av_pop(av));\n          av_length--;\n        }\n        if (av_readonly)\n          SvREADONLY_on(av);\n      }\n    }\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n\n    for (i= 0;  i < num_fields; ++i)\n    {\n      char *col= cols[i];\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n\n      if (col)\n      {\n        STRLEN len= lengths[i];\n        if (ChopBlanks)\n        {\n          while (len && col[len-1] == ' ')\n          {\t--len; }\n        }\n\n        /* Set string value returned from mysql server */\n        sv_setpvn(sv, col, len);\n\n        switch (mysql_to_perl_type(fields[i].type)) {\n        case MYSQL_TYPE_DOUBLE:\n          /* Coerce to dobule and set scalar as NV */\n          (void) SvNV(sv);\n          SvNOK_only(sv);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          /* Coerce to integer and set scalar as UV resp. IV */\n          if (fields[i].flags & UNSIGNED_FLAG)\n          {\n            (void) SvUV(sv);\n            SvIOK_only_UV(sv);\n          }\n          else\n          {\n            (void) SvIV(sv);\n            SvIOK_only(sv);\n          }\n          break;\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n        case MYSQL_TYPE_BIT:\n          /* Let it as binary string */\n          break;\n#endif\n\n        default:\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fields[i].charsetnr != 63)\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n        }\n      }\n      else\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n    return av;\n\n#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION\n  }\n#endif\n\n}", "func_src_after": "dbd_st_fetch(SV *sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  int num_fields, ChopBlanks, i, rc;\n  unsigned long *lengths;\n  AV *av;\n  int av_length, av_readonly;\n  MYSQL_ROW cols;\n  D_imp_dbh_from_sth;\n  MYSQL* svsock= imp_dbh->pmysql;\n  imp_sth_fbh_t *fbh;\n  D_imp_xxh(sth);\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  MYSQL_BIND *buffer;\n#endif\n  MYSQL_FIELD *fields;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t-> dbd_st_fetch\\n\");\n\n#if MYSQL_ASYNC\n  if(imp_dbh->async_query_in_flight) {\n      if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {\n        return Nullav;\n      }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (!DBIc_ACTIVE(imp_sth) )\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"no statement executing\\n\",NULL);\n      return Nullav;\n    }\n\n    if (imp_sth->fetch_done)\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"fetch() but fetch already done\",NULL);\n      return Nullav;\n    }\n\n    if (!imp_sth->done_desc)\n    {\n      if (!dbd_describe(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE, \"Error while describe result set.\",\n                 NULL);\n        return Nullav;\n      }\n    }\n  }\n#endif\n\n  ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tdbd_st_fetch for %p, chopblanks %d\\n\",\n                  sth, ChopBlanks);\n\n  if (!imp_sth->result)\n  {\n    do_error(sth, JW_ERR_SEQUENCE, \"fetch() without execute()\" ,NULL);\n    return Nullav;\n  }\n\n  /* fix from 2.9008 */\n  imp_dbh->pmysql->net.last_errno = 0;\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch calling mysql_fetch\\n\");\n\n    if ((rc= mysql_stmt_fetch(imp_sth->stmt)))\n    {\n      if (rc == 1)\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_stmt_sqlstate(imp_sth->stmt));\n\n#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 \n      if (rc == MYSQL_DATA_TRUNCATED) {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch data truncated\\n\");\n        goto process;\n      }\n#endif\n\n      if (rc == MYSQL_NO_DATA)\n      {\n        /* Update row_num to affected_rows value */\n        imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);\n        imp_sth->fetch_done=1;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch no data\\n\");\n      }\n\n      dbd_st_finish(sth, imp_sth);\n\n      return Nullav;\n    }\n\nprocess:\n    imp_sth->currow++;\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n    num_fields=mysql_stmt_field_count(imp_sth->stmt);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\\n\",\n                    rc, num_fields);\n\n    for (\n         buffer= imp_sth->buffer,\n         fbh= imp_sth->fbh,\n         i= 0;\n         i < num_fields;\n         i++,\n         fbh++,\n         buffer++\n        )\n    {\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n      STRLEN len;\n\n      /* This is wrong, null is not being set correctly\n       * This is not the way to determine length (this would break blobs!)\n       */\n      if (fbh->is_null)\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n      else\n      {\n        /* In case of BLOB/TEXT fields we allocate only 8192 bytes\n           in dbd_describe() for data. Here we know real size of field\n           so we should increase buffer size and refetch column value\n        */\n        if (fbh->length > buffer->buffer_length || fbh->error)\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n              \"\\t\\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\\n\",\n              i, fbh->length, fbh->error);\n\n          Renew(fbh->data, fbh->length, char);\n          buffer->buffer_length= fbh->length;\n          buffer->buffer= (char *) fbh->data;\n          imp_sth->stmt->bind[i].buffer_length = fbh->length;\n          imp_sth->stmt->bind[i].buffer = (char *)fbh->data;\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tbefore buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n\n          /*TODO: Use offset instead of 0 to fetch only remain part of data*/\n          if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))\n            do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                     mysql_stmt_error(imp_sth->stmt),\n                     mysql_stmt_sqlstate(imp_sth->stmt));\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tafter buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n        }\n\n        /* This does look a lot like Georg's PHP driver doesn't it?  --Brian */\n        /* Credit due to Georg - mysqli_api.c  ;) --PMG */\n        switch (buffer->buffer_type) {\n        case MYSQL_TYPE_DOUBLE:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch double data %f\\n\", fbh->ddata);\n          sv_setnv(sv, fbh->ddata);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch int data %\"IVdf\", unsigned? %d\\n\",\n                          fbh->ldata, buffer->is_unsigned);\n          if (buffer->is_unsigned)\n            sv_setuv(sv, fbh->ldata);\n          else\n            sv_setiv(sv, fbh->ldata);\n\n          break;\n\n        case MYSQL_TYPE_BIT:\n          sv_setpvn(sv, fbh->data, fbh->length);\n\n          break;\n\n        default:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tERROR IN st_fetch_string\");\n          len= fbh->length;\n\t  /* ChopBlanks server-side prepared statement */\n          if (ChopBlanks)\n          {\n            /* \n              see bottom of:\n              http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html\n            */\n            if (fbh->charsetnr != 63)\n              while (len && fbh->data[len-1] == ' ') { --len; }\n          }\n\t  /* END OF ChopBlanks */\n\n          sv_setpvn(sv, fbh->data, len);\n\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION \n  /* SHOW COLLATION WHERE Id = 63; -- 63 == charset binary, collation binary */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fbh->charsetnr != 63)\n#else\n\tif ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && !(fbh->flags & BINARY_FLAG))\n#endif\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n\n        }\n\n      }\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n\n    return av;\n  }\n  else\n  {\n#endif\n\n    imp_sth->currow++;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    {\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch result set details\\n\");\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\timp_sth->result=%p\\n\", imp_sth->result);\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_fields=%u\\n\",\n                    mysql_num_fields(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_rows=%llu\\n\",\n                    mysql_num_rows(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_affected_rows=%llu\\n\",\n                    mysql_affected_rows(imp_dbh->pmysql));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch for %p, currow= %d\\n\",\n                    sth,imp_sth->currow);\n    }\n\n    if (!(cols= mysql_fetch_row(imp_sth->result)))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch, no more rows to fetch\");\n      }\n      if (mysql_errno(imp_dbh->pmysql))\n        do_error(sth, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql),\n                 mysql_sqlstate(imp_dbh->pmysql));\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (!mysql_more_results(svsock))\n#endif\n        dbd_st_finish(sth, imp_sth);\n      return Nullav;\n    }\n\n    num_fields= mysql_num_fields(imp_sth->result);\n    fields= mysql_fetch_fields(imp_sth->result);\n    lengths= mysql_fetch_lengths(imp_sth->result);\n\n    if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)\n    {\n      av_length= av_len(av)+1;\n\n      if (av_length != num_fields)              /* Resize array if necessary */\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\\n\",\n                                   av_length, num_fields);\n\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, result fields(%d)\\n\",\n                                   DBIc_NUM_FIELDS(imp_sth));\n\n        av_readonly = SvREADONLY(av);\n\n        if (av_readonly)\n          SvREADONLY_off( av );              /* DBI sets this readonly */\n\n        while (av_length < num_fields)\n        {\n          av_store(av, av_length++, newSV(0));\n        }\n\n        while (av_length > num_fields)\n        {\n          SvREFCNT_dec(av_pop(av));\n          av_length--;\n        }\n        if (av_readonly)\n          SvREADONLY_on(av);\n      }\n    }\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n\n    for (i= 0;  i < num_fields; ++i)\n    {\n      char *col= cols[i];\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n\n      if (col)\n      {\n        STRLEN len= lengths[i];\n        if (ChopBlanks)\n        {\n          while (len && col[len-1] == ' ')\n          {\t--len; }\n        }\n\n        /* Set string value returned from mysql server */\n        sv_setpvn(sv, col, len);\n\n        switch (mysql_to_perl_type(fields[i].type)) {\n        case MYSQL_TYPE_DOUBLE:\n          /* Coerce to dobule and set scalar as NV */\n          (void) SvNV(sv);\n          SvNOK_only(sv);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          /* Coerce to integer and set scalar as UV resp. IV */\n          if (fields[i].flags & UNSIGNED_FLAG)\n          {\n            (void) SvUV(sv);\n            SvIOK_only_UV(sv);\n          }\n          else\n          {\n            (void) SvIV(sv);\n            SvIOK_only(sv);\n          }\n          break;\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n        case MYSQL_TYPE_BIT:\n          /* Let it as binary string */\n          break;\n#endif\n\n        default:\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fields[i].charsetnr != 63)\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n        }\n      }\n      else\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n    return av;\n\n#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION\n  }\n#endif\n\n}", "line_changes": {"deleted": [], "added": [{"line_no": 150, "char_start": 4222, "char_end": 4284, "line": "          imp_sth->stmt->bind[i].buffer_length = fbh->length;\n"}, {"line_no": 151, "char_start": 4284, "char_end": 4345, "line": "          imp_sth->stmt->bind[i].buffer = (char *)fbh->data;\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 4222, "char_end": 4345, "chars": "          imp_sth->stmt->bind[i].buffer_length = fbh->length;\n          imp_sth->stmt->bind[i].buffer = (char *)fbh->data;\n"}]}, "commit_link": "github.com/perl5-dbi/DBD-mysql/commit/3619c170461a3107a258d1fd2d00ed4832adb1b1", "file_name": "dbdimp.c", "vul_type": "cwe-416"}
{"func_name": "Magick::Image::read", "func_src_before": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  // Ensure that multiple image frames were not read.\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n\n      // Destroy any extra image frames\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n    }\n  ThrowImageException;\n}", "func_src_after": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  // Ensure that multiple image frames were not read.\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n\n      // Destroy any extra image frames\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n      return;\n    }\n  ThrowImageException;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 25, "char_start": 799, "char_end": 813, "line": "      return;\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 803, "char_end": 817, "chars": "  return;\n    "}]}, "commit_link": "github.com/ImageMagick/ImageMagick/commit/8c35502217c1879cb8257c617007282eee3fe1cc", "file_name": "Magick++/lib/Image.cpp", "vul_type": "cwe-416"}
{"func_name": "sctp_do_peeloff", "func_src_before": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\t/* If there is a thread waiting on more sndbuf space for\n\t * sending on this asoc, it cannot be peeled.\n\t */\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\n\t/* An association cannot be branched off from an already peeled-off\n\t * socket, nor is this supported for tcp style sockets.\n\t */\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Create a new socket.  */\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t/* Make peeled-off sockets more like 1-1 accepted sockets.\n\t * Set the daddr and initialize id to something more random\n\t */\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}", "func_src_after": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\n\t/* Do not peel off from one netns to another one. */\n\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n\t\treturn -EINVAL;\n\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\t/* If there is a thread waiting on more sndbuf space for\n\t * sending on this asoc, it cannot be peeled.\n\t */\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\n\t/* An association cannot be branched off from an already peeled-off\n\t * socket, nor is this supported for tcp style sockets.\n\t */\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Create a new socket.  */\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t/* Make peeled-off sockets more like 1-1 accepted sockets.\n\t * Set the daddr and initialize id to something more random\n\t */\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 8, "char_start": 209, "char_end": 263, "line": "\t/* Do not peel off from one netns to another one. */\n"}, {"line_no": 9, "char_start": 263, "char_end": 317, "line": "\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n"}, {"line_no": 10, "char_start": 317, "char_end": 335, "line": "\t\treturn -EINVAL;\n"}, {"line_no": 11, "char_start": 335, "char_end": 336, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 210, "char_end": 337, "chars": "/* Do not peel off from one netns to another one. */\n\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n\t\treturn -EINVAL;\n\n\t"}]}, "commit_link": "github.com/torvalds/linux/commit/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74", "file_name": "net/sctp/socket.c", "vul_type": "cwe-416"}
{"func_name": "ap_limit_section", "func_src_before": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n\n        /* check for builtin or module registered method number */\n        methnum = ap_method_number_of(method);\n\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n            /* method has not been registered yet, but resource restriction\n             * is always checked before method handling, so register it.\n             */\n            methnum = ap_method_register(cmd->pool,\n                                         apr_pstrdup(cmd->pool, method));\n        }\n\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n\n    /* Killing two features with one function,\n     * if (tog == NULL) <Limit>, else <LimitExcept>\n     */\n    limited = tog ? ~limited : limited;\n\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n\n    cmd->limited &= limited;\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n\n    cmd->limited = old_limited;\n\n    return errmsg;\n}", "func_src_after": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n\n        /* check for builtin or module registered method number */\n        methnum = ap_method_number_of(method);\n\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n            /* method has not been registered yet, but resource restriction\n             * is always checked before method handling, so register it.\n             */\n            if (cmd->pool == cmd->temp_pool) {\n                /* In .htaccess, we can't globally register new methods. */\n                return apr_psprintf(cmd->pool, \"Could not register method '%s' \"\n                                   \"for %s from .htaccess configuration\",\n                                    method, cmd->cmd->name);\n            }\n            methnum = ap_method_register(cmd->pool,\n                                         apr_pstrdup(cmd->pool, method));\n        }\n\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n\n    /* Killing two features with one function,\n     * if (tog == NULL) <Limit>, else <LimitExcept>\n     */\n    limited = tog ? ~limited : limited;\n\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n\n    cmd->limited &= limited;\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n\n    cmd->limited = old_limited;\n\n    return errmsg;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 36, "char_start": 1227, "char_end": 1274, "line": "            if (cmd->pool == cmd->temp_pool) {\n"}, {"line_no": 37, "char_start": 1274, "char_end": 1350, "line": "                /* In .htaccess, we can't globally register new methods. */\n"}, {"line_no": 38, "char_start": 1350, "char_end": 1431, "line": "                return apr_psprintf(cmd->pool, \"Could not register method '%s' \"\n"}, {"line_no": 39, "char_start": 1431, "char_end": 1505, "line": "                                   \"for %s from .htaccess configuration\",\n"}, {"line_no": 40, "char_start": 1505, "char_end": 1566, "line": "                                    method, cmd->cmd->name);\n"}, {"line_no": 41, "char_start": 1566, "char_end": 1580, "line": "            }\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1239, "char_end": 1592, "chars": "if (cmd->pool == cmd->temp_pool) {\n                /* In .htaccess, we can't globally register new methods. */\n                return apr_psprintf(cmd->pool, \"Could not register method '%s' \"\n                                   \"for %s from .htaccess configuration\",\n                                    method, cmd->cmd->name);\n            }\n            "}]}, "commit_link": "github.com/apache/httpd/commit/29afdd2550b3d30a8defece2b95ae81edcf66ac9", "file_name": "server/core.c", "vul_type": "cwe-416"}
{"func_name": "do_mq_notify", "func_src_before": "static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct sock *sock;\n\tstruct inode *inode;\n\tstruct mqueue_inode_info *info;\n\tstruct sk_buff *nc;\n\n\taudit_mq_notify(mqdes, notification);\n\n\tnc = NULL;\n\tsock = NULL;\n\tif (notification != NULL) {\n\t\tif (unlikely(notification->sigev_notify != SIGEV_NONE &&\n\t\t\t     notification->sigev_notify != SIGEV_SIGNAL &&\n\t\t\t     notification->sigev_notify != SIGEV_THREAD))\n\t\t\treturn -EINVAL;\n\t\tif (notification->sigev_notify == SIGEV_SIGNAL &&\n\t\t\t!valid_signal(notification->sigev_signo)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (notification->sigev_notify == SIGEV_THREAD) {\n\t\t\tlong timeo;\n\n\t\t\t/* create the notify skb */\n\t\t\tnc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);\n\t\t\tif (!nc) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (copy_from_user(nc->data,\n\t\t\t\t\tnotification->sigev_value.sival_ptr,\n\t\t\t\t\tNOTIFY_COOKIE_LEN)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* TODO: add a header? */\n\t\t\tskb_put(nc, NOTIFY_COOKIE_LEN);\n\t\t\t/* and attach it to the socket */\nretry:\n\t\t\tf = fdget(notification->sigev_signo);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsock = netlink_getsockbyfilp(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(sock)) {\n\t\t\t\tret = PTR_ERR(sock);\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n\t\t\tret = netlink_attachskb(sock, nc, &timeo, NULL);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto retry;\n\t\t\tif (ret) {\n\t\t\t\tsock = NULL;\n\t\t\t\tnc = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tf = fdget(mqdes);\n\tif (!f.file) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tinode = file_inode(f.file);\n\tif (unlikely(f.file->f_op != &mqueue_file_operations)) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\tinfo = MQUEUE_I(inode);\n\n\tret = 0;\n\tspin_lock(&info->lock);\n\tif (notification == NULL) {\n\t\tif (info->notify_owner == task_tgid(current)) {\n\t\t\tremove_notification(info);\n\t\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t\t}\n\t} else if (info->notify_owner != NULL) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tswitch (notification->sigev_notify) {\n\t\tcase SIGEV_NONE:\n\t\t\tinfo->notify.sigev_notify = SIGEV_NONE;\n\t\t\tbreak;\n\t\tcase SIGEV_THREAD:\n\t\t\tinfo->notify_sock = sock;\n\t\t\tinfo->notify_cookie = nc;\n\t\t\tsock = NULL;\n\t\t\tnc = NULL;\n\t\t\tinfo->notify.sigev_notify = SIGEV_THREAD;\n\t\t\tbreak;\n\t\tcase SIGEV_SIGNAL:\n\t\t\tinfo->notify.sigev_signo = notification->sigev_signo;\n\t\t\tinfo->notify.sigev_value = notification->sigev_value;\n\t\t\tinfo->notify.sigev_notify = SIGEV_SIGNAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->notify_owner = get_pid(task_tgid(current));\n\t\tinfo->notify_user_ns = get_user_ns(current_user_ns());\n\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t}\n\tspin_unlock(&info->lock);\nout_fput:\n\tfdput(f);\nout:\n\tif (sock)\n\t\tnetlink_detachskb(sock, nc);\n\telse if (nc)\n\t\tdev_kfree_skb(nc);\n\n\treturn ret;\n}", "func_src_after": "static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct sock *sock;\n\tstruct inode *inode;\n\tstruct mqueue_inode_info *info;\n\tstruct sk_buff *nc;\n\n\taudit_mq_notify(mqdes, notification);\n\n\tnc = NULL;\n\tsock = NULL;\n\tif (notification != NULL) {\n\t\tif (unlikely(notification->sigev_notify != SIGEV_NONE &&\n\t\t\t     notification->sigev_notify != SIGEV_SIGNAL &&\n\t\t\t     notification->sigev_notify != SIGEV_THREAD))\n\t\t\treturn -EINVAL;\n\t\tif (notification->sigev_notify == SIGEV_SIGNAL &&\n\t\t\t!valid_signal(notification->sigev_signo)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (notification->sigev_notify == SIGEV_THREAD) {\n\t\t\tlong timeo;\n\n\t\t\t/* create the notify skb */\n\t\t\tnc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);\n\t\t\tif (!nc) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (copy_from_user(nc->data,\n\t\t\t\t\tnotification->sigev_value.sival_ptr,\n\t\t\t\t\tNOTIFY_COOKIE_LEN)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* TODO: add a header? */\n\t\t\tskb_put(nc, NOTIFY_COOKIE_LEN);\n\t\t\t/* and attach it to the socket */\nretry:\n\t\t\tf = fdget(notification->sigev_signo);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsock = netlink_getsockbyfilp(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(sock)) {\n\t\t\t\tret = PTR_ERR(sock);\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n\t\t\tret = netlink_attachskb(sock, nc, &timeo, NULL);\n\t\t\tif (ret == 1) {\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tsock = NULL;\n\t\t\t\tnc = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tf = fdget(mqdes);\n\tif (!f.file) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tinode = file_inode(f.file);\n\tif (unlikely(f.file->f_op != &mqueue_file_operations)) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\tinfo = MQUEUE_I(inode);\n\n\tret = 0;\n\tspin_lock(&info->lock);\n\tif (notification == NULL) {\n\t\tif (info->notify_owner == task_tgid(current)) {\n\t\t\tremove_notification(info);\n\t\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t\t}\n\t} else if (info->notify_owner != NULL) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tswitch (notification->sigev_notify) {\n\t\tcase SIGEV_NONE:\n\t\t\tinfo->notify.sigev_notify = SIGEV_NONE;\n\t\t\tbreak;\n\t\tcase SIGEV_THREAD:\n\t\t\tinfo->notify_sock = sock;\n\t\t\tinfo->notify_cookie = nc;\n\t\t\tsock = NULL;\n\t\t\tnc = NULL;\n\t\t\tinfo->notify.sigev_notify = SIGEV_THREAD;\n\t\t\tbreak;\n\t\tcase SIGEV_SIGNAL:\n\t\t\tinfo->notify.sigev_signo = notification->sigev_signo;\n\t\t\tinfo->notify.sigev_value = notification->sigev_value;\n\t\t\tinfo->notify.sigev_notify = SIGEV_SIGNAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->notify_owner = get_pid(task_tgid(current));\n\t\tinfo->notify_user_ns = get_user_ns(current_user_ns());\n\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t}\n\tspin_unlock(&info->lock);\nout_fput:\n\tfdput(f);\nout:\n\tif (sock)\n\t\tnetlink_detachskb(sock, nc);\n\telse if (nc)\n\t\tdev_kfree_skb(nc);\n\n\treturn ret;\n}", "line_changes": {"deleted": [{"line_no": 58, "char_start": 1368, "char_end": 1385, "line": "\t\t\tif (ret == 1)\n"}], "added": [{"line_no": 58, "char_start": 1368, "char_end": 1387, "line": "\t\t\tif (ret == 1) {\n"}, {"line_no": 59, "char_start": 1387, "char_end": 1404, "line": "\t\t\t\tsock = NULL;\n"}, {"line_no": 61, "char_start": 1420, "char_end": 1425, "line": "\t\t\t}\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1384, "char_end": 1403, "chars": " {\n\t\t\t\tsock = NULL;"}, {"char_start": 1419, "char_end": 1424, "chars": "\n\t\t\t}"}]}, "commit_link": "github.com/torvalds/linux/commit/f991af3daabaecff34684fd51fac80319d1baad1", "file_name": "ipc/mqueue.c", "vul_type": "cwe-416"}
{"func_name": "xc2028_set_config", "func_src_before": "static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\t/*\n\t * Copy the config data.\n\t * For the firmware name, keep a local copy of the string,\n\t * in order to avoid troubles during device release.\n\t */\n\tkfree(priv->ctrl.fname);\n\tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n\tif (p->fname) {\n\t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n\t\tif (priv->ctrl.fname == NULL)\n\t\t\trc = -ENOMEM;\n\t}\n\n\t/*\n\t * If firmware name changed, frees firmware. As free_firmware will\n\t * reset the status to NO_FIRMWARE, this forces a new request_firmware\n\t */\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}", "func_src_after": "static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\t/*\n\t * Copy the config data.\n\t * For the firmware name, keep a local copy of the string,\n\t * in order to avoid troubles during device release.\n\t */\n\tkfree(priv->ctrl.fname);\n\tpriv->ctrl.fname = NULL;\n\tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n\tif (p->fname) {\n\t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n\t\tif (priv->ctrl.fname == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * If firmware name changed, frees firmware. As free_firmware will\n\t * reset the status to NO_FIRMWARE, this forces a new request_firmware\n\t */\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}", "line_changes": {"deleted": [{"line_no": 21, "char_start": 572, "char_end": 589, "line": "\t\t\trc = -ENOMEM;\n"}], "added": [{"line_no": 17, "char_start": 426, "char_end": 452, "line": "\tpriv->ctrl.fname = NULL;\n"}, {"line_no": 22, "char_start": 598, "char_end": 617, "line": "\t\t\treturn -ENOMEM;\n"}]}, "char_changes": {"deleted": [{"char_start": 576, "char_end": 579, "chars": "c ="}], "added": [{"char_start": 427, "char_end": 453, "chars": "priv->ctrl.fname = NULL;\n\t"}, {"char_start": 602, "char_end": 607, "chars": "eturn"}]}, "commit_link": "github.com/torvalds/linux/commit/8dfbcc4351a0b6d2f2d77f367552f48ffefafe18", "file_name": "drivers/media/tuners/tuner-xc2028.c", "vul_type": "cwe-416"}
{"func_name": "snd_pcm_period_elapsed", "func_src_before": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n}", "func_src_after": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n}", "line_changes": {"deleted": [{"line_no": 20, "char_start": 463, "char_end": 516, "line": "\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n"}], "added": [{"line_no": 21, "char_start": 511, "char_end": 564, "line": "\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n"}]}, "char_changes": {"deleted": [{"char_start": 513, "char_end": 561, "chars": ");\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN"}], "added": [{"char_start": 464, "char_end": 512, "chars": "kill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n\t"}]}, "commit_link": "github.com/torvalds/linux/commit/3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4", "file_name": "sound/core/pcm_lib.c", "vul_type": "cwe-416"}
{"func_name": "wwunpack", "func_src_before": "int wwunpack(uint8_t *exe, uint32_t exesz, uint8_t *wwsect, struct cli_exe_section *sects, uint16_t scount, uint32_t pe, int desc) {\n  uint8_t *structs = wwsect + 0x2a1, *compd, *ccur, *unpd, *ucur, bc;\n  uint32_t src, srcend, szd, bt, bits;\n  int error=0, i;\n\n  cli_dbgmsg(\"in wwunpack\\n\");\n  while (1) {\n    if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, structs, 17)) {\n      cli_dbgmsg(\"WWPack: Array of structs out of section\\n\");\n      break;\n    }\n    src = sects[scount].rva - cli_readint32(structs); /* src delta / dst delta - not used / dwords / end of src */\n    structs+=8;\n    szd = cli_readint32(structs) * 4;\n    structs+=4;\n    srcend = cli_readint32(structs);\n    structs+=4;\n\n    unpd = ucur = exe+src+srcend+4-szd;\n    if (!szd || !CLI_ISCONTAINED(exe, exesz, unpd, szd)) {\n      cli_dbgmsg(\"WWPack: Compressed data out of file\\n\");\n      break;\n    }\n    cli_dbgmsg(\"WWP: src: %x, szd: %x, srcend: %x - %x\\n\", src, szd, srcend, srcend+4-szd);\n    if (!(compd = cli_malloc(szd))) {\n        cli_dbgmsg(\"WWPack: Unable to allocate memory for compd\\n\");\n        break;\n    }\n    memcpy(compd, unpd, szd);\n    memset(unpd, -1, szd); /*FIXME*/\n    ccur=compd;\n    \n    RESEED;\n    while(!error) {\n      uint32_t backbytes, backsize;\n      uint8_t saved;\n\n      BIT;\n      if (!bits) { /* BYTE copy */\n\tif(ccur-compd>=szd || !CLI_ISCONTAINED(exe, exesz, ucur, 1))\n\t  error=1;\n\telse\n\t  *ucur++=*ccur++;\n\tcontinue;\n      }\n\n      BITS(2);\n      if(bits==3) { /* WORD backcopy */\n\tuint8_t shifted, subbed = 31;\n\tBITS(2);\n\tshifted = bits + 5;\n\tif(bits>=2) {\n\t  shifted++;\n\t  subbed += 0x80;\n\t}\n\tbackbytes = (1<<shifted)-subbed; /* 1h, 21h, 61h, 161h */\n\tBITS(shifted); /* 5, 6, 8, 9 */\n\tif(error || bits == 0x1ff) break;\n\tbackbytes+=bits;\n\tif(!CLI_ISCONTAINED(exe, exesz, ucur, 2) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, 2)) {\n\t  error=1;\n\t} else {\n\t  ucur[0]=*(ucur-backbytes);\n\t  ucur[1]=*(ucur-backbytes+1);\n\t  ucur+=2;\n\t}\n\tcontinue;\n      }\n\n      /* BLOCK backcopy */\n      saved = bits; /* cmp al, 1 / pushf */\n\n      BITS(3);\n      if (bits<6) {\n\tbackbytes = bits;\n\tswitch(bits) {\n\tcase 4: /* 10,11 */\n\t  backbytes++;\n\tcase 3: /* 8,9 */\n\t  BIT;\n\t  backbytes+=bits;\n\tcase 0:\tcase 1:\tcase 2: /* 5,6,7 */\n\t  backbytes+=5;\n\t  break;\n\tcase 5: /* 12 */\n\t  backbytes=12;\n\t  break;\n\t}\n\tBITS(backbytes);\n\tbits+=(1<<backbytes)-31;\n      } else if(bits==6) {\n\tBITS(0x0e);\n\tbits+=0x1fe1;\n      } else {\n\tBITS(0x0f);\n\tbits+=0x5fe1;\n      }\n\n      backbytes = bits;\n\n      /* popf / jb */\n      if (!saved) {\n\tBIT;\n\tif(!bits) {\n\t  BIT;\n\t  bits+=5;\n\t} else {\n\t  BITS(3);\n\t  if(bits) {\n\t    bits+=6;\n\t  } else {\n\t    BITS(4);\n\t    if(bits) {\n\t      bits+=13;\n\t    } else {\n\t      uint8_t cnt = 4;\n\t      uint16_t shifted = 0x0d;\n\t      \n\t      do {\n\t\tif(cnt==7) { cnt = 0x0e; shifted = 0; break; }\n\t\tshifted=((shifted+2)<<1)-1;\n\t\tBIT;\n\t\tcnt++;\n\t      } while(!bits);\n\t      BITS(cnt);\n\t      bits+=shifted;\n\t    }\n\t  }\n\t}\n\tbacksize = bits;\n      } else {\n\tbacksize = saved+2;\n      }\n\n      if(!CLI_ISCONTAINED(exe, exesz, ucur, backsize) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, backsize)) error=1;\n      else while(backsize--) {\n\t*ucur=*(ucur-backbytes);\n\tucur++;\n      }\n    }\n    free(compd);\n    if(error) {\n      cli_dbgmsg(\"WWPack: decompression error\\n\");\n      break;\n    }\n    if (error || !*structs++) break;\n  }\n\n  if(!error) {\n    if (pe+6 > exesz || pe+7 > exesz || pe+0x28 > exesz ||\n\t\tpe+0x50 > exesz || pe+0x14 > exesz) \n\treturn CL_EFORMAT;\n    exe[pe+6]=(uint8_t)scount;\n    exe[pe+7]=(uint8_t)(scount>>8);\n    cli_writeint32(&exe[pe+0x28], cli_readint32(wwsect+0x295)+sects[scount].rva+0x299);\n    cli_writeint32(&exe[pe+0x50], cli_readint32(&exe[pe+0x50])-sects[scount].vsz);\n\n    structs = &exe[(0xffff&cli_readint32(&exe[pe+0x14]))+pe+0x18];\n    for(i=0 ; i<scount ; i++) {\n\t  if (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t    cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t    return CL_EFORMAT;\n\t  }\n\n      cli_writeint32(structs+8, sects[i].vsz);\n      cli_writeint32(structs+12, sects[i].rva);\n      cli_writeint32(structs+16, sects[i].vsz);\n      cli_writeint32(structs+20, sects[i].rva);\n      structs+=0x28;\n    }\n\tif (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t  cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t  return CL_EFORMAT;\n\t}\n\n    memset(structs, 0, 0x28);\n    error = (uint32_t)cli_writen(desc, exe, exesz)!=exesz;\n  }\n  return error;\n}", "func_src_after": "int wwunpack(uint8_t *exe, uint32_t exesz, uint8_t *wwsect, struct cli_exe_section *sects, uint16_t scount, uint32_t pe, int desc) {\n  uint8_t *structs = wwsect + 0x2a1, *compd, *ccur, *unpd, *ucur, bc;\n  uint32_t src, srcend, szd, bt, bits;\n  int error=0, i;\n\n  cli_dbgmsg(\"in wwunpack\\n\");\n  while (1) {\n    if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, structs, 17)) {\n      cli_dbgmsg(\"WWPack: Array of structs out of section\\n\");\n      break;\n    }\n    src = sects[scount].rva - cli_readint32(structs); /* src delta / dst delta - not used / dwords / end of src */\n    structs+=8;\n    szd = cli_readint32(structs) * 4;\n    structs+=4;\n    srcend = cli_readint32(structs);\n    structs+=4;\n\n    unpd = ucur = exe+src+srcend+4-szd;\n    if (!szd || !CLI_ISCONTAINED(exe, exesz, unpd, szd)) {\n      cli_dbgmsg(\"WWPack: Compressed data out of file\\n\");\n      break;\n    }\n    cli_dbgmsg(\"WWP: src: %x, szd: %x, srcend: %x - %x\\n\", src, szd, srcend, srcend+4-szd);\n    if (!(compd = cli_malloc(szd))) {\n        cli_dbgmsg(\"WWPack: Unable to allocate memory for compd\\n\");\n        break;\n    }\n    memcpy(compd, unpd, szd);\n    memset(unpd, -1, szd); /*FIXME*/\n    ccur=compd;\n    \n    RESEED;\n    while(!error) {\n      uint32_t backbytes, backsize;\n      uint8_t saved;\n\n      BIT;\n      if (!bits) { /* BYTE copy */\n\tif(ccur-compd>=szd || !CLI_ISCONTAINED(exe, exesz, ucur, 1))\n\t  error=1;\n\telse\n\t  *ucur++=*ccur++;\n\tcontinue;\n      }\n\n      BITS(2);\n      if(bits==3) { /* WORD backcopy */\n\tuint8_t shifted, subbed = 31;\n\tBITS(2);\n\tshifted = bits + 5;\n\tif(bits>=2) {\n\t  shifted++;\n\t  subbed += 0x80;\n\t}\n\tbackbytes = (1<<shifted)-subbed; /* 1h, 21h, 61h, 161h */\n\tBITS(shifted); /* 5, 6, 8, 9 */\n\tif(error || bits == 0x1ff) break;\n\tbackbytes+=bits;\n\tif(!CLI_ISCONTAINED(exe, exesz, ucur, 2) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, 2)) {\n\t  error=1;\n\t} else {\n\t  ucur[0]=*(ucur-backbytes);\n\t  ucur[1]=*(ucur-backbytes+1);\n\t  ucur+=2;\n\t}\n\tcontinue;\n      }\n\n      /* BLOCK backcopy */\n      saved = bits; /* cmp al, 1 / pushf */\n\n      BITS(3);\n      if (bits<6) {\n\tbackbytes = bits;\n\tswitch(bits) {\n\tcase 4: /* 10,11 */\n\t  backbytes++;\n\tcase 3: /* 8,9 */\n\t  BIT;\n\t  backbytes+=bits;\n\tcase 0:\tcase 1:\tcase 2: /* 5,6,7 */\n\t  backbytes+=5;\n\t  break;\n\tcase 5: /* 12 */\n\t  backbytes=12;\n\t  break;\n\t}\n\tBITS(backbytes);\n\tbits+=(1<<backbytes)-31;\n      } else if(bits==6) {\n\tBITS(0x0e);\n\tbits+=0x1fe1;\n      } else {\n\tBITS(0x0f);\n\tbits+=0x5fe1;\n      }\n\n      backbytes = bits;\n\n      /* popf / jb */\n      if (!saved) {\n\tBIT;\n\tif(!bits) {\n\t  BIT;\n\t  bits+=5;\n\t} else {\n\t  BITS(3);\n\t  if(bits) {\n\t    bits+=6;\n\t  } else {\n\t    BITS(4);\n\t    if(bits) {\n\t      bits+=13;\n\t    } else {\n\t      uint8_t cnt = 4;\n\t      uint16_t shifted = 0x0d;\n\t      \n\t      do {\n\t\tif(cnt==7) { cnt = 0x0e; shifted = 0; break; }\n\t\tshifted=((shifted+2)<<1)-1;\n\t\tBIT;\n\t\tcnt++;\n\t      } while(!bits);\n\t      BITS(cnt);\n\t      bits+=shifted;\n\t    }\n\t  }\n\t}\n\tbacksize = bits;\n      } else {\n\tbacksize = saved+2;\n      }\n\n      if(!CLI_ISCONTAINED(exe, exesz, ucur, backsize) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, backsize)) error=1;\n      else while(backsize--) {\n\t*ucur=*(ucur-backbytes);\n\tucur++;\n      }\n    }\n    free(compd);\n    if(error) {\n      cli_dbgmsg(\"WWPack: decompression error\\n\");\n      break;\n    }\n    if (error || !*structs++) break;\n  }\n\n  if(!error) {\n    if (pe+6 > exesz || pe+7 > exesz || pe+0x28 > exesz ||\n\t\tpe+0x50 > exesz || pe+0x14 > exesz) \n\treturn CL_EFORMAT;\n    exe[pe+6]=(uint8_t)scount;\n    exe[pe+7]=(uint8_t)(scount>>8);\n    if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295, 4) ||\n        !CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295+sects[scount].rva, 4) ||\n        !CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295+sects[scount].rva+0x299, 4)) {\n        cli_dbgmsg(\"WWPack: unpack memory address out of bounds.\\n\");\n        return CL_EFORMAT;\n    }\n    cli_writeint32(&exe[pe+0x28], cli_readint32(wwsect+0x295)+sects[scount].rva+0x299);\n    cli_writeint32(&exe[pe+0x50], cli_readint32(&exe[pe+0x50])-sects[scount].vsz);\n\n    structs = &exe[(0xffff&cli_readint32(&exe[pe+0x14]))+pe+0x18];\n    for(i=0 ; i<scount ; i++) {\n\t  if (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t    cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t    return CL_EFORMAT;\n\t  }\n\n      cli_writeint32(structs+8, sects[i].vsz);\n      cli_writeint32(structs+12, sects[i].rva);\n      cli_writeint32(structs+16, sects[i].vsz);\n      cli_writeint32(structs+20, sects[i].rva);\n      structs+=0x28;\n    }\n\tif (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t  cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t  return CL_EFORMAT;\n\t}\n\n    memset(structs, 0, 0x28);\n    error = (uint32_t)cli_writen(desc, exe, exesz)!=exesz;\n  }\n  return error;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 155, "char_start": 3541, "char_end": 3613, "line": "    if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295, 4) ||\n"}, {"line_no": 156, "char_start": 3613, "char_end": 3703, "line": "        !CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295+sects[scount].rva, 4) ||\n"}, {"line_no": 157, "char_start": 3703, "char_end": 3799, "line": "        !CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295+sects[scount].rva+0x299, 4)) {\n"}, {"line_no": 158, "char_start": 3799, "char_end": 3869, "line": "        cli_dbgmsg(\"WWPack: unpack memory address out of bounds.\\n\");\n"}, {"line_no": 159, "char_start": 3869, "char_end": 3896, "line": "        return CL_EFORMAT;\n"}, {"line_no": 160, "char_start": 3896, "char_end": 3902, "line": "    }\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 3545, "char_end": 3906, "chars": "if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295, 4) ||\n        !CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295+sects[scount].rva, 4) ||\n        !CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295+sects[scount].rva+0x299, 4)) {\n        cli_dbgmsg(\"WWPack: unpack memory address out of bounds.\\n\");\n        return CL_EFORMAT;\n    }\n    "}]}, "commit_link": "github.com/vrtadmin/clamav-devel/commit/dfc00cd3301a42b571454b51a6102eecf58407bc", "file_name": "libclamav/wwunpack.c", "vul_type": "cwe-416"}
{"func_name": "__ext4_journal_stop", "func_src_before": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\n\tif (!handle->h_transaction) {\n\t\terr = jbd2_journal_stop(handle);\n\t\treturn handle->h_err ? handle->h_err : err;\n\t}\n\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = jbd2_journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}", "func_src_after": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\n\terr = handle->h_err;\n\tif (!handle->h_transaction) {\n\t\trc = jbd2_journal_stop(handle);\n\t\treturn err ? err : rc;\n\t}\n\n\tsb = handle->h_transaction->t_journal->j_private;\n\trc = jbd2_journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}", "line_changes": {"deleted": [{"line_no": 13, "char_start": 239, "char_end": 274, "line": "\t\terr = jbd2_journal_stop(handle);\n"}, {"line_no": 14, "char_start": 274, "char_end": 320, "line": "\t\treturn handle->h_err ? handle->h_err : err;\n"}, {"line_no": 18, "char_start": 375, "char_end": 397, "line": "\terr = handle->h_err;\n"}], "added": [{"line_no": 12, "char_start": 208, "char_end": 230, "line": "\terr = handle->h_err;\n"}, {"line_no": 14, "char_start": 261, "char_end": 295, "line": "\t\trc = jbd2_journal_stop(handle);\n"}, {"line_no": 15, "char_start": 295, "char_end": 320, "line": "\t\treturn err ? err : rc;\n"}]}, "char_changes": {"deleted": [{"char_start": 241, "char_end": 242, "chars": "e"}, {"char_start": 243, "char_end": 244, "chars": "r"}, {"char_start": 283, "char_end": 293, "chars": "handle->h_"}, {"char_start": 299, "char_end": 309, "chars": "handle->h_"}, {"char_start": 315, "char_end": 316, "chars": "e"}, {"char_start": 317, "char_end": 318, "chars": "r"}, {"char_start": 373, "char_end": 395, "chars": ";\n\terr = handle->h_err"}], "added": [{"char_start": 209, "char_end": 231, "chars": "err = handle->h_err;\n\t"}, {"char_start": 264, "char_end": 265, "chars": "c"}, {"char_start": 317, "char_end": 318, "chars": "c"}]}, "commit_link": "github.com/torvalds/linux/commit/6934da9238da947628be83635e365df41064b09b", "file_name": "fs/ext4/ext4_jbd2.c", "vul_type": "cwe-416"}
{"func_name": "blk_rq_map_user_iov", "func_src_before": "int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n\tstruct iov_iter i;\n\tint ret;\n\n\tif (map_data)\n\t\tcopy = true;\n\telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\n\nunmap_rq:\n\t__blk_rq_unmap_user(bio);\n\trq->bio = NULL;\n\treturn -EINVAL;\n}", "func_src_after": "int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n\tstruct iov_iter i;\n\tint ret;\n\n\tif (!iter_is_iovec(iter))\n\t\tgoto fail;\n\n\tif (map_data)\n\t\tcopy = true;\n\telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\n\nunmap_rq:\n\t__blk_rq_unmap_user(bio);\nfail:\n\trq->bio = NULL;\n\treturn -EINVAL;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 11, "char_start": 293, "char_end": 320, "line": "\tif (!iter_is_iovec(iter))\n"}, {"line_no": 12, "char_start": 320, "char_end": 333, "line": "\t\tgoto fail;\n"}, {"line_no": 13, "char_start": 333, "char_end": 334, "line": "\n"}, {"line_no": 36, "char_start": 819, "char_end": 825, "line": "fail:\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 298, "char_end": 339, "chars": "!iter_is_iovec(iter))\n\t\tgoto fail;\n\n\tif ("}, {"char_start": 818, "char_end": 824, "chars": "\nfail:"}]}, "commit_link": "github.com/torvalds/linux/commit/a0ac402cfcdc904f9772e1762b3fda112dcc56a0", "file_name": "block/blk-map.c", "vul_type": "cwe-416"}
{"func_name": "mif_process_cmpt", "func_src_before": "static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)\n{\n\tjas_tvparser_t *tvp;\n\tmif_cmpt_t *cmpt;\n\tint id;\n\n\tcmpt = 0;\n\ttvp = 0;\n\n\tif (!(cmpt = mif_cmpt_create())) {\n\t\tgoto error;\n\t}\n\tcmpt->tlx = 0;\n\tcmpt->tly = 0;\n\tcmpt->sampperx = 0;\n\tcmpt->samppery = 0;\n\tcmpt->width = 0;\n\tcmpt->height = 0;\n\tcmpt->prec = 0;\n\tcmpt->sgnd = -1;\n\tcmpt->data = 0;\n\n\tif (!(tvp = jas_tvparser_create(buf))) {\n\t\tgoto error;\n\t}\n\twhile (!(id = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase MIF_TLX:\n\t\t\tcmpt->tlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_TLY:\n\t\t\tcmpt->tly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_WIDTH:\n\t\t\tcmpt->width = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HEIGHT:\n\t\t\tcmpt->height = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HSAMP:\n\t\t\tcmpt->sampperx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_VSAMP:\n\t\t\tcmpt->samppery = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_PREC:\n\t\t\tcmpt->prec = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_SGND:\n\t\t\tcmpt->sgnd = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_DATA:\n\t\t\tif (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tjas_tvparser_destroy(tvp);\n\tif (!cmpt->sampperx || !cmpt->samppery) {\n\t\tgoto error;\n\t}\n\tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {\n\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tif (cmpt) {\n\t\tmif_cmpt_destroy(cmpt);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\treturn -1;\n}", "func_src_after": "static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)\n{\n\tjas_tvparser_t *tvp;\n\tmif_cmpt_t *cmpt;\n\tint id;\n\n\tcmpt = 0;\n\ttvp = 0;\n\n\tif (!(cmpt = mif_cmpt_create())) {\n\t\tgoto error;\n\t}\n\tcmpt->tlx = 0;\n\tcmpt->tly = 0;\n\tcmpt->sampperx = 0;\n\tcmpt->samppery = 0;\n\tcmpt->width = 0;\n\tcmpt->height = 0;\n\tcmpt->prec = 0;\n\tcmpt->sgnd = -1;\n\tcmpt->data = 0;\n\n\tif (!(tvp = jas_tvparser_create(buf))) {\n\t\tgoto error;\n\t}\n\twhile (!(id = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase MIF_TLX:\n\t\t\tcmpt->tlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_TLY:\n\t\t\tcmpt->tly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_WIDTH:\n\t\t\tcmpt->width = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HEIGHT:\n\t\t\tcmpt->height = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HSAMP:\n\t\t\tcmpt->sampperx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_VSAMP:\n\t\t\tcmpt->samppery = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_PREC:\n\t\t\tcmpt->prec = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_SGND:\n\t\t\tcmpt->sgnd = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_DATA:\n\t\t\tif (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cmpt->sampperx || !cmpt->samppery) {\n\t\tgoto error;\n\t}\n\tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {\n\t\tgoto error;\n\t}\n\tjas_tvparser_destroy(tvp);\n\treturn 0;\n\nerror:\n\tif (cmpt) {\n\t\tmif_cmpt_destroy(cmpt);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\treturn -1;\n}", "line_changes": {"deleted": [{"line_no": 60, "char_start": 1274, "char_end": 1302, "line": "\tjas_tvparser_destroy(tvp);\n"}], "added": [{"line_no": 66, "char_start": 1401, "char_end": 1429, "line": "\tjas_tvparser_destroy(tvp);\n"}]}, "char_changes": {"deleted": [{"char_start": 1275, "char_end": 1303, "chars": "jas_tvparser_destroy(tvp);\n\t"}], "added": [{"char_start": 1400, "char_end": 1428, "chars": "\n\tjas_tvparser_destroy(tvp);"}]}, "commit_link": "github.com/mdadams/jasper/commit/df5d2867e8004e51e18b89865bc4aa69229227b3", "file_name": "src/libjasper/mif/mif_cod.c", "vul_type": "cwe-416"}
{"func_name": "onig_new_deluxe", "func_src_before": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n\n err2:\n  if (cpat != pattern) xfree(cpat);\n\n  return r;\n}", "func_src_after": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n\n  if (ci->pattern_enc != ci->target_enc) {\n    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n\n err2:\n  if (cpat != pattern) xfree(cpat);\n\n  return r;\n}", "line_changes": {"deleted": [{"line_no": 10, "char_start": 274, "char_end": 351, "line": "    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n"}, {"line_no": 11, "char_start": 351, "char_end": 392, "line": "                      &cpat, &cpat_end);\n"}, {"line_no": 12, "char_start": 392, "char_end": 418, "line": "    if (r != 0) return r;\n"}], "added": [{"line_no": 10, "char_start": 274, "char_end": 329, "line": "    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;\n"}]}, "char_changes": {"deleted": [{"char_start": 279, "char_end": 287, "chars": " = conv_"}, {"char_start": 288, "char_end": 302, "chars": "ncoding(ci->pa"}, {"char_start": 303, "char_end": 305, "chars": "te"}, {"char_start": 308, "char_end": 323, "chars": "enc, ci->target"}, {"char_start": 324, "char_end": 345, "chars": "enc, pattern, pattern"}, {"char_start": 346, "char_end": 385, "chars": "end,\n                      &cpat, &cpat"}, {"char_start": 386, "char_end": 416, "chars": "end);\n    if (r != 0) return r"}], "added": [{"char_start": 281, "char_end": 282, "chars": "u"}, {"char_start": 285, "char_end": 292, "chars": "ONIGERR"}, {"char_start": 293, "char_end": 296, "chars": "NOT"}, {"char_start": 297, "char_end": 315, "chars": "SUPPORTED_ENCODING"}, {"char_start": 316, "char_end": 327, "chars": "COMBINATION"}]}, "commit_link": "github.com/kkos/oniguruma/commit/0f7f61ed1b7b697e283e37bd2d731d0bd57adb55", "file_name": "src/regext.c", "vul_type": "cwe-416"}
{"func_name": "usb_sg_cancel", "func_src_before": "void usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\t/* shut everything down */\n\tio->status = -ECONNRESET;\n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n}", "func_src_after": "void usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status || io->count == 0) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\t/* shut everything down */\n\tio->status = -ECONNRESET;\n\tio->count++;\t\t/* Keep the request alive until we're done */\n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tio->count--;\n\tif (!io->count)\n\t\tcomplete(&io->complete);\n\tspin_unlock_irqrestore(&io->lock, flags);\n}", "line_changes": {"deleted": [{"line_no": 7, "char_start": 125, "char_end": 144, "line": "\tif (io->status) {\n"}], "added": [{"line_no": 7, "char_start": 125, "char_end": 162, "line": "\tif (io->status || io->count == 0) {\n"}, {"line_no": 13, "char_start": 274, "char_end": 335, "line": "\tio->count++;\t\t/* Keep the request alive until we're done */\n"}, {"line_no": 27, "char_start": 678, "char_end": 679, "line": "\n"}, {"line_no": 28, "char_start": 679, "char_end": 717, "line": "\tspin_lock_irqsave(&io->lock, flags);\n"}, {"line_no": 29, "char_start": 717, "char_end": 731, "line": "\tio->count--;\n"}, {"line_no": 30, "char_start": 731, "char_end": 748, "line": "\tif (!io->count)\n"}, {"line_no": 31, "char_start": 748, "char_end": 775, "line": "\t\tcomplete(&io->complete);\n"}, {"line_no": 32, "char_start": 775, "char_end": 818, "line": "\tspin_unlock_irqrestore(&io->lock, flags);\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 140, "char_end": 158, "chars": " || io->count == 0"}, {"char_start": 273, "char_end": 334, "chars": "\n\tio->count++;\t\t/* Keep the request alive until we're done */"}, {"char_start": 677, "char_end": 817, "chars": "\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tio->count--;\n\tif (!io->count)\n\t\tcomplete(&io->complete);\n\tspin_unlock_irqrestore(&io->lock, flags);"}]}, "commit_link": "github.com/torvalds/linux/commit/056ad39ee9253873522f6469c3364964a322912b", "file_name": "drivers/usb/core/message.c", "vul_type": "cwe-416"}
{"func_name": "ip4_datagram_release_cb", "func_src_before": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n\trcu_read_unlock();\n}", "func_src_after": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct dst_entry *dst;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\n\trcu_read_lock();\n\n\tdst = __sk_dst_get(sk);\n\tif (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\n\tdst = !IS_ERR(rt) ? &rt->dst : NULL;\n\tsk_dst_set(sk, dst);\n\n\trcu_read_unlock();\n}", "line_changes": {"deleted": [{"line_no": 9, "char_start": 208, "char_end": 258, "line": "\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n"}, {"line_no": 10, "char_start": 258, "char_end": 268, "line": "\t\treturn;\n"}, {"line_no": 11, "char_start": 268, "char_end": 269, "line": "\n"}, {"line_no": 20, "char_start": 591, "char_end": 609, "line": "\tif (!IS_ERR(rt))\n"}, {"line_no": 21, "char_start": 609, "char_end": 639, "line": "\t\t__sk_dst_set(sk, &rt->dst);\n"}], "added": [{"line_no": 6, "char_start": 167, "char_end": 191, "line": "\tstruct dst_entry *dst;\n"}, {"line_no": 11, "char_start": 250, "char_end": 251, "line": "\n"}, {"line_no": 12, "char_start": 251, "char_end": 276, "line": "\tdst = __sk_dst_get(sk);\n"}, {"line_no": 13, "char_start": 276, "char_end": 334, "line": "\tif (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {\n"}, {"line_no": 14, "char_start": 334, "char_end": 355, "line": "\t\trcu_read_unlock();\n"}, {"line_no": 15, "char_start": 355, "char_end": 365, "line": "\t\treturn;\n"}, {"line_no": 16, "char_start": 365, "char_end": 368, "line": "\t}\n"}, {"line_no": 24, "char_start": 672, "char_end": 673, "line": "\n"}, {"line_no": 25, "char_start": 673, "char_end": 711, "line": "\tdst = !IS_ERR(rt) ? &rt->dst : NULL;\n"}, {"line_no": 26, "char_start": 711, "char_end": 733, "line": "\tsk_dst_set(sk, dst);\n"}, {"line_no": 27, "char_start": 733, "char_end": 734, "line": "\n"}]}, "char_changes": {"deleted": [{"char_start": 209, "char_end": 212, "chars": "if "}, {"char_start": 213, "char_end": 214, "chars": "!"}, {"char_start": 235, "char_end": 237, "chars": "__"}, {"char_start": 238, "char_end": 240, "chars": "k_"}, {"char_start": 243, "char_end": 244, "chars": "_"}, {"char_start": 251, "char_end": 252, "chars": "k"}, {"char_start": 259, "char_end": 269, "chars": "\treturn;\n\n"}, {"char_start": 592, "char_end": 594, "chars": "if"}, {"char_start": 595, "char_end": 596, "chars": "("}, {"char_start": 607, "char_end": 608, "chars": ")"}, {"char_start": 610, "char_end": 613, "chars": "\t__"}, {"char_start": 628, "char_end": 633, "chars": "&rt->"}], "added": [{"char_start": 175, "char_end": 199, "chars": "dst_entry *dst;\n\tstruct "}, {"char_start": 233, "char_end": 246, "chars": "rcu_read_lock"}, {"char_start": 247, "char_end": 257, "chars": ");\n\n\tdst ="}, {"char_start": 274, "char_end": 285, "chars": ";\n\tif (!dst"}, {"char_start": 289, "char_end": 291, "chars": "!d"}, {"char_start": 292, "char_end": 307, "chars": "t->obsolete || "}, {"char_start": 310, "char_end": 317, "chars": "->ops->"}, {"char_start": 323, "char_end": 324, "chars": "d"}, {"char_start": 325, "char_end": 326, "chars": "t"}, {"char_start": 331, "char_end": 333, "chars": " {"}, {"char_start": 345, "char_end": 347, "chars": "un"}, {"char_start": 354, "char_end": 367, "chars": "\n\t\treturn;\n\t}"}, {"char_start": 672, "char_end": 673, "chars": "\n"}, {"char_start": 674, "char_end": 677, "chars": "dst"}, {"char_start": 678, "char_end": 680, "chars": "= "}, {"char_start": 691, "char_end": 710, "chars": " ? &rt->dst : NULL;"}, {"char_start": 732, "char_end": 733, "chars": "\n"}]}, "commit_link": "github.com/torvalds/linux/commit/9709674e68646cee5a24e3000b3558d25412203a", "file_name": "net/ipv4/datagram.c", "vul_type": "cwe-416"}
{"func_name": "mark_context_stack", "func_src_before": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n\n    if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n    }\n  }\n}", "func_src_after": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n  mrb_value nil;\n\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n\n    if (!mrb_immediate_p(v)) {\n      mrb_gc_mark(mrb, mrb_basic_ptr(v));\n    }\n  }\n  e = c->stend - c->stbase;\n  nil = mrb_nil_value();\n  for (; i<e; i++) {\n    c->stbase[i] = nil;\n  }\n}", "line_changes": {"deleted": [{"line_no": 14, "char_start": 323, "char_end": 372, "line": "      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n"}, {"line_no": 15, "char_start": 372, "char_end": 412, "line": "        c->stbase[i] = mrb_nil_value();\n"}, {"line_no": 16, "char_start": 412, "char_end": 420, "line": "      }\n"}, {"line_no": 17, "char_start": 420, "char_end": 433, "line": "      else {\n"}, {"line_no": 18, "char_start": 433, "char_end": 477, "line": "        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n"}, {"line_no": 19, "char_start": 477, "char_end": 485, "line": "      }\n"}], "added": [{"line_no": 5, "char_start": 84, "char_end": 101, "line": "  mrb_value nil;\n"}, {"line_no": 15, "char_start": 340, "char_end": 382, "line": "      mrb_gc_mark(mrb, mrb_basic_ptr(v));\n"}, {"line_no": 18, "char_start": 392, "char_end": 420, "line": "  e = c->stend - c->stbase;\n"}, {"line_no": 19, "char_start": 420, "char_end": 445, "line": "  nil = mrb_nil_value();\n"}, {"line_no": 20, "char_start": 445, "char_end": 466, "line": "  for (; i<e; i++) {\n"}, {"line_no": 21, "char_start": 466, "char_end": 490, "line": "    c->stbase[i] = nil;\n"}, {"line_no": 22, "char_start": 490, "char_end": 494, "line": "  }\n"}]}, "char_changes": {"deleted": [{"char_start": 329, "char_end": 331, "chars": "if"}, {"char_start": 332, "char_end": 333, "chars": "("}, {"char_start": 349, "char_end": 353, "chars": "->tt"}, {"char_start": 354, "char_end": 356, "chars": "=="}, {"char_start": 357, "char_end": 369, "chars": "MRB_TT_FREE)"}, {"char_start": 370, "char_end": 371, "chars": "{"}, {"char_start": 389, "char_end": 390, "chars": "["}, {"char_start": 391, "char_end": 392, "chars": "]"}, {"char_start": 414, "char_end": 424, "chars": "    }\n    "}, {"char_start": 427, "char_end": 430, "chars": "lse"}, {"char_start": 433, "char_end": 436, "chars": "   "}, {"char_start": 440, "char_end": 446, "chars": " mrb_g"}, {"char_start": 447, "char_end": 462, "chars": "_mark(mrb, mrb_"}, {"char_start": 466, "char_end": 477, "chars": "c_ptr(v));\n"}, {"char_start": 478, "char_end": 485, "chars": "     }\n"}, {"char_start": 486, "char_end": 490, "chars": "   }"}], "added": [{"char_start": 84, "char_end": 101, "chars": "  mrb_value nil;\n"}, {"char_start": 346, "char_end": 357, "chars": "mrb_gc_mark"}, {"char_start": 358, "char_end": 363, "chars": "mrb, "}, {"char_start": 379, "char_end": 382, "chars": ");\n"}, {"char_start": 383, "char_end": 384, "chars": " "}, {"char_start": 386, "char_end": 387, "chars": "}"}, {"char_start": 390, "char_end": 392, "chars": "}\n"}, {"char_start": 394, "char_end": 395, "chars": "e"}, {"char_start": 396, "char_end": 397, "chars": "="}, {"char_start": 398, "char_end": 406, "chars": "c->stend"}, {"char_start": 407, "char_end": 408, "chars": "-"}, {"char_start": 418, "char_end": 423, "chars": ";\n  n"}, {"char_start": 424, "char_end": 425, "chars": "l"}, {"char_start": 447, "char_end": 450, "chars": "for"}, {"char_start": 451, "char_end": 453, "chars": "(;"}, {"char_start": 454, "char_end": 458, "chars": "i<e;"}, {"char_start": 459, "char_end": 463, "chars": "i++)"}, {"char_start": 471, "char_end": 475, "chars": "->st"}, {"char_start": 478, "char_end": 480, "chars": "e["}, {"char_start": 481, "char_end": 482, "chars": "]"}, {"char_start": 483, "char_end": 484, "chars": "="}, {"char_start": 485, "char_end": 489, "chars": "nil;"}]}, "commit_link": "github.com/mruby/mruby/commit/5c114c91d4ff31859fcd84cf8bf349b737b90d99", "file_name": "src/gc.c", "vul_type": "cwe-416"}
{"func_name": "shadow_server_start", "func_src_before": "int shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\n\tif (!server)\n\t\treturn -1;\n\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\n\tserver->capture = shadow_capture_new(server);\n\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\n\t/* Bind magic:\n\t *\n\t * emtpy                 ... bind TCP all\n\t * <local path>          ... bind local (IPC)\n\t * bind-socket,<address> ... bind TCP to specified interface\n\t */\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tfree(list);\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "func_src_after": "int shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\n\tif (!server)\n\t\treturn -1;\n\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\n\tserver->capture = shadow_capture_new(server);\n\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\n\t/* Bind magic:\n\t *\n\t * emtpy                 ... bind TCP all\n\t * <local path>          ... bind local (IPC)\n\t * bind-socket,<address> ... bind TCP to specified interface\n\t */\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t{\n\t\t\t\t\tfree(list);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "line_changes": {"deleted": [{"line_no": 46, "char_start": 981, "char_end": 996, "line": "\t\t\tfree(list);\n"}], "added": [{"line_no": 49, "char_start": 1054, "char_end": 1060, "line": "\t\t\t\t{\n"}, {"line_no": 50, "char_start": 1060, "char_end": 1077, "line": "\t\t\t\t\tfree(list);\n"}, {"line_no": 52, "char_start": 1093, "char_end": 1099, "line": "\t\t\t\t}\n"}, {"line_no": 55, "char_start": 1112, "char_end": 1117, "line": "\t\t\t{\n"}, {"line_no": 56, "char_start": 1117, "char_end": 1133, "line": "\t\t\t\tfree(list);\n"}, {"line_no": 58, "char_start": 1148, "char_end": 1153, "line": "\t\t\t}\n"}]}, "char_changes": {"deleted": [{"char_start": 984, "char_end": 999, "chars": "free(list);\n\t\t\t"}], "added": [{"char_start": 1015, "char_end": 1015, "chars": ""}, {"char_start": 1054, "char_end": 1077, "chars": "\t\t\t\t{\n\t\t\t\t\tfree(list);\n"}, {"char_start": 1093, "char_end": 1099, "chars": "\t\t\t\t}\n"}, {"char_start": 1112, "char_end": 1133, "chars": "\t\t\t{\n\t\t\t\tfree(list);\n"}, {"char_start": 1147, "char_end": 1152, "chars": "\n\t\t\t}"}]}, "commit_link": "github.com/FreeRDP/FreeRDP/commit/6d86e20e1e7caaab4f0c7f89e36d32914dbccc52", "file_name": "server/shadow/shadow_server.c", "vul_type": "cwe-416"}
{"func_name": "Curl_close", "func_src_before": "CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n\n  if(!data)\n    return CURLE_OK;\n\n  Curl_expire_clear(data); /* shut off timers */\n\n  m = data->multi;\n  if(m)\n    /* This handle is still part of a multi handle, take care of this first\n       and detach this handle from there. */\n    curl_multi_remove_handle(data->multi, data);\n\n  if(data->multi_easy)\n    /* when curl_easy_perform() is used, it creates its own multi handle to\n       use and this is the one */\n    curl_multi_cleanup(data->multi_easy);\n\n  /* Destroy the timeout list that is held in the easy handle. It is\n     /normally/ done by curl_multi_remove_handle() but this is \"just in\n     case\" */\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n\n  data->magic = 0; /* force a clear AFTER the possibly enforced removal from\n                      the multi handle, since that function uses the magic\n                      field! */\n\n  if(data->state.rangestringalloc)\n    free(data->state.range);\n\n  /* freed here just in case DONE wasn't called */\n  Curl_free_request_state(data);\n\n  /* Close down all open SSL info and sessions */\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n\n  /* Cleanup possible redirect junk */\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n\n  /* this destroys the channel and we cannot use it anymore after this */\n  Curl_resolver_cleanup(data->state.resolver);\n\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n\n  /* No longer a dirty share, if it exists */\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n\n  /* destruct wildcard structures if it is needed */\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}", "func_src_after": "CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n\n  if(!data)\n    return CURLE_OK;\n\n  Curl_expire_clear(data); /* shut off timers */\n\n  m = data->multi;\n  if(m)\n    /* This handle is still part of a multi handle, take care of this first\n       and detach this handle from there. */\n    curl_multi_remove_handle(data->multi, data);\n\n  if(data->multi_easy) {\n    /* when curl_easy_perform() is used, it creates its own multi handle to\n       use and this is the one */\n    curl_multi_cleanup(data->multi_easy);\n    data->multi_easy = NULL;\n  }\n\n  /* Destroy the timeout list that is held in the easy handle. It is\n     /normally/ done by curl_multi_remove_handle() but this is \"just in\n     case\" */\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n\n  data->magic = 0; /* force a clear AFTER the possibly enforced removal from\n                      the multi handle, since that function uses the magic\n                      field! */\n\n  if(data->state.rangestringalloc)\n    free(data->state.range);\n\n  /* freed here just in case DONE wasn't called */\n  Curl_free_request_state(data);\n\n  /* Close down all open SSL info and sessions */\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n\n  /* Cleanup possible redirect junk */\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n\n  /* this destroys the channel and we cannot use it anymore after this */\n  Curl_resolver_cleanup(data->state.resolver);\n\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n\n  /* No longer a dirty share, if it exists */\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n\n  /* destruct wildcard structures if it is needed */\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}", "line_changes": {"deleted": [{"line_no": 16, "char_start": 353, "char_end": 376, "line": "  if(data->multi_easy)\n"}], "added": [{"line_no": 16, "char_start": 353, "char_end": 378, "line": "  if(data->multi_easy) {\n"}, {"line_no": 20, "char_start": 530, "char_end": 559, "line": "    data->multi_easy = NULL;\n"}, {"line_no": 21, "char_start": 559, "char_end": 563, "line": "  }\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 375, "char_end": 377, "chars": " {"}, {"char_start": 529, "char_end": 562, "chars": "\n    data->multi_easy = NULL;\n  }"}]}, "commit_link": "github.com/curl/curl/commit/81d135d67155c5295b1033679c606165d4e28f3f", "file_name": "lib/url.c", "vul_type": "cwe-416"}
{"func_name": "ExprAppendMultiKeysymList", "func_src_before": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n\n    FreeStmt((ParseCommon *) &append);\n\n    return expr;\n}", "func_src_after": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n\n    FreeStmt((ParseCommon *) append);\n\n    return expr;\n}", "line_changes": {"deleted": [{"line_no": 10, "char_start": 377, "char_end": 416, "line": "    FreeStmt((ParseCommon *) &append);\n"}], "added": [{"line_no": 10, "char_start": 377, "char_end": 415, "line": "    FreeStmt((ParseCommon *) append);\n"}]}, "char_changes": {"deleted": [{"char_start": 406, "char_end": 407, "chars": "&"}], "added": []}, "commit_link": "github.com/xkbcommon/libxkbcommon/commit/c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb", "file_name": "src/xkbcomp/ast-build.c", "vul_type": "cwe-416"}
{"func_name": "mm_init", "func_src_before": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tmmu_notifier_mm_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\n\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}", "func_src_after": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n\tmmu_notifier_mm_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\n\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 22, "char_start": 591, "char_end": 630, "line": "\tRCU_INIT_POINTER(mm->exe_file, NULL);\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 592, "char_end": 631, "chars": "RCU_INIT_POINTER(mm->exe_file, NULL);\n\t"}]}, "commit_link": "github.com/torvalds/linux/commit/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a", "file_name": "kernel/fork.c", "vul_type": "cwe-416"}
{"func_name": "PHP_MINIT_FUNCTION", "func_src_before": "PHP_MINIT_FUNCTION(spl_array)\n{\n\tREGISTER_SPL_STD_CLASS_EX(ArrayObject, spl_array_object_new, spl_funcs_ArrayObject);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Aggregate);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, ArrayAccess);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Countable);\n\tmemcpy(&spl_handler_ArrayObject, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\n\tspl_handler_ArrayObject.clone_obj = spl_array_object_clone;\n\tspl_handler_ArrayObject.read_dimension = spl_array_read_dimension;\n\tspl_handler_ArrayObject.write_dimension = spl_array_write_dimension;\n\tspl_handler_ArrayObject.unset_dimension = spl_array_unset_dimension;\n\tspl_handler_ArrayObject.has_dimension = spl_array_has_dimension;\n\tspl_handler_ArrayObject.count_elements = spl_array_object_count_elements;\n\n\tspl_handler_ArrayObject.get_properties = spl_array_get_properties;\n\tspl_handler_ArrayObject.get_debug_info = spl_array_get_debug_info;\n\tspl_handler_ArrayObject.get_gc = spl_array_get_gc;\n\tspl_handler_ArrayObject.read_property = spl_array_read_property;\n\tspl_handler_ArrayObject.write_property = spl_array_write_property;\n\tspl_handler_ArrayObject.get_property_ptr_ptr = spl_array_get_property_ptr_ptr;\n\tspl_handler_ArrayObject.has_property = spl_array_has_property;\n\tspl_handler_ArrayObject.unset_property = spl_array_unset_property;\n\n\tspl_handler_ArrayObject.compare_objects = spl_array_compare_objects;\n\n\tREGISTER_SPL_STD_CLASS_EX(ArrayIterator, spl_array_object_new, spl_funcs_ArrayIterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, ArrayAccess);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, SeekableIterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Countable);\n\tmemcpy(&spl_handler_ArrayIterator, &spl_handler_ArrayObject, sizeof(zend_object_handlers));\n\tspl_ce_ArrayIterator->get_iterator = spl_array_get_iterator;\n\n\tREGISTER_SPL_SUB_CLASS_EX(RecursiveArrayIterator, ArrayIterator, spl_array_object_new, spl_funcs_RecursiveArrayIterator);\n\tREGISTER_SPL_IMPLEMENTS(RecursiveArrayIterator, RecursiveIterator);\n\tspl_ce_RecursiveArrayIterator->get_iterator = spl_array_get_iterator;\n\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   \"STD_PROP_LIST\",    SPL_ARRAY_STD_PROP_LIST);\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   \"ARRAY_AS_PROPS\",   SPL_ARRAY_ARRAY_AS_PROPS);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, \"STD_PROP_LIST\",    SPL_ARRAY_STD_PROP_LIST);\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, \"ARRAY_AS_PROPS\",   SPL_ARRAY_ARRAY_AS_PROPS);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(RecursiveArrayIterator, \"CHILD_ARRAYS_ONLY\", SPL_ARRAY_CHILD_ARRAYS_ONLY);\n\n\treturn SUCCESS;\n}", "func_src_after": "PHP_MINIT_FUNCTION(spl_array)\n{\n\tREGISTER_SPL_STD_CLASS_EX(ArrayObject, spl_array_object_new, spl_funcs_ArrayObject);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Aggregate);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, ArrayAccess);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Countable);\n\tmemcpy(&spl_handler_ArrayObject, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\n\tspl_handler_ArrayObject.clone_obj = spl_array_object_clone;\n\tspl_handler_ArrayObject.read_dimension = spl_array_read_dimension;\n\tspl_handler_ArrayObject.write_dimension = spl_array_write_dimension;\n\tspl_handler_ArrayObject.unset_dimension = spl_array_unset_dimension;\n\tspl_handler_ArrayObject.has_dimension = spl_array_has_dimension;\n\tspl_handler_ArrayObject.count_elements = spl_array_object_count_elements;\n\n\tspl_handler_ArrayObject.get_properties = spl_array_get_properties;\n\tspl_handler_ArrayObject.get_debug_info = spl_array_get_debug_info;\n\tspl_handler_ArrayObject.get_gc = spl_array_get_gc;\n\tspl_handler_ArrayObject.read_property = spl_array_read_property;\n\tspl_handler_ArrayObject.write_property = spl_array_write_property;\n\tspl_handler_ArrayObject.get_property_ptr_ptr = spl_array_get_property_ptr_ptr;\n\tspl_handler_ArrayObject.has_property = spl_array_has_property;\n\tspl_handler_ArrayObject.unset_property = spl_array_unset_property;\n\n\tspl_handler_ArrayObject.compare_objects = spl_array_compare_objects;\n\n\tREGISTER_SPL_STD_CLASS_EX(ArrayIterator, spl_array_object_new, spl_funcs_ArrayIterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, ArrayAccess);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, SeekableIterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Countable);\n\tmemcpy(&spl_handler_ArrayIterator, &spl_handler_ArrayObject, sizeof(zend_object_handlers));\n\tspl_ce_ArrayIterator->get_iterator = spl_array_get_iterator;\n\n\tREGISTER_SPL_SUB_CLASS_EX(RecursiveArrayIterator, ArrayIterator, spl_array_object_new, spl_funcs_RecursiveArrayIterator);\n\tREGISTER_SPL_IMPLEMENTS(RecursiveArrayIterator, RecursiveIterator);\n\tspl_ce_RecursiveArrayIterator->get_iterator = spl_array_get_iterator;\n\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   \"STD_PROP_LIST\",    SPL_ARRAY_STD_PROP_LIST);\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   \"ARRAY_AS_PROPS\",   SPL_ARRAY_ARRAY_AS_PROPS);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, \"STD_PROP_LIST\",    SPL_ARRAY_STD_PROP_LIST);\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, \"ARRAY_AS_PROPS\",   SPL_ARRAY_ARRAY_AS_PROPS);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(RecursiveArrayIterator, \"CHILD_ARRAYS_ONLY\", SPL_ARRAY_CHILD_ARRAYS_ONLY);\n\n\treturn SUCCESS;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 19, "char_start": 968, "char_end": 1020, "line": "\tspl_handler_ArrayObject.get_gc = spl_array_get_gc;\n"}]}, "char_changes": {"deleted": [], "added": []}, "commit_link": "github.com/php/php-src/commit/3f627e580acfdaf0595ae3b115b8bec677f203ee?w=1", "file_name": "ext/spl/spl_array.c", "vul_type": "cwe-416"}
{"func_name": "do_get_mempolicy", "func_src_before": "static long do_get_mempolicy(int *policy, nodemask_t *nmask,\n\t\t\t     unsigned long addr, unsigned long flags)\n{\n\tint err;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mempolicy *pol = current->mempolicy;\n\n\tif (flags &\n\t\t~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))\n\t\treturn -EINVAL;\n\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t\tif (flags & (MPOL_F_NODE|MPOL_F_ADDR))\n\t\t\treturn -EINVAL;\n\t\t*policy = 0;\t/* just so it's initialized */\n\t\ttask_lock(current);\n\t\t*nmask  = cpuset_current_mems_allowed;\n\t\ttask_unlock(current);\n\t\treturn 0;\n\t}\n\n\tif (flags & MPOL_F_ADDR) {\n\t\t/*\n\t\t * Do NOT fall back to task policy if the\n\t\t * vma/shared policy at addr is NULL.  We\n\t\t * want to return MPOL_DEFAULT in this case.\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\n\tif (!pol)\n\t\tpol = &default_policy;\t/* indicates default behavior */\n\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\terr = lookup_node(addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\t*policy = err;\n\t\t} else if (pol == current->mempolicy &&\n\t\t\t\tpol->mode == MPOL_INTERLEAVE) {\n\t\t\t*policy = next_node_in(current->il_prev, pol->v.nodes);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*policy = pol == &default_policy ? MPOL_DEFAULT :\n\t\t\t\t\t\tpol->mode;\n\t\t/*\n\t\t * Internal mempolicy flags must be masked off before exposing\n\t\t * the policy to userspace.\n\t\t */\n\t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n\t}\n\n\tif (vma) {\n\t\tup_read(&current->mm->mmap_sem);\n\t\tvma = NULL;\n\t}\n\n\terr = 0;\n\tif (nmask) {\n\t\tif (mpol_store_user_nodemask(pol)) {\n\t\t\t*nmask = pol->w.user_nodemask;\n\t\t} else {\n\t\t\ttask_lock(current);\n\t\t\tget_policy_nodemask(pol, nmask);\n\t\t\ttask_unlock(current);\n\t\t}\n\t}\n\n out:\n\tmpol_cond_put(pol);\n\tif (vma)\n\t\tup_read(&current->mm->mmap_sem);\n\treturn err;\n}", "func_src_after": "static long do_get_mempolicy(int *policy, nodemask_t *nmask,\n\t\t\t     unsigned long addr, unsigned long flags)\n{\n\tint err;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mempolicy *pol = current->mempolicy;\n\n\tif (flags &\n\t\t~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))\n\t\treturn -EINVAL;\n\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t\tif (flags & (MPOL_F_NODE|MPOL_F_ADDR))\n\t\t\treturn -EINVAL;\n\t\t*policy = 0;\t/* just so it's initialized */\n\t\ttask_lock(current);\n\t\t*nmask  = cpuset_current_mems_allowed;\n\t\ttask_unlock(current);\n\t\treturn 0;\n\t}\n\n\tif (flags & MPOL_F_ADDR) {\n\t\t/*\n\t\t * Do NOT fall back to task policy if the\n\t\t * vma/shared policy at addr is NULL.  We\n\t\t * want to return MPOL_DEFAULT in this case.\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\n\tif (!pol)\n\t\tpol = &default_policy;\t/* indicates default behavior */\n\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\terr = lookup_node(addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\t*policy = err;\n\t\t} else if (pol == current->mempolicy &&\n\t\t\t\tpol->mode == MPOL_INTERLEAVE) {\n\t\t\t*policy = next_node_in(current->il_prev, pol->v.nodes);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*policy = pol == &default_policy ? MPOL_DEFAULT :\n\t\t\t\t\t\tpol->mode;\n\t\t/*\n\t\t * Internal mempolicy flags must be masked off before exposing\n\t\t * the policy to userspace.\n\t\t */\n\t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n\t}\n\n\terr = 0;\n\tif (nmask) {\n\t\tif (mpol_store_user_nodemask(pol)) {\n\t\t\t*nmask = pol->w.user_nodemask;\n\t\t} else {\n\t\t\ttask_lock(current);\n\t\t\tget_policy_nodemask(pol, nmask);\n\t\t\ttask_unlock(current);\n\t\t}\n\t}\n\n out:\n\tmpol_cond_put(pol);\n\tif (vma)\n\t\tup_read(&current->mm->mmap_sem);\n\treturn err;\n}", "line_changes": {"deleted": [{"line_no": 68, "char_start": 1678, "char_end": 1690, "line": "\tif (vma) {\n"}, {"line_no": 69, "char_start": 1690, "char_end": 1725, "line": "\t\tup_read(&current->mm->mmap_sem);\n"}, {"line_no": 70, "char_start": 1725, "char_end": 1739, "line": "\t\tvma = NULL;\n"}, {"line_no": 71, "char_start": 1739, "char_end": 1742, "line": "\t}\n"}, {"line_no": 72, "char_start": 1742, "char_end": 1743, "line": "\n"}], "added": []}, "char_changes": {"deleted": [{"char_start": 1679, "char_end": 1744, "chars": "if (vma) {\n\t\tup_read(&current->mm->mmap_sem);\n\t\tvma = NULL;\n\t}\n\n\t"}], "added": []}, "commit_link": "github.com/torvalds/linux/commit/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99", "file_name": "mm/mempolicy.c", "vul_type": "cwe-416"}
{"func_name": "wddx_stack_destroy", "func_src_before": " */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data\n\t\t\t\t\t&& ((st_entry *)stack->elements[i])->type != ST_FIELD)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;", "func_src_after": " */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data\n\t\t\t\t\t&& ((st_entry *)stack->elements[i])->type != ST_FIELD)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;", "line_changes": {"deleted": [{"line_no": 8, "char_start": 134, "char_end": 180, "line": "\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n"}], "added": [{"line_no": 8, "char_start": 134, "char_end": 180, "line": "\t\t\tif (((st_entry *)stack->elements[i])->data\n"}, {"line_no": 9, "char_start": 180, "char_end": 242, "line": "\t\t\t\t\t&& ((st_entry *)stack->elements[i])->type != ST_FIELD)\t{\n"}]}, "char_changes": {"deleted": [], "added": []}, "commit_link": "github.com/php/php-src/commit/b88393f08a558eec14964a55d3c680fe67407712?w=1", "file_name": "ext/wddx/wddx.c", "vul_type": "cwe-416"}
{"func_name": "regulator_ena_gpio_free", "func_src_before": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\n\tif (!rdev->ena_pin)\n\t\treturn;\n\n\t/* Free the GPIO only in case of no use */\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n\t\t\t\tgpiod_put(pin->gpiod);\n\t\t\t\tlist_del(&pin->list);\n\t\t\t\tkfree(pin);\n\t\t\t} else {\n\t\t\t\tpin->request_count--;\n\t\t\t}\n\t\t}\n\t}\n}", "func_src_after": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\n\tif (!rdev->ena_pin)\n\t\treturn;\n\n\t/* Free the GPIO only in case of no use */\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n\t\t\t\tgpiod_put(pin->gpiod);\n\t\t\t\tlist_del(&pin->list);\n\t\t\t\tkfree(pin);\n\t\t\t\trdev->ena_pin = NULL;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpin->request_count--;\n\t\t\t}\n\t\t}\n\t}\n}", "line_changes": {"deleted": [], "added": [{"line_no": 16, "char_start": 426, "char_end": 452, "line": "\t\t\t\trdev->ena_pin = NULL;\n"}, {"line_no": 17, "char_start": 452, "char_end": 464, "line": "\t\t\t\treturn;\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 429, "char_end": 467, "chars": "\trdev->ena_pin = NULL;\n\t\t\t\treturn;\n\t\t\t"}]}, "commit_link": "github.com/torvalds/linux/commit/60a2362f769cf549dc466134efe71c8bf9fbaaba", "file_name": "drivers/regulator/core.c", "vul_type": "cwe-416"}
{"func_name": "usb_console_setup", "func_src_before": "static int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n\ttty_kref_put(tty);\n reset_open_count:\n\tport->port.count = 0;\n\tusb_autopm_put_interface(serial->interface);\n error_get_interface:\n\tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}", "func_src_after": "static int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n\ttty_kref_put(tty);\n reset_open_count:\n\tport->port.count = 0;\n\tinfo->port = NULL;\n\tusb_autopm_put_interface(serial->interface);\n error_get_interface:\n\tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 132, "char_start": 3110, "char_end": 3130, "line": "\tinfo->port = NULL;\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 3111, "char_end": 3131, "chars": "info->port = NULL;\n\t"}]}, "commit_link": "github.com/torvalds/linux/commit/299d7572e46f98534033a9e65973f13ad1ce9047", "file_name": "drivers/usb/serial/console.c", "vul_type": "cwe-416"}
{"func_name": "ipxitf_ioctl", "func_src_before": "static int ipxitf_ioctl(unsigned int cmd, void __user *arg)\n{\n\tint rc = -EINVAL;\n\tstruct ifreq ifr;\n\tint val;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface_definition f;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\trc = -EINVAL;\n\t\tif (sipx->sipx_family != AF_IPX)\n\t\t\tbreak;\n\t\tf.ipx_network = sipx->sipx_network;\n\t\tmemcpy(f.ipx_device, ifr.ifr_name,\n\t\t\tsizeof(f.ipx_device));\n\t\tmemcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);\n\t\tf.ipx_dlink_type = sipx->sipx_type;\n\t\tf.ipx_special = sipx->sipx_special;\n\n\t\tif (sipx->sipx_action == IPX_DLTITF)\n\t\t\trc = ipxitf_delete(&f);\n\t\telse\n\t\t\trc = ipxitf_create(&f);\n\t\tbreak;\n\t}\n\tcase SIOCGIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface *ipxif;\n\t\tstruct net_device *dev;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\tdev  = __dev_get_by_name(&init_net, ifr.ifr_name);\n\t\trc   = -ENODEV;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tipxif = ipxitf_find_using_phys(dev,\n\t\t\t\t\t   ipx_map_frame_type(sipx->sipx_type));\n\t\trc = -EADDRNOTAVAIL;\n\t\tif (!ipxif)\n\t\t\tbreak;\n\n\t\tsipx->sipx_family\t= AF_IPX;\n\t\tsipx->sipx_network\t= ipxif->if_netnum;\n\t\tmemcpy(sipx->sipx_node, ipxif->if_node,\n\t\t\tsizeof(sipx->sipx_node));\n\t\trc = -EFAULT;\n\t\tif (copy_to_user(arg, &ifr, sizeof(ifr)))\n\t\t\tbreak;\n\t\tipxitf_put(ipxif);\n\t\trc = 0;\n\t\tbreak;\n\t}\n\tcase SIOCAIPXITFCRT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_auto_create_interfaces = val;\n\t\tbreak;\n\tcase SIOCAIPXPRISLT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_set_auto_select(val);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}", "func_src_after": "static int ipxitf_ioctl(unsigned int cmd, void __user *arg)\n{\n\tint rc = -EINVAL;\n\tstruct ifreq ifr;\n\tint val;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface_definition f;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\trc = -EINVAL;\n\t\tif (sipx->sipx_family != AF_IPX)\n\t\t\tbreak;\n\t\tf.ipx_network = sipx->sipx_network;\n\t\tmemcpy(f.ipx_device, ifr.ifr_name,\n\t\t\tsizeof(f.ipx_device));\n\t\tmemcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);\n\t\tf.ipx_dlink_type = sipx->sipx_type;\n\t\tf.ipx_special = sipx->sipx_special;\n\n\t\tif (sipx->sipx_action == IPX_DLTITF)\n\t\t\trc = ipxitf_delete(&f);\n\t\telse\n\t\t\trc = ipxitf_create(&f);\n\t\tbreak;\n\t}\n\tcase SIOCGIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface *ipxif;\n\t\tstruct net_device *dev;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\tdev  = __dev_get_by_name(&init_net, ifr.ifr_name);\n\t\trc   = -ENODEV;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tipxif = ipxitf_find_using_phys(dev,\n\t\t\t\t\t   ipx_map_frame_type(sipx->sipx_type));\n\t\trc = -EADDRNOTAVAIL;\n\t\tif (!ipxif)\n\t\t\tbreak;\n\n\t\tsipx->sipx_family\t= AF_IPX;\n\t\tsipx->sipx_network\t= ipxif->if_netnum;\n\t\tmemcpy(sipx->sipx_node, ipxif->if_node,\n\t\t\tsizeof(sipx->sipx_node));\n\t\trc = 0;\n\t\tif (copy_to_user(arg, &ifr, sizeof(ifr)))\n\t\t\trc = -EFAULT;\n\t\tipxitf_put(ipxif);\n\t\tbreak;\n\t}\n\tcase SIOCAIPXITFCRT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_auto_create_interfaces = val;\n\t\tbreak;\n\tcase SIOCAIPXPRISLT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_set_auto_select(val);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}", "line_changes": {"deleted": [{"line_no": 55, "char_start": 1332, "char_end": 1348, "line": "\t\trc = -EFAULT;\n"}, {"line_no": 57, "char_start": 1392, "char_end": 1402, "line": "\t\t\tbreak;\n"}, {"line_no": 59, "char_start": 1423, "char_end": 1433, "line": "\t\trc = 0;\n"}], "added": [{"line_no": 55, "char_start": 1332, "char_end": 1342, "line": "\t\trc = 0;\n"}, {"line_no": 57, "char_start": 1386, "char_end": 1403, "line": "\t\t\trc = -EFAULT;\n"}]}, "char_changes": {"deleted": [{"char_start": 1339, "char_end": 1346, "chars": "-EFAULT"}, {"char_start": 1395, "char_end": 1396, "chars": "b"}, {"char_start": 1397, "char_end": 1400, "chars": "eak"}, {"char_start": 1421, "char_end": 1431, "chars": ";\n\t\trc = 0"}], "added": [{"char_start": 1339, "char_end": 1340, "chars": "0"}, {"char_start": 1390, "char_end": 1401, "chars": "c = -EFAULT"}]}, "commit_link": "github.com/torvalds/linux/commit/ee0d8d8482345ff97a75a7d747efc309f13b0d80", "file_name": "net/ipx/af_ipx.c", "vul_type": "cwe-416"}
{"func_name": "PHP_MINIT_FUNCTION", "func_src_before": "static PHP_MINIT_FUNCTION(zip)\n{\n#ifdef PHP_ZIP_USE_OO\n\tzend_class_entry ce;\n\n\tmemcpy(&zip_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tzip_object_handlers.clone_obj\t\t= NULL;\n\tzip_object_handlers.get_property_ptr_ptr = php_zip_get_property_ptr_ptr;\n\n\tzip_object_handlers.get_gc          = php_zip_get_gc;\n\tzip_object_handlers.get_properties = php_zip_get_properties;\n\tzip_object_handlers.read_property\t= php_zip_read_property;\n\tzip_object_handlers.has_property\t= php_zip_has_property;\n\n\tINIT_CLASS_ENTRY(ce, \"ZipArchive\", zip_class_functions);\n\tce.create_object = php_zip_object_new;\n\tzip_class_entry = zend_register_internal_class(&ce TSRMLS_CC);\n\n\tzend_hash_init(&zip_prop_handlers, 0, NULL, NULL, 1);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"status\",    php_zip_status, NULL, NULL, IS_LONG TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"statusSys\", php_zip_status_sys, NULL, NULL, IS_LONG TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"numFiles\",  php_zip_get_num_files, NULL, NULL, IS_LONG TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"filename\", NULL, NULL, php_zipobj_get_filename, IS_STRING TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"comment\", NULL, php_zipobj_get_zip_comment, NULL, IS_STRING TSRMLS_CC);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CREATE\", ZIP_CREATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"EXCL\", ZIP_EXCL);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CHECKCONS\", ZIP_CHECKCONS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OVERWRITE\", ZIP_OVERWRITE);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NOCASE\", ZIP_FL_NOCASE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NODIR\", ZIP_FL_NODIR);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_COMPRESSED\", ZIP_FL_COMPRESSED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_UNCHANGED\", ZIP_FL_UNCHANGED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFAULT\", ZIP_CM_DEFAULT);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_STORE\", ZIP_CM_STORE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_SHRINK\", ZIP_CM_SHRINK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_1\", ZIP_CM_REDUCE_1);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_2\", ZIP_CM_REDUCE_2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_3\", ZIP_CM_REDUCE_3);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_4\", ZIP_CM_REDUCE_4);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_IMPLODE\", ZIP_CM_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE\", ZIP_CM_DEFLATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE64\", ZIP_CM_DEFLATE64);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PKWARE_IMPLODE\", ZIP_CM_PKWARE_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_BZIP2\", ZIP_CM_BZIP2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZMA\", ZIP_CM_LZMA);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_TERSE\", ZIP_CM_TERSE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZ77\", ZIP_CM_LZ77);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_WAVPACK\", ZIP_CM_WAVPACK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PPMD\", ZIP_CM_PPMD);\n\n\t/* Error code */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OK\",\t\t\tZIP_ER_OK);\t\t\t/* N No error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MULTIDISK\",\tZIP_ER_MULTIDISK);\t/* N Multi-disk zip archives not supported */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_RENAME\",\t\tZIP_ER_RENAME);\t\t/* S Renaming temporary file failed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CLOSE\",\t\tZIP_ER_CLOSE);\t\t/* S Closing zip archive failed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_SEEK\",\t\tZIP_ER_SEEK);\t\t/* S Seek error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_READ\",\t\tZIP_ER_READ);\t\t/* S Read error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_WRITE\",\t\tZIP_ER_WRITE);\t\t/* S Write error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CRC\",\t\t\tZIP_ER_CRC);\t\t/* N CRC error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZIPCLOSED\",\tZIP_ER_ZIPCLOSED);\t/* N Containing zip archive was closed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOENT\",\t\tZIP_ER_NOENT);\t\t/* N No such file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EXISTS\",\t\tZIP_ER_EXISTS);\t\t/* N File already exists */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OPEN\",\t\tZIP_ER_OPEN);\t\t/* S Can't open file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_TMPOPEN\",\t\tZIP_ER_TMPOPEN);\t/* S Failure to create temporary file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZLIB\",\t\tZIP_ER_ZLIB);\t\t/* Z Zlib error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MEMORY\",\t\tZIP_ER_MEMORY);\t\t/* N Malloc failure */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CHANGED\",\t\tZIP_ER_CHANGED);\t/* N Entry has been changed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_COMPNOTSUPP\",\tZIP_ER_COMPNOTSUPP);/* N Compression method not supported */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EOF\",\t\t\tZIP_ER_EOF);\t\t/* N Premature EOF */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INVAL\",\t\tZIP_ER_INVAL);\t\t/* N Invalid argument */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOZIP\",\t\tZIP_ER_NOZIP);\t\t/* N Not a zip archive */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INTERNAL\",\tZIP_ER_INTERNAL);\t/* N Internal error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INCONS\",\t\tZIP_ER_INCONS);\t\t/* N Zip archive inconsistent */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_REMOVE\",\t\tZIP_ER_REMOVE);\t\t/* S Can't remove file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_DELETED\",  \tZIP_ER_DELETED);\t/* N Entry has been deleted */\n\n\tphp_register_url_stream_wrapper(\"zip\", &php_stream_zip_wrapper TSRMLS_CC);\n#endif\n\n\tle_zip_dir   = zend_register_list_destructors_ex(php_zip_free_dir,   NULL, le_zip_dir_name,   module_number);\n\tle_zip_entry = zend_register_list_destructors_ex(php_zip_free_entry, NULL, le_zip_entry_name, module_number);\n\n\treturn SUCCESS;\n}", "func_src_after": "static PHP_MINIT_FUNCTION(zip)\n{\n#ifdef PHP_ZIP_USE_OO\n\tzend_class_entry ce;\n\n\tmemcpy(&zip_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tzip_object_handlers.clone_obj\t\t= NULL;\n\tzip_object_handlers.get_property_ptr_ptr = php_zip_get_property_ptr_ptr;\n\n\tzip_object_handlers.get_gc          = php_zip_get_gc;\n\tzip_object_handlers.get_properties = php_zip_get_properties;\n\tzip_object_handlers.read_property\t= php_zip_read_property;\n\tzip_object_handlers.has_property\t= php_zip_has_property;\n\n\tINIT_CLASS_ENTRY(ce, \"ZipArchive\", zip_class_functions);\n\tce.create_object = php_zip_object_new;\n\tzip_class_entry = zend_register_internal_class(&ce TSRMLS_CC);\n\n\tzend_hash_init(&zip_prop_handlers, 0, NULL, NULL, 1);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"status\",    php_zip_status, NULL, NULL, IS_LONG TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"statusSys\", php_zip_status_sys, NULL, NULL, IS_LONG TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"numFiles\",  php_zip_get_num_files, NULL, NULL, IS_LONG TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"filename\", NULL, NULL, php_zipobj_get_filename, IS_STRING TSRMLS_CC);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"comment\", NULL, php_zipobj_get_zip_comment, NULL, IS_STRING TSRMLS_CC);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CREATE\", ZIP_CREATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"EXCL\", ZIP_EXCL);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CHECKCONS\", ZIP_CHECKCONS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OVERWRITE\", ZIP_OVERWRITE);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NOCASE\", ZIP_FL_NOCASE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NODIR\", ZIP_FL_NODIR);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_COMPRESSED\", ZIP_FL_COMPRESSED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_UNCHANGED\", ZIP_FL_UNCHANGED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFAULT\", ZIP_CM_DEFAULT);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_STORE\", ZIP_CM_STORE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_SHRINK\", ZIP_CM_SHRINK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_1\", ZIP_CM_REDUCE_1);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_2\", ZIP_CM_REDUCE_2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_3\", ZIP_CM_REDUCE_3);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_4\", ZIP_CM_REDUCE_4);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_IMPLODE\", ZIP_CM_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE\", ZIP_CM_DEFLATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE64\", ZIP_CM_DEFLATE64);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PKWARE_IMPLODE\", ZIP_CM_PKWARE_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_BZIP2\", ZIP_CM_BZIP2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZMA\", ZIP_CM_LZMA);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_TERSE\", ZIP_CM_TERSE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZ77\", ZIP_CM_LZ77);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_WAVPACK\", ZIP_CM_WAVPACK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PPMD\", ZIP_CM_PPMD);\n\n\t/* Error code */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OK\",\t\t\tZIP_ER_OK);\t\t\t/* N No error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MULTIDISK\",\tZIP_ER_MULTIDISK);\t/* N Multi-disk zip archives not supported */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_RENAME\",\t\tZIP_ER_RENAME);\t\t/* S Renaming temporary file failed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CLOSE\",\t\tZIP_ER_CLOSE);\t\t/* S Closing zip archive failed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_SEEK\",\t\tZIP_ER_SEEK);\t\t/* S Seek error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_READ\",\t\tZIP_ER_READ);\t\t/* S Read error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_WRITE\",\t\tZIP_ER_WRITE);\t\t/* S Write error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CRC\",\t\t\tZIP_ER_CRC);\t\t/* N CRC error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZIPCLOSED\",\tZIP_ER_ZIPCLOSED);\t/* N Containing zip archive was closed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOENT\",\t\tZIP_ER_NOENT);\t\t/* N No such file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EXISTS\",\t\tZIP_ER_EXISTS);\t\t/* N File already exists */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OPEN\",\t\tZIP_ER_OPEN);\t\t/* S Can't open file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_TMPOPEN\",\t\tZIP_ER_TMPOPEN);\t/* S Failure to create temporary file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZLIB\",\t\tZIP_ER_ZLIB);\t\t/* Z Zlib error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MEMORY\",\t\tZIP_ER_MEMORY);\t\t/* N Malloc failure */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CHANGED\",\t\tZIP_ER_CHANGED);\t/* N Entry has been changed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_COMPNOTSUPP\",\tZIP_ER_COMPNOTSUPP);/* N Compression method not supported */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EOF\",\t\t\tZIP_ER_EOF);\t\t/* N Premature EOF */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INVAL\",\t\tZIP_ER_INVAL);\t\t/* N Invalid argument */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOZIP\",\t\tZIP_ER_NOZIP);\t\t/* N Not a zip archive */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INTERNAL\",\tZIP_ER_INTERNAL);\t/* N Internal error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INCONS\",\t\tZIP_ER_INCONS);\t\t/* N Zip archive inconsistent */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_REMOVE\",\t\tZIP_ER_REMOVE);\t\t/* S Can't remove file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_DELETED\",  \tZIP_ER_DELETED);\t/* N Entry has been deleted */\n\n\tphp_register_url_stream_wrapper(\"zip\", &php_stream_zip_wrapper TSRMLS_CC);\n#endif\n\n\tle_zip_dir   = zend_register_list_destructors_ex(php_zip_free_dir,   NULL, le_zip_dir_name,   module_number);\n\tle_zip_entry = zend_register_list_destructors_ex(php_zip_free_entry, NULL, le_zip_entry_name, module_number);\n\n\treturn SUCCESS;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 10, "char_start": 286, "char_end": 341, "line": "\tzip_object_handlers.get_gc          = php_zip_get_gc;\n"}]}, "char_changes": {"deleted": [], "added": []}, "commit_link": "github.com/php/php-src/commit/f6aef68089221c5ea047d4a74224ee3deead99a6?w=1", "file_name": "ext/zip/php_zip.c", "vul_type": "cwe-416"}
{"func_name": "get_task_ioprio", "func_src_before": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n\tif (p->io_context)\n\t\tret = p->io_context->ioprio;\nout:\n\treturn ret;\n}", "func_src_after": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n\ttask_lock(p);\n\tif (p->io_context)\n\t\tret = p->io_context->ioprio;\n\ttask_unlock(p);\nout:\n\treturn ret;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 9, "char_start": 178, "char_end": 193, "line": "\ttask_lock(p);\n"}, {"line_no": 12, "char_start": 244, "char_end": 261, "line": "\ttask_unlock(p);\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 179, "char_end": 194, "chars": "task_lock(p);\n\t"}, {"char_start": 242, "char_end": 259, "chars": ";\n\ttask_unlock(p)"}]}, "commit_link": "github.com/torvalds/linux/commit/8ba8682107ee2ca3347354e018865d8e1967c5f4", "file_name": "block/ioprio.c", "vul_type": "cwe-416"}
{"func_name": "SetImageType", "func_src_before": "MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)\n{\n  const char\n    *artifact;\n\n  ImageInfo\n    *image_info;\n\n  MagickBooleanType\n    status;\n\n  QuantizeInfo\n    *quantize_info;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  status=MagickTrue;\n  image_info=AcquireImageInfo();\n  image_info->dither=image->dither;\n  artifact=GetImageArtifact(image,\"dither\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"dither\",artifact);\n  switch (type)\n  {\n    case BilevelType:\n    {\n      if (SetImageMonochrome(image,&image->exception) == MagickFalse)\n        {\n          status=TransformImageColorspace(image,GRAYColorspace);\n          (void) NormalizeImage(image);\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=2;\n          quantize_info->colorspace=GRAYColorspace;\n          status=QuantizeImage(quantize_info,image);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      image->colors=2;\n      image->matte=MagickFalse;\n      break;\n    }\n    case GrayscaleType:\n    {\n      if (SetImageGray(image,&image->exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace);\n      image->matte=MagickFalse;\n      break;\n    }\n    case GrayscaleMatteType:\n    {\n      if (SetImageGray(image,&image->exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case PaletteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        {\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=256;\n          status=QuantizeImage(quantize_info,image);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      image->matte=MagickFalse;\n      break;\n    }\n    case PaletteBilevelMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      status=QuantizeImage(quantize_info,image);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case PaletteMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      quantize_info->colorspace=TransparentColorspace;\n      status=QuantizeImage(quantize_info,image);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case TrueColorType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      image->matte=MagickFalse;\n      break;\n    }\n    case TrueColorMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case ColorSeparationType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            (void) TransformImageColorspace(image,sRGBColorspace);\n          status=TransformImageColorspace(image,CMYKColorspace);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      image->matte=MagickFalse;\n      break;\n    }\n    case ColorSeparationMatteType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            (void) TransformImageColorspace(image,sRGBColorspace);\n          status=TransformImageColorspace(image,CMYKColorspace);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case OptimizeType:\n    case UndefinedType:\n      break;\n  }\n  image_info=DestroyImageInfo(image_info);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  image->type=type;\n  return(MagickTrue);\n}", "func_src_after": "MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)\n{\n  const char\n    *artifact;\n\n  ImageInfo\n    *image_info;\n\n  MagickBooleanType\n    status;\n\n  QuantizeInfo\n    *quantize_info;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  status=MagickTrue;\n  image_info=AcquireImageInfo();\n  image_info->dither=image->dither;\n  artifact=GetImageArtifact(image,\"dither\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"dither\",artifact);\n  switch (type)\n  {\n    case BilevelType:\n    {\n      if (SetImageMonochrome(image,&image->exception) == MagickFalse)\n        {\n          status=TransformImageColorspace(image,GRAYColorspace);\n          (void) NormalizeImage(image);\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=2;\n          quantize_info->colorspace=GRAYColorspace;\n          status=QuantizeImage(quantize_info,image);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      status=AcquireImageColormap(image,2);\n      image->matte=MagickFalse;\n      break;\n    }\n    case GrayscaleType:\n    {\n      if (SetImageGray(image,&image->exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace);\n      image->matte=MagickFalse;\n      break;\n    }\n    case GrayscaleMatteType:\n    {\n      if (SetImageGray(image,&image->exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case PaletteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        {\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=256;\n          status=QuantizeImage(quantize_info,image);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      image->matte=MagickFalse;\n      break;\n    }\n    case PaletteBilevelMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      status=QuantizeImage(quantize_info,image);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case PaletteMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      quantize_info->colorspace=TransparentColorspace;\n      status=QuantizeImage(quantize_info,image);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case TrueColorType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      image->matte=MagickFalse;\n      break;\n    }\n    case TrueColorMatteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case ColorSeparationType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            (void) TransformImageColorspace(image,sRGBColorspace);\n          status=TransformImageColorspace(image,CMYKColorspace);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      image->matte=MagickFalse;\n      break;\n    }\n    case ColorSeparationMatteType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            (void) TransformImageColorspace(image,sRGBColorspace);\n          status=TransformImageColorspace(image,CMYKColorspace);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass);\n      if (image->matte == MagickFalse)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n      break;\n    }\n    case OptimizeType:\n    case UndefinedType:\n      break;\n  }\n  image_info=DestroyImageInfo(image_info);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  image->type=type;\n  return(MagickTrue);\n}", "line_changes": {"deleted": [{"line_no": 39, "char_start": 1127, "char_end": 1150, "line": "      image->colors=2;\n"}], "added": [{"line_no": 39, "char_start": 1127, "char_end": 1171, "line": "      status=AcquireImageColormap(image,2);\n"}]}, "char_changes": {"deleted": [{"char_start": 1138, "char_end": 1141, "chars": "->c"}, {"char_start": 1145, "char_end": 1147, "chars": "s="}], "added": [{"char_start": 1133, "char_end": 1144, "chars": "status=Acqu"}, {"char_start": 1145, "char_end": 1148, "chars": "reI"}, {"char_start": 1152, "char_end": 1153, "chars": "C"}, {"char_start": 1157, "char_end": 1167, "chars": "map(image,"}, {"char_start": 1168, "char_end": 1169, "chars": ")"}]}, "commit_link": "github.com/ImageMagick/ImageMagick/commit/d63a3c5729df59f183e9e110d5d8385d17caaad0", "file_name": "magick/attribute.c", "vul_type": "cwe-416"}
{"func_name": "updateDevice", "func_src_before": "updateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist; */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\t/*printf(\"found! %d\\n\", (int)(t - p->t));*/\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\t/* update Location ! */\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n\t\t\t\tif(!tmp)\t/* allocation error */\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n\t\t\t\t\tfree(p);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\t/* TODO : check p->headers[HEADER_LOCATION].l */\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t/* add */\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}", "func_src_after": "updateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist; */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\t/*printf(\"found! %d\\n\", (int)(t - p->t));*/\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\t/* update Location ! */\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n\t\t\t\tif(!tmp)\t/* allocation error */\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n\t\t\t\t\t*pp = p->next;\t/* remove \"p\" from the list */\n\t\t\t\t\tfree(p);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\t/* TODO : check p->headers[HEADER_LOCATION].l */\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t/* add */\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 24, "char_start": 920, "char_end": 971, "line": "\t\t\t\t\t*pp = p->next;\t/* remove \"p\" from the list */\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 925, "char_end": 976, "chars": "*pp = p->next;\t/* remove \"p\" from the list */\n\t\t\t\t\t"}]}, "commit_link": "github.com/miniupnp/miniupnp/commit/cd506a67e174a45c6a202eff182a712955ed6d6f", "file_name": "minissdpd/minissdpd.c", "vul_type": "cwe-416"}
{"func_name": "kvm_ioctl_create_device", "func_src_before": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\n\tif (test)\n\t\treturn 0;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\n\tif (ops->init)\n\t\tops->init(dev);\n\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tops->destroy(dev);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn ret;\n\t}\n\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "func_src_after": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\n\tif (test)\n\t\treturn 0;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\n\tif (ops->init)\n\t\tops->init(dev);\n\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\tops->destroy(dev);\n\t\treturn ret;\n\t}\n\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "line_changes": {"deleted": [{"line_no": 41, "char_start": 823, "char_end": 844, "line": "\t\tops->destroy(dev);\n"}], "added": [{"line_no": 44, "char_start": 904, "char_end": 925, "line": "\t\tops->destroy(dev);\n"}]}, "char_changes": {"deleted": [{"char_start": 825, "char_end": 846, "chars": "ops->destroy(dev);\n\t\t"}], "added": [{"char_start": 901, "char_end": 922, "chars": ");\n\t\tops->destroy(dev"}]}, "commit_link": "github.com/torvalds/linux/commit/a0f1d21c1ccb1da66629627a74059dd7f5ac9c61", "file_name": "virt/kvm/kvm_main.c", "vul_type": "cwe-416"}
{"func_name": "SMB2_read", "func_src_before": "SMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tstruct smb_rqst rqst;\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tunsigned int total_len;\n\tint flags = CIFS_LOG_ERROR;\n\tstruct cifs_ses *ses = io_parms->tcon->ses;\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req((void **)&req, &total_len, io_parms, NULL, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\n\trsp = (struct smb2_read_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tif (rc != -ENODATA) {\n\t\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t\t\ttrace_smb3_read_err(xid, req->PersistentFileId,\n\t\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t\t    io_parms->offset, io_parms->length,\n\t\t\t\t\t    rc);\n\t\t} else\n\t\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, 0);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t\treturn rc == -ENODATA ? 0 : rc;\n\t} else\n\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, io_parms->length);\n\n\t*nbytes = le32_to_cpu(rsp->DataLength);\n\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t    (*nbytes > io_parms->length)) {\n\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t *nbytes, io_parms->length);\n\t\trc = -EIO;\n\t\t*nbytes = 0;\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp + rsp->DataOffset, *nbytes);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = rsp_iov.iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}", "func_src_after": "SMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tstruct smb_rqst rqst;\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tunsigned int total_len;\n\tint flags = CIFS_LOG_ERROR;\n\tstruct cifs_ses *ses = io_parms->tcon->ses;\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req((void **)&req, &total_len, io_parms, NULL, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_read_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tif (rc != -ENODATA) {\n\t\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t\t\ttrace_smb3_read_err(xid, req->PersistentFileId,\n\t\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t\t    io_parms->offset, io_parms->length,\n\t\t\t\t\t    rc);\n\t\t} else\n\t\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, 0);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t\treturn rc == -ENODATA ? 0 : rc;\n\t} else\n\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, io_parms->length);\n\n\tcifs_small_buf_release(req);\n\n\t*nbytes = le32_to_cpu(rsp->DataLength);\n\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t    (*nbytes > io_parms->length)) {\n\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t *nbytes, io_parms->length);\n\t\trc = -EIO;\n\t\t*nbytes = 0;\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp + rsp->DataOffset, *nbytes);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = rsp_iov.iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}", "line_changes": {"deleted": [{"line_no": 30, "char_start": 802, "char_end": 832, "line": "\tcifs_small_buf_release(req);\n"}, {"line_no": 31, "char_start": 832, "char_end": 833, "line": "\n"}], "added": [{"line_no": 51, "char_start": 1501, "char_end": 1531, "line": "\tcifs_small_buf_release(req);\n"}, {"line_no": 52, "char_start": 1531, "char_end": 1532, "line": "\n"}]}, "char_changes": {"deleted": [{"char_start": 803, "char_end": 834, "chars": "cifs_small_buf_release(req);\n\n\t"}], "added": [{"char_start": 1497, "char_end": 1528, "chars": ");\n\n\tcifs_small_buf_release(req"}]}, "commit_link": "github.com/torvalds/linux/commit/088aaf17aa79300cab14dbee2569c58cfafd7d6e", "file_name": "fs/cifs/smb2pdu.c", "vul_type": "cwe-416"}
{"func_name": "archive_read_format_rar_read_data", "func_src_before": "archive_read_format_rar_read_data(struct archive_read *a, const void **buff,\n                                  size_t *size, int64_t *offset)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int ret;\n\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n\n  if (rar->bytes_unconsumed > 0) {\n      /* Consume as much as the decompressor actually used. */\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n\n  *buff = NULL;\n  if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {\n    *size = 0;\n    *offset = rar->offset;\n    if (*offset < rar->unp_size)\n      *offset = rar->unp_size;\n    return (ARCHIVE_EOF);\n  }\n\n  switch (rar->compression_method)\n  {\n  case COMPRESS_METHOD_STORE:\n    ret = read_data_stored(a, buff, size, offset);\n    break;\n\n  case COMPRESS_METHOD_FASTEST:\n  case COMPRESS_METHOD_FAST:\n  case COMPRESS_METHOD_NORMAL:\n  case COMPRESS_METHOD_GOOD:\n  case COMPRESS_METHOD_BEST:\n    ret = read_data_compressed(a, buff, size, offset);\n    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN)\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n    break;\n\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unsupported compression method for RAR file.\");\n    ret = ARCHIVE_FATAL;\n    break;\n  }\n  return (ret);\n}", "func_src_after": "archive_read_format_rar_read_data(struct archive_read *a, const void **buff,\n                                  size_t *size, int64_t *offset)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int ret;\n\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n\n  if (rar->bytes_unconsumed > 0) {\n      /* Consume as much as the decompressor actually used. */\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n\n  *buff = NULL;\n  if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {\n    *size = 0;\n    *offset = rar->offset;\n    if (*offset < rar->unp_size)\n      *offset = rar->unp_size;\n    return (ARCHIVE_EOF);\n  }\n\n  switch (rar->compression_method)\n  {\n  case COMPRESS_METHOD_STORE:\n    ret = read_data_stored(a, buff, size, offset);\n    break;\n\n  case COMPRESS_METHOD_FASTEST:\n  case COMPRESS_METHOD_FAST:\n  case COMPRESS_METHOD_NORMAL:\n  case COMPRESS_METHOD_GOOD:\n  case COMPRESS_METHOD_BEST:\n    ret = read_data_compressed(a, buff, size, offset);\n    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN) {\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n      rar->start_new_table = 1;\n    }\n    break;\n\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unsupported compression method for RAR file.\");\n    ret = ARCHIVE_FATAL;\n    break;\n  }\n  return (ret);\n}", "line_changes": {"deleted": [{"line_no": 38, "char_start": 1072, "char_end": 1122, "line": "    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN)\n"}], "added": [{"line_no": 38, "char_start": 1072, "char_end": 1124, "line": "    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN) {\n"}, {"line_no": 40, "char_start": 1189, "char_end": 1221, "line": "      rar->start_new_table = 1;\n"}, {"line_no": 41, "char_start": 1221, "char_end": 1227, "line": "    }\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1121, "char_end": 1123, "chars": " {"}, {"char_start": 1188, "char_end": 1226, "chars": "\n      rar->start_new_table = 1;\n    }"}]}, "commit_link": "github.com/libarchive/libarchive/commit/b8592ecba2f9e451e1f5cb7ab6dcee8b8e7b3f60", "file_name": "libarchive/archive_read_support_format_rar.c", "vul_type": "cwe-416"}
{"func_name": "r_anal_bb_free", "func_src_before": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n\t\tbb->failbb->prev = NULL;\n\t\tbb->failbb = NULL;\n\t}\n\tR_FREE (bb);\n}", "func_src_after": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n\t\tbb->failbb->prev = NULL;\n\t\tbb->failbb = NULL;\n\t}\n\tif (bb->next) {\n\t\t// avoid double free\n\t\tbb->next->prev = NULL;\n\t}\n\tR_FREE (bb); // double free\n}", "line_changes": {"deleted": [{"line_no": 34, "char_start": 686, "char_end": 700, "line": "\tR_FREE (bb);\n"}], "added": [{"line_no": 34, "char_start": 686, "char_end": 703, "line": "\tif (bb->next) {\n"}, {"line_no": 36, "char_start": 726, "char_end": 751, "line": "\t\tbb->next->prev = NULL;\n"}, {"line_no": 37, "char_start": 751, "char_end": 754, "line": "\t}\n"}, {"line_no": 38, "char_start": 754, "char_end": 783, "line": "\tR_FREE (bb); // double free\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 687, "char_end": 755, "chars": "if (bb->next) {\n\t\t// avoid double free\n\t\tbb->next->prev = NULL;\n\t}\n\t"}, {"char_start": 767, "char_end": 782, "chars": " // double free"}]}, "commit_link": "github.com/radare/radare2/commit/90b71c017a7fa9732fe45fd21b245ee051b1f548", "file_name": "libr/anal/bb.c", "vul_type": "cwe-416"}
{"func_name": "hci_uart_set_proto", "func_src_before": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\n\thu->proto = p;\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "func_src_after": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\n\thu->proto = p;\n\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\treturn 0;\n}", "line_changes": {"deleted": [{"line_no": 11, "char_start": 187, "char_end": 231, "line": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n"}, {"line_no": 15, "char_start": 278, "char_end": 325, "line": "\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n"}], "added": [{"line_no": 17, "char_start": 252, "char_end": 296, "line": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n"}]}, "char_changes": {"deleted": [{"char_start": 187, "char_end": 231, "chars": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n"}, {"char_start": 280, "char_end": 282, "chars": "cl"}, {"char_start": 283, "char_end": 284, "chars": "a"}, {"char_start": 324, "char_end": 342, "chars": "\n\t\treturn err;\n\t}\n"}], "added": [{"char_start": 236, "char_end": 237, "chars": "r"}, {"char_start": 238, "char_end": 245, "chars": "turn er"}, {"char_start": 246, "char_end": 256, "chars": ";\n\t}\n\n\tset"}]}, "commit_link": "github.com/torvalds/linux/commit/56897b217a1d0a91c9920cb418d6b3fe922f590a", "file_name": "drivers/bluetooth/hci_ldisc.c", "vul_type": "cwe-416"}
{"func_name": "rm_read_multi", "func_src_before": "static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n                         AVStream *st, char *mime)\n{\n    int number_of_streams = avio_rb16(pb);\n    int number_of_mdpr;\n    int i, ret;\n    unsigned size2;\n    for (i = 0; i<number_of_streams; i++)\n        avio_rb16(pb);\n    number_of_mdpr = avio_rb16(pb);\n    if (number_of_mdpr != 1) {\n        avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);\n    }\n    for (i = 0; i < number_of_mdpr; i++) {\n        AVStream *st2;\n        if (i > 0) {\n            st2 = avformat_new_stream(s, NULL);\n            if (!st2) {\n                ret = AVERROR(ENOMEM);\n                return ret;\n            }\n            st2->id = st->id + (i<<16);\n            st2->codecpar->bit_rate = st->codecpar->bit_rate;\n            st2->start_time = st->start_time;\n            st2->duration   = st->duration;\n            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st2->priv_data = ff_rm_alloc_rmstream();\n            if (!st2->priv_data)\n                return AVERROR(ENOMEM);\n        } else\n            st2 = st;\n\n        size2 = avio_rb32(pb);\n        ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n                                        size2, mime);\n        if (ret < 0)\n            return ret;\n    }\n    return 0;\n}", "func_src_after": "static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n                         AVStream *st, char *mime)\n{\n    int number_of_streams = avio_rb16(pb);\n    int number_of_mdpr;\n    int i, ret;\n    unsigned size2;\n    for (i = 0; i<number_of_streams; i++)\n        avio_rb16(pb);\n    number_of_mdpr = avio_rb16(pb);\n    if (number_of_mdpr != 1) {\n        avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);\n    }\n    for (i = 0; i < number_of_mdpr; i++) {\n        AVStream *st2;\n        if (i > 0) {\n            st2 = avformat_new_stream(s, NULL);\n            if (!st2) {\n                ret = AVERROR(ENOMEM);\n                return ret;\n            }\n            st2->id = st->id + (i<<16);\n            st2->codecpar->bit_rate = st->codecpar->bit_rate;\n            st2->start_time = st->start_time;\n            st2->duration   = st->duration;\n            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st2->priv_data = ff_rm_alloc_rmstream();\n            if (!st2->priv_data)\n                return AVERROR(ENOMEM);\n        } else\n            st2 = st;\n\n        size2 = avio_rb32(pb);\n        ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n                                        size2, NULL);\n        if (ret < 0)\n            return ret;\n    }\n    return 0;\n}", "line_changes": {"deleted": [{"line_no": 35, "char_start": 1195, "char_end": 1249, "line": "                                        size2, mime);\n"}], "added": [{"line_no": 35, "char_start": 1195, "char_end": 1249, "line": "                                        size2, NULL);\n"}]}, "char_changes": {"deleted": [{"char_start": 1242, "char_end": 1246, "chars": "mime"}], "added": [{"char_start": 1242, "char_end": 1246, "chars": "NULL"}]}, "commit_link": "github.com/FFmpeg/FFmpeg/commit/a7e032a277452366771951e29fd0bf2bd5c029f0", "file_name": "libavformat/rmdec.c", "vul_type": "cwe-416"}
{"func_name": "HeifContext::interpret_heif_file", "func_src_before": "Error HeifContext::interpret_heif_file()\n{\n  m_all_images.clear();\n  m_top_level_images.clear();\n  m_primary_image.reset();\n\n\n  // --- reference all non-hidden images\n\n  std::vector<heif_item_id> image_IDs = m_heif_file->get_item_IDs();\n\n  bool primary_is_grid = false;\n  for (heif_item_id id : image_IDs) {\n    auto infe_box = m_heif_file->get_infe_box(id);\n    if (!infe_box) {\n      // TODO(farindk): Should we return an error instead of skipping the invalid id?\n      continue;\n    }\n\n    if (item_type_is_image(infe_box->get_item_type())) {\n      auto image = std::make_shared<Image>(this, id);\n      m_all_images.insert(std::make_pair(id, image));\n\n      if (!infe_box->is_hidden_item()) {\n        if (id==m_heif_file->get_primary_image_ID()) {\n          image->set_primary(true);\n          m_primary_image = image;\n          primary_is_grid = infe_box->get_item_type() == \"grid\";\n        }\n\n        m_top_level_images.push_back(image);\n      }\n    }\n  }\n\n\n  if (!m_primary_image) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Nonexisting_item_referenced,\n                 \"'pitm' box references a non-existing image\");\n  }\n\n\n  // --- remove thumbnails from top-level images and assign to their respective image\n\n  auto iref_box = m_heif_file->get_iref_box();\n  if (iref_box) {\n    // m_top_level_images.clear();\n\n    for (auto& pair : m_all_images) {\n      auto& image = pair.second;\n\n      std::vector<Box_iref::Reference> references = iref_box->get_references_from(image->get_id());\n\n      for (const Box_iref::Reference& ref : references) {\n        uint32_t type = ref.header.get_short_type();\n\n        if (type==fourcc(\"thmb\")) {\n          // --- this is a thumbnail image, attach to the main image\n\n          std::vector<heif_item_id> refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         \"Too many thumbnail references\");\n          }\n\n          image->set_is_thumbnail_of(refs[0]);\n\n          auto master_iter = m_all_images.find(refs[0]);\n          if (master_iter == m_all_images.end()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Thumbnail references a non-existing image\");\n          }\n\n          if (master_iter->second->is_thumbnail()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Thumbnail references another thumbnail\");\n          }\n\n          if (image.get() == master_iter->second.get()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Recursive thumbnail image detected\");\n          }\n          master_iter->second->add_thumbnail(image);\n\n          remove_top_level_image(image);\n        }\n        else if (type==fourcc(\"auxl\")) {\n\n          // --- this is an auxiliary image\n          //     check whether it is an alpha channel and attach to the main image if yes\n\n          std::vector<Box_ipco::Property> properties;\n          Error err = m_heif_file->get_properties(image->get_id(), properties);\n          if (err) {\n            return err;\n          }\n\n          std::shared_ptr<Box_auxC> auxC_property;\n          for (const auto& property : properties) {\n            auto auxC = std::dynamic_pointer_cast<Box_auxC>(property.property);\n            if (auxC) {\n              auxC_property = auxC;\n            }\n          }\n\n          if (!auxC_property) {\n            std::stringstream sstr;\n            sstr << \"No auxC property for image \" << image->get_id();\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Auxiliary_image_type_unspecified,\n                         sstr.str());\n          }\n\n          std::vector<heif_item_id> refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         \"Too many auxiliary image references\");\n          }\n\n\n          // alpha channel\n\n          if (auxC_property->get_aux_type() == \"urn:mpeg:avc:2015:auxid:1\" ||\n              auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:1\") {\n            image->set_is_alpha_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (image.get() == master_iter->second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Recursive alpha image detected\");\n            }\n            master_iter->second->set_alpha_channel(image);\n          }\n\n\n          // depth channel\n\n          if (auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:2\") {\n            image->set_is_depth_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (image.get() == master_iter->second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Recursive depth image detected\");\n            }\n            master_iter->second->set_depth_channel(image);\n\n            auto subtypes = auxC_property->get_subtypes();\n\n            std::vector<std::shared_ptr<SEIMessage>> sei_messages;\n            Error err = decode_hevc_aux_sei_messages(subtypes, sei_messages);\n\n            for (auto& msg : sei_messages) {\n              auto depth_msg = std::dynamic_pointer_cast<SEIMessage_depth_representation_info>(msg);\n              if (depth_msg) {\n                image->set_depth_representation_info(*depth_msg);\n              }\n            }\n          }\n\n          remove_top_level_image(image);\n        }\n        else {\n          // 'image' is a normal image, keep it as a top-level image\n        }\n      }\n    }\n  }\n\n\n  // --- check that HEVC images have an hvcC property\n\n  for (auto& pair : m_all_images) {\n    auto& image = pair.second;\n\n    std::shared_ptr<Box_infe> infe = m_heif_file->get_infe_box(image->get_id());\n    if (infe->get_item_type() == \"hvc1\") {\n\n      auto ipma = m_heif_file->get_ipma_box();\n      auto ipco = m_heif_file->get_ipco_box();\n\n      if (!ipco->get_property_for_item_ID(image->get_id(), ipma, fourcc(\"hvcC\"))) {\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_No_hvcC_box,\n                     \"No hvcC property in hvc1 type image\");\n      }\n    }\n  }\n\n\n  // --- read through properties for each image and extract image resolutions\n\n  for (auto& pair : m_all_images) {\n    auto& image = pair.second;\n\n    std::vector<Box_ipco::Property> properties;\n\n    Error err = m_heif_file->get_properties(pair.first, properties);\n    if (err) {\n      return err;\n    }\n\n    bool ispe_read = false;\n    bool primary_colr_set = false;\n    for (const auto& prop : properties) {\n      auto ispe = std::dynamic_pointer_cast<Box_ispe>(prop.property);\n      if (ispe) {\n        uint32_t width = ispe->get_width();\n        uint32_t height = ispe->get_height();\n\n\n        // --- check whether the image size is \"too large\"\n\n        if (width  >= static_cast<uint32_t>(MAX_IMAGE_WIDTH) ||\n            height >= static_cast<uint32_t>(MAX_IMAGE_HEIGHT)) {\n          std::stringstream sstr;\n          sstr << \"Image size \" << width << \"x\" << height << \" exceeds the maximum image size \"\n               << MAX_IMAGE_WIDTH << \"x\" << MAX_IMAGE_HEIGHT << \"\\n\";\n\n          return Error(heif_error_Memory_allocation_error,\n                       heif_suberror_Security_limit_exceeded,\n                       sstr.str());\n        }\n\n        image->set_resolution(width, height);\n        image->set_ispe_resolution(width, height);\n        ispe_read = true;\n      }\n\n      if (ispe_read) {\n        auto clap = std::dynamic_pointer_cast<Box_clap>(prop.property);\n        if (clap) {\n          image->set_resolution( clap->get_width_rounded(),\n                                 clap->get_height_rounded() );\n        }\n\n        auto irot = std::dynamic_pointer_cast<Box_irot>(prop.property);\n        if (irot) {\n          if (irot->get_rotation()==90 ||\n              irot->get_rotation()==270) {\n            // swap width and height\n            image->set_resolution( image->get_height(),\n                                   image->get_width() );\n          }\n        }\n      }\n\n      auto colr = std::dynamic_pointer_cast<Box_colr>(prop.property);\n      if (colr) {\n        auto profile = colr->get_color_profile();\n\n        image->set_color_profile(profile);\n\n        // if this is a grid item we assign the first one's color profile\n        // to the main image which is supposed to be a grid\n\n        // TODO: this condition is not correct. It would also classify a secondary image as a 'grid item'.\n        // We have to set the grid-image color profile in another way...\n        const bool is_grid_item = !image->is_primary() && !image->is_alpha_channel() && !image->is_depth_channel();\n\n        if (primary_is_grid &&\n            !primary_colr_set &&\n            is_grid_item) {\n          m_primary_image->set_color_profile(profile);\n          primary_colr_set = true;\n        }\n      }\n    }\n  }\n\n\n  // --- read metadata and assign to image\n\n  for (heif_item_id id : image_IDs) {\n    std::string item_type    = m_heif_file->get_item_type(id);\n    std::string content_type = m_heif_file->get_content_type(id);\n    if (item_type == \"Exif\" ||\n        (item_type==\"mime\" && content_type==\"application/rdf+xml\")) {\n      std::shared_ptr<ImageMetadata> metadata = std::make_shared<ImageMetadata>();\n      metadata->item_id = id;\n      metadata->item_type = item_type;\n      metadata->content_type = content_type;\n\n      Error err = m_heif_file->get_compressed_image_data(id, &(metadata->m_data));\n      if (err) {\n        return err;\n      }\n\n      //std::cerr.write((const char*)data.data(), data.size());\n\n\n      // --- assign metadata to the image\n\n      if (iref_box) {\n        std::vector<Box_iref::Reference> references = iref_box->get_references_from(id);\n        for (const auto& ref : references) {\n          if (ref.header.get_short_type() == fourcc(\"cdsc\")) {\n            std::vector<uint32_t> refs = ref.to_item_ID;\n            if (refs.size() != 1) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Unspecified,\n                           \"Exif data not correctly assigned to image\");\n            }\n\n            uint32_t exif_image_id = refs[0];\n            auto img_iter = m_all_images.find(exif_image_id);\n            if (img_iter == m_all_images.end()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Exif data assigned to non-existing image\");\n            }\n\n            img_iter->second->add_metadata(metadata);\n          }\n        }\n      }\n    }\n  }\n\n  return Error::Ok;\n}", "func_src_after": "Error HeifContext::interpret_heif_file()\n{\n  m_all_images.clear();\n  m_top_level_images.clear();\n  m_primary_image.reset();\n\n\n  // --- reference all non-hidden images\n\n  std::vector<heif_item_id> image_IDs = m_heif_file->get_item_IDs();\n\n  bool primary_is_grid = false;\n  for (heif_item_id id : image_IDs) {\n    auto infe_box = m_heif_file->get_infe_box(id);\n    if (!infe_box) {\n      // TODO(farindk): Should we return an error instead of skipping the invalid id?\n      continue;\n    }\n\n    if (item_type_is_image(infe_box->get_item_type())) {\n      auto image = std::make_shared<Image>(this, id);\n      m_all_images.insert(std::make_pair(id, image));\n\n      if (!infe_box->is_hidden_item()) {\n        if (id==m_heif_file->get_primary_image_ID()) {\n          image->set_primary(true);\n          m_primary_image = image;\n          primary_is_grid = infe_box->get_item_type() == \"grid\";\n        }\n\n        m_top_level_images.push_back(image);\n      }\n    }\n  }\n\n\n  if (!m_primary_image) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Nonexisting_item_referenced,\n                 \"'pitm' box references a non-existing image\");\n  }\n\n\n  // --- remove thumbnails from top-level images and assign to their respective image\n\n  auto iref_box = m_heif_file->get_iref_box();\n  if (iref_box) {\n    // m_top_level_images.clear();\n\n    for (auto& pair : m_all_images) {\n      auto& image = pair.second;\n\n      std::vector<Box_iref::Reference> references = iref_box->get_references_from(image->get_id());\n\n      for (const Box_iref::Reference& ref : references) {\n        uint32_t type = ref.header.get_short_type();\n\n        if (type==fourcc(\"thmb\")) {\n          // --- this is a thumbnail image, attach to the main image\n\n          std::vector<heif_item_id> refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         \"Too many thumbnail references\");\n          }\n\n          image->set_is_thumbnail_of(refs[0]);\n\n          auto master_iter = m_all_images.find(refs[0]);\n          if (master_iter == m_all_images.end()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Thumbnail references a non-existing image\");\n          }\n\n          if (master_iter->second->is_thumbnail()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Thumbnail references another thumbnail\");\n          }\n\n          if (image.get() == master_iter->second.get()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Recursive thumbnail image detected\");\n          }\n          master_iter->second->add_thumbnail(image);\n\n          remove_top_level_image(image);\n        }\n        else if (type==fourcc(\"auxl\")) {\n\n          // --- this is an auxiliary image\n          //     check whether it is an alpha channel and attach to the main image if yes\n\n          std::vector<Box_ipco::Property> properties;\n          Error err = m_heif_file->get_properties(image->get_id(), properties);\n          if (err) {\n            return err;\n          }\n\n          std::shared_ptr<Box_auxC> auxC_property;\n          for (const auto& property : properties) {\n            auto auxC = std::dynamic_pointer_cast<Box_auxC>(property.property);\n            if (auxC) {\n              auxC_property = auxC;\n            }\n          }\n\n          if (!auxC_property) {\n            std::stringstream sstr;\n            sstr << \"No auxC property for image \" << image->get_id();\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Auxiliary_image_type_unspecified,\n                         sstr.str());\n          }\n\n          std::vector<heif_item_id> refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         \"Too many auxiliary image references\");\n          }\n\n\n          // alpha channel\n\n          if (auxC_property->get_aux_type() == \"urn:mpeg:avc:2015:auxid:1\" ||\n              auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:1\") {\n            image->set_is_alpha_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (master_iter == m_all_images.end()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Non-existing alpha image referenced\");\n            }\n            if (image.get() == master_iter->second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Recursive alpha image detected\");\n            }\n            master_iter->second->set_alpha_channel(image);\n          }\n\n\n          // depth channel\n\n          if (auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:2\") {\n            image->set_is_depth_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (image.get() == master_iter->second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Recursive depth image detected\");\n            }\n            master_iter->second->set_depth_channel(image);\n\n            auto subtypes = auxC_property->get_subtypes();\n\n            std::vector<std::shared_ptr<SEIMessage>> sei_messages;\n            Error err = decode_hevc_aux_sei_messages(subtypes, sei_messages);\n\n            for (auto& msg : sei_messages) {\n              auto depth_msg = std::dynamic_pointer_cast<SEIMessage_depth_representation_info>(msg);\n              if (depth_msg) {\n                image->set_depth_representation_info(*depth_msg);\n              }\n            }\n          }\n\n          remove_top_level_image(image);\n        }\n        else {\n          // 'image' is a normal image, keep it as a top-level image\n        }\n      }\n    }\n  }\n\n\n  // --- check that HEVC images have an hvcC property\n\n  for (auto& pair : m_all_images) {\n    auto& image = pair.second;\n\n    std::shared_ptr<Box_infe> infe = m_heif_file->get_infe_box(image->get_id());\n    if (infe->get_item_type() == \"hvc1\") {\n\n      auto ipma = m_heif_file->get_ipma_box();\n      auto ipco = m_heif_file->get_ipco_box();\n\n      if (!ipco->get_property_for_item_ID(image->get_id(), ipma, fourcc(\"hvcC\"))) {\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_No_hvcC_box,\n                     \"No hvcC property in hvc1 type image\");\n      }\n    }\n  }\n\n\n  // --- read through properties for each image and extract image resolutions\n\n  for (auto& pair : m_all_images) {\n    auto& image = pair.second;\n\n    std::vector<Box_ipco::Property> properties;\n\n    Error err = m_heif_file->get_properties(pair.first, properties);\n    if (err) {\n      return err;\n    }\n\n    bool ispe_read = false;\n    bool primary_colr_set = false;\n    for (const auto& prop : properties) {\n      auto ispe = std::dynamic_pointer_cast<Box_ispe>(prop.property);\n      if (ispe) {\n        uint32_t width = ispe->get_width();\n        uint32_t height = ispe->get_height();\n\n\n        // --- check whether the image size is \"too large\"\n\n        if (width  >= static_cast<uint32_t>(MAX_IMAGE_WIDTH) ||\n            height >= static_cast<uint32_t>(MAX_IMAGE_HEIGHT)) {\n          std::stringstream sstr;\n          sstr << \"Image size \" << width << \"x\" << height << \" exceeds the maximum image size \"\n               << MAX_IMAGE_WIDTH << \"x\" << MAX_IMAGE_HEIGHT << \"\\n\";\n\n          return Error(heif_error_Memory_allocation_error,\n                       heif_suberror_Security_limit_exceeded,\n                       sstr.str());\n        }\n\n        image->set_resolution(width, height);\n        image->set_ispe_resolution(width, height);\n        ispe_read = true;\n      }\n\n      if (ispe_read) {\n        auto clap = std::dynamic_pointer_cast<Box_clap>(prop.property);\n        if (clap) {\n          image->set_resolution( clap->get_width_rounded(),\n                                 clap->get_height_rounded() );\n        }\n\n        auto irot = std::dynamic_pointer_cast<Box_irot>(prop.property);\n        if (irot) {\n          if (irot->get_rotation()==90 ||\n              irot->get_rotation()==270) {\n            // swap width and height\n            image->set_resolution( image->get_height(),\n                                   image->get_width() );\n          }\n        }\n      }\n\n      auto colr = std::dynamic_pointer_cast<Box_colr>(prop.property);\n      if (colr) {\n        auto profile = colr->get_color_profile();\n\n        image->set_color_profile(profile);\n\n        // if this is a grid item we assign the first one's color profile\n        // to the main image which is supposed to be a grid\n\n        // TODO: this condition is not correct. It would also classify a secondary image as a 'grid item'.\n        // We have to set the grid-image color profile in another way...\n        const bool is_grid_item = !image->is_primary() && !image->is_alpha_channel() && !image->is_depth_channel();\n\n        if (primary_is_grid &&\n            !primary_colr_set &&\n            is_grid_item) {\n          m_primary_image->set_color_profile(profile);\n          primary_colr_set = true;\n        }\n      }\n    }\n  }\n\n\n  // --- read metadata and assign to image\n\n  for (heif_item_id id : image_IDs) {\n    std::string item_type    = m_heif_file->get_item_type(id);\n    std::string content_type = m_heif_file->get_content_type(id);\n    if (item_type == \"Exif\" ||\n        (item_type==\"mime\" && content_type==\"application/rdf+xml\")) {\n      std::shared_ptr<ImageMetadata> metadata = std::make_shared<ImageMetadata>();\n      metadata->item_id = id;\n      metadata->item_type = item_type;\n      metadata->content_type = content_type;\n\n      Error err = m_heif_file->get_compressed_image_data(id, &(metadata->m_data));\n      if (err) {\n        return err;\n      }\n\n      //std::cerr.write((const char*)data.data(), data.size());\n\n\n      // --- assign metadata to the image\n\n      if (iref_box) {\n        std::vector<Box_iref::Reference> references = iref_box->get_references_from(id);\n        for (const auto& ref : references) {\n          if (ref.header.get_short_type() == fourcc(\"cdsc\")) {\n            std::vector<uint32_t> refs = ref.to_item_ID;\n            if (refs.size() != 1) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Unspecified,\n                           \"Exif data not correctly assigned to image\");\n            }\n\n            uint32_t exif_image_id = refs[0];\n            auto img_iter = m_all_images.find(exif_image_id);\n            if (img_iter == m_all_images.end()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Exif data assigned to non-existing image\");\n            }\n\n            img_iter->second->add_metadata(metadata);\n          }\n        }\n      }\n    }\n  }\n\n  return Error::Ok;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 134, "char_start": 4504, "char_end": 4557, "line": "            if (master_iter == m_all_images.end()) {\n"}, {"line_no": 135, "char_start": 4557, "char_end": 4610, "line": "              return Error(heif_error_Invalid_input,\n"}, {"line_no": 136, "char_start": 4610, "char_end": 4680, "line": "                           heif_suberror_Nonexisting_item_referenced,\n"}, {"line_no": 137, "char_start": 4680, "char_end": 4747, "line": "                           \"Non-existing alpha image referenced\");\n"}, {"line_no": 138, "char_start": 4747, "char_end": 4761, "line": "            }\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 4520, "char_end": 4777, "chars": "master_iter == m_all_images.end()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Non-existing alpha image referenced\");\n            }\n            if ("}]}, "commit_link": "github.com/strukturag/libheif/commit/995a4283d8ed2d0d2c1ceb1a577b993df2f0e014", "file_name": "libheif/heif_context.cc", "vul_type": "cwe-416"}
{"func_name": "PlayerGeneric::~PlayerGeneric", "func_src_before": "PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\n\tdelete[] audioDriverName;\n\t\n\tdelete listener;\n}", "func_src_after": "PlayerGeneric::~PlayerGeneric()\n{\n\n\tif (player)\n\t{\n\t\tif (mixer && mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\t\n\tif (mixer)\n\t\tdelete mixer;\n\n\tdelete[] audioDriverName;\n\t\n\tdelete listener;\n}", "line_changes": {"deleted": [{"line_no": 3, "char_start": 34, "char_end": 46, "line": "\tif (mixer)\n"}, {"line_no": 4, "char_start": 46, "char_end": 62, "line": "\t\tdelete mixer;\n"}, {"line_no": 8, "char_start": 79, "char_end": 139, "line": "\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n"}], "added": [{"line_no": 6, "char_start": 51, "char_end": 120, "line": "\t\tif (mixer && mixer->isActive() && !mixer->isDeviceRemoved(player))\n"}, {"line_no": 10, "char_start": 172, "char_end": 174, "line": "\t\n"}, {"line_no": 11, "char_start": 174, "char_end": 186, "line": "\tif (mixer)\n"}, {"line_no": 12, "char_start": 186, "char_end": 202, "line": "\t\tdelete mixer;\n"}]}, "char_changes": {"deleted": [{"char_start": 34, "char_end": 62, "chars": "\tif (mixer)\n\t\tdelete mixer;\n"}], "added": [{"char_start": 57, "char_end": 66, "chars": "mixer && "}, {"char_start": 171, "char_end": 201, "chars": "\n\t\n\tif (mixer)\n\t\tdelete mixer;"}]}, "commit_link": "github.com/milkytracker/MilkyTracker/commit/7afd55c42ad80d01a339197a2d8b5461d214edaf", "file_name": "src/milkyplay/PlayerGeneric.cpp", "vul_type": "cwe-416"}
{"func_name": "vips_foreign_load_gif_scan_image", "func_src_before": "vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\tGifFileType *file = gif->file;\n\tColorMapObject *map = file->Image.ColorMap ?\n\t\tfile->Image.ColorMap : file->SColorMap;\n\n\tGifByteType *extension;\n\n\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\n\t/* Check that the frame looks sane. Perhaps giflib checks\n\t * this for us.\n\t */\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n\n\t/* Test for a non-greyscale colourmap for this frame.\n\t */\n\tif( !gif->has_colour &&\n\t\tmap ) {\n\t\tint i;\n\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/* Step over compressed image data.\n\t */\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\n\treturn( 0 );\n}", "func_src_after": "vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\tGifFileType *file = gif->file;\n\n\tColorMapObject *map;\n\tGifByteType *extension;\n\n\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\n\t/* Check that the frame looks sane. Perhaps giflib checks\n\t * this for us.\n\t */\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n\n\t/* Test for a non-greyscale colourmap for this frame.\n\t */\n\tmap = file->Image.ColorMap ? file->Image.ColorMap : file->SColorMap;\n\tif( !gif->has_colour &&\n\t\tmap ) {\n\t\tint i;\n\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/* Step over compressed image data.\n\t */\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\n\treturn( 0 );\n}", "line_changes": {"deleted": [{"line_no": 5, "char_start": 151, "char_end": 197, "line": "\tColorMapObject *map = file->Image.ColorMap ?\n"}, {"line_no": 6, "char_start": 197, "char_end": 239, "line": "\t\tfile->Image.ColorMap : file->SColorMap;\n"}], "added": [{"line_no": 6, "char_start": 152, "char_end": 174, "line": "\tColorMapObject *map;\n"}, {"line_no": 31, "char_start": 824, "char_end": 894, "line": "\tmap = file->Image.ColorMap ? file->Image.ColorMap : file->SColorMap;\n"}]}, "char_changes": {"deleted": [{"char_start": 171, "char_end": 237, "chars": " = file->Image.ColorMap ?\n\t\tfile->Image.ColorMap : file->SColorMap"}, {"char_start": 238, "char_end": 239, "chars": "\n"}], "added": [{"char_start": 151, "char_end": 152, "chars": "\n"}, {"char_start": 823, "char_end": 893, "chars": "\n\tmap = file->Image.ColorMap ? file->Image.ColorMap : file->SColorMap;"}]}, "commit_link": "github.com/libvips/libvips/commit/ce684dd008532ea0bf9d4a1d89bacb35f4a83f4d", "file_name": "libvips/foreign/gifload.c", "vul_type": "cwe-416"}
{"func_name": "ReadMATImage", "func_src_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}", "func_src_after": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}", "line_changes": {"deleted": [{"line_no": 489, "char_start": 16851, "char_end": 16869, "line": "  if (clone_info)\n"}, {"line_no": 490, "char_start": 16869, "char_end": 16914, "line": "    clone_info=DestroyImageInfo(clone_info);\n"}], "added": [{"line_no": 506, "char_start": 17156, "char_end": 17185, "line": "          if (tmp == image2)\n"}, {"line_no": 507, "char_start": 17185, "char_end": 17220, "line": "            image2=(Image *) NULL;\n"}]}, "char_changes": {"deleted": [{"char_start": 16853, "char_end": 16916, "chars": "if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  "}], "added": [{"char_start": 17154, "char_end": 17218, "chars": ";\n          if (tmp == image2)\n            image2=(Image *) NULL"}]}, "commit_link": "github.com/ImageMagick/ImageMagick/commit/04178de2247e353fc095846784b9a10fefdbf890", "file_name": "coders/mat.c", "vul_type": "cwe-416"}
{"func_name": "opj_j2k_write_mco", "func_src_before": "static OPJ_BOOL opj_j2k_write_mco(     opj_j2k_t *p_j2k,\n                                                struct opj_stream_private *p_stream,\n                                                struct opj_event_mgr * p_manager\n                                  )\n{\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_mco_size;\n        opj_tcp_t * l_tcp = 00;\n        opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n        OPJ_UINT32 i;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tcp =&(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        l_mco_size = 5 + l_tcp->m_nb_mcc_records;\n        if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mco_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCO marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;\n        }\n\n        opj_write_bytes(l_current_data,J2K_MS_MCO,2);                   /* MCO */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_mco_size-2,2);                 /* Lmco */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_tcp->m_nb_mcc_records,1);      /* Nmco : only one tranform stage*/\n        ++l_current_data;\n\n        l_mcc_record = l_tcp->m_mcc_records;\n        for     (i=0;i<l_tcp->m_nb_mcc_records;++i) {\n                opj_write_bytes(l_current_data,l_mcc_record->m_index,1);/* Imco -> use the mcc indicated by 1*/\n                ++l_current_data;\n\n                ++l_mcc_record;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_mco_size,p_manager) != l_mco_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}", "func_src_after": "static OPJ_BOOL opj_j2k_write_mco(     opj_j2k_t *p_j2k,\n                                                struct opj_stream_private *p_stream,\n                                                struct opj_event_mgr * p_manager\n                                  )\n{\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_mco_size;\n        opj_tcp_t * l_tcp = 00;\n        opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n        OPJ_UINT32 i;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tcp =&(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n\t\n        l_mco_size = 5 + l_tcp->m_nb_mcc_records;\n        if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mco_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCO marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;\n        }\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n\n        opj_write_bytes(l_current_data,J2K_MS_MCO,2);                   /* MCO */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_mco_size-2,2);                 /* Lmco */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_tcp->m_nb_mcc_records,1);      /* Nmco : only one tranform stage*/\n        ++l_current_data;\n\n        l_mcc_record = l_tcp->m_mcc_records;\n        for (i=0;i<l_tcp->m_nb_mcc_records;++i) {\n                opj_write_bytes(l_current_data,l_mcc_record->m_index,1);/* Imco -> use the mcc indicated by 1*/\n                ++l_current_data;\n                ++l_mcc_record;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_mco_size,p_manager) != l_mco_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}", "line_changes": {"deleted": [{"line_no": 18, "char_start": 636, "char_end": 715, "line": "        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n"}, {"line_no": 19, "char_start": 715, "char_end": 716, "line": "\n"}, {"line_no": 45, "char_start": 2061, "char_end": 2115, "line": "        for     (i=0;i<l_tcp->m_nb_mcc_records;++i) {\n"}, {"line_no": 48, "char_start": 2261, "char_end": 2262, "line": "\n"}], "added": [{"line_no": 18, "char_start": 636, "char_end": 638, "line": "\t\n"}, {"line_no": 33, "char_start": 1577, "char_end": 1656, "line": "        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n"}, {"line_no": 34, "char_start": 1656, "char_end": 1657, "line": "\n"}, {"line_no": 46, "char_start": 2063, "char_end": 2113, "line": "        for (i=0;i<l_tcp->m_nb_mcc_records;++i) {\n"}]}, "char_changes": {"deleted": [{"char_start": 636, "char_end": 715, "chars": "        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n"}, {"char_start": 2073, "char_end": 2077, "chars": "    "}, {"char_start": 2260, "char_end": 2261, "chars": "\n"}], "added": [{"char_start": 636, "char_end": 637, "chars": "\t"}, {"char_start": 1577, "char_end": 1657, "chars": "        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n"}]}, "commit_link": "github.com/uclouvain/openjpeg/commit/940100c28ae28931722290794889cf84a92c5f6f", "file_name": "src/lib/openjp2/j2k.c", "vul_type": "cwe-416"}
{"func_name": "tcpmss_mangle_packet", "func_src_before": "tcpmss_mangle_packet(struct sk_buff *skb,\n\t\t     const struct xt_action_param *par,\n\t\t     unsigned int family,\n\t\t     unsigned int tcphoff,\n\t\t     unsigned int minlen)\n{\n\tconst struct xt_tcpmss_info *info = par->targinfo;\n\tstruct tcphdr *tcph;\n\tint len, tcp_hdrlen;\n\tunsigned int i;\n\t__be16 oldval;\n\tu16 newmss;\n\tu8 *opt;\n\n\t/* This is a fragment, no TCP header is available */\n\tif (par->fragoff != 0)\n\t\treturn 0;\n\n\tif (!skb_make_writable(skb, skb->len))\n\t\treturn -1;\n\n\tlen = skb->len - tcphoff;\n\tif (len < (int)sizeof(struct tcphdr))\n\t\treturn -1;\n\n\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\ttcp_hdrlen = tcph->doff * 4;\n\n\tif (len < tcp_hdrlen)\n\t\treturn -1;\n\n\tif (info->mss == XT_TCPMSS_CLAMP_PMTU) {\n\t\tstruct net *net = xt_net(par);\n\t\tunsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);\n\t\tunsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);\n\n\t\tif (min_mtu <= minlen) {\n\t\t\tnet_err_ratelimited(\"unknown or invalid path-MTU (%u)\\n\",\n\t\t\t\t\t    min_mtu);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmss = min_mtu - minlen;\n\t} else\n\t\tnewmss = info->mss;\n\n\topt = (u_int8_t *)tcph;\n\tfor (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {\n\t\tif (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {\n\t\t\tu_int16_t oldmss;\n\n\t\t\toldmss = (opt[i+2] << 8) | opt[i+3];\n\n\t\t\t/* Never increase MSS, even when setting it, as\n\t\t\t * doing so results in problems for hosts that rely\n\t\t\t * on MSS being set correctly.\n\t\t\t */\n\t\t\tif (oldmss <= newmss)\n\t\t\t\treturn 0;\n\n\t\t\topt[i+2] = (newmss & 0xff00) >> 8;\n\t\t\topt[i+3] = newmss & 0x00ff;\n\n\t\t\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t\t\t htons(oldmss), htons(newmss),\n\t\t\t\t\t\t false);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* There is data after the header so the option can't be added\n\t * without moving it, and doing so may make the SYN packet\n\t * itself too large. Accept the packet unmodified instead.\n\t */\n\tif (len > tcp_hdrlen)\n\t\treturn 0;\n\n\t/*\n\t * MSS Option not found ?! add it..\n\t */\n\tif (skb_tailroom(skb) < TCPOLEN_MSS) {\n\t\tif (pskb_expand_head(skb, 0,\n\t\t\t\t     TCPOLEN_MSS - skb_tailroom(skb),\n\t\t\t\t     GFP_ATOMIC))\n\t\t\treturn -1;\n\t\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\t}\n\n\tskb_put(skb, TCPOLEN_MSS);\n\n\t/*\n\t * IPv4: RFC 1122 states \"If an MSS option is not received at\n\t * connection setup, TCP MUST assume a default send MSS of 536\".\n\t * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum\n\t * length IPv6 header of 60, ergo the default MSS value is 1220\n\t * Since no MSS was provided, we must use the default values\n\t */\n\tif (xt_family(par) == NFPROTO_IPV4)\n\t\tnewmss = min(newmss, (u16)536);\n\telse\n\t\tnewmss = min(newmss, (u16)1220);\n\n\topt = (u_int8_t *)tcph + sizeof(struct tcphdr);\n\tmemmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));\n\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t htons(len), htons(len + TCPOLEN_MSS), true);\n\topt[0] = TCPOPT_MSS;\n\topt[1] = TCPOLEN_MSS;\n\topt[2] = (newmss & 0xff00) >> 8;\n\topt[3] = newmss & 0x00ff;\n\n\tinet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);\n\n\toldval = ((__be16 *)tcph)[6];\n\ttcph->doff += TCPOLEN_MSS/4;\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t oldval, ((__be16 *)tcph)[6], false);\n\treturn TCPOLEN_MSS;\n}", "func_src_after": "tcpmss_mangle_packet(struct sk_buff *skb,\n\t\t     const struct xt_action_param *par,\n\t\t     unsigned int family,\n\t\t     unsigned int tcphoff,\n\t\t     unsigned int minlen)\n{\n\tconst struct xt_tcpmss_info *info = par->targinfo;\n\tstruct tcphdr *tcph;\n\tint len, tcp_hdrlen;\n\tunsigned int i;\n\t__be16 oldval;\n\tu16 newmss;\n\tu8 *opt;\n\n\t/* This is a fragment, no TCP header is available */\n\tif (par->fragoff != 0)\n\t\treturn 0;\n\n\tif (!skb_make_writable(skb, skb->len))\n\t\treturn -1;\n\n\tlen = skb->len - tcphoff;\n\tif (len < (int)sizeof(struct tcphdr))\n\t\treturn -1;\n\n\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\ttcp_hdrlen = tcph->doff * 4;\n\n\tif (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))\n\t\treturn -1;\n\n\tif (info->mss == XT_TCPMSS_CLAMP_PMTU) {\n\t\tstruct net *net = xt_net(par);\n\t\tunsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);\n\t\tunsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);\n\n\t\tif (min_mtu <= minlen) {\n\t\t\tnet_err_ratelimited(\"unknown or invalid path-MTU (%u)\\n\",\n\t\t\t\t\t    min_mtu);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmss = min_mtu - minlen;\n\t} else\n\t\tnewmss = info->mss;\n\n\topt = (u_int8_t *)tcph;\n\tfor (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {\n\t\tif (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {\n\t\t\tu_int16_t oldmss;\n\n\t\t\toldmss = (opt[i+2] << 8) | opt[i+3];\n\n\t\t\t/* Never increase MSS, even when setting it, as\n\t\t\t * doing so results in problems for hosts that rely\n\t\t\t * on MSS being set correctly.\n\t\t\t */\n\t\t\tif (oldmss <= newmss)\n\t\t\t\treturn 0;\n\n\t\t\topt[i+2] = (newmss & 0xff00) >> 8;\n\t\t\topt[i+3] = newmss & 0x00ff;\n\n\t\t\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t\t\t htons(oldmss), htons(newmss),\n\t\t\t\t\t\t false);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* There is data after the header so the option can't be added\n\t * without moving it, and doing so may make the SYN packet\n\t * itself too large. Accept the packet unmodified instead.\n\t */\n\tif (len > tcp_hdrlen)\n\t\treturn 0;\n\n\t/* tcph->doff has 4 bits, do not wrap it to 0 */\n\tif (tcp_hdrlen >= 15 * 4)\n\t\treturn 0;\n\n\t/*\n\t * MSS Option not found ?! add it..\n\t */\n\tif (skb_tailroom(skb) < TCPOLEN_MSS) {\n\t\tif (pskb_expand_head(skb, 0,\n\t\t\t\t     TCPOLEN_MSS - skb_tailroom(skb),\n\t\t\t\t     GFP_ATOMIC))\n\t\t\treturn -1;\n\t\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\t}\n\n\tskb_put(skb, TCPOLEN_MSS);\n\n\t/*\n\t * IPv4: RFC 1122 states \"If an MSS option is not received at\n\t * connection setup, TCP MUST assume a default send MSS of 536\".\n\t * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum\n\t * length IPv6 header of 60, ergo the default MSS value is 1220\n\t * Since no MSS was provided, we must use the default values\n\t */\n\tif (xt_family(par) == NFPROTO_IPV4)\n\t\tnewmss = min(newmss, (u16)536);\n\telse\n\t\tnewmss = min(newmss, (u16)1220);\n\n\topt = (u_int8_t *)tcph + sizeof(struct tcphdr);\n\tmemmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));\n\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t htons(len), htons(len + TCPOLEN_MSS), true);\n\topt[0] = TCPOPT_MSS;\n\topt[1] = TCPOLEN_MSS;\n\topt[2] = (newmss & 0xff00) >> 8;\n\topt[3] = newmss & 0x00ff;\n\n\tinet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);\n\n\toldval = ((__be16 *)tcph)[6];\n\ttcph->doff += TCPOLEN_MSS/4;\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t oldval, ((__be16 *)tcph)[6], false);\n\treturn TCPOLEN_MSS;\n}", "line_changes": {"deleted": [{"line_no": 29, "char_start": 642, "char_end": 665, "line": "\tif (len < tcp_hdrlen)\n"}], "added": [{"line_no": 29, "char_start": 642, "char_end": 703, "line": "\tif (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))\n"}, {"line_no": 77, "char_start": 1935, "char_end": 1985, "line": "\t/* tcph->doff has 4 bits, do not wrap it to 0 */\n"}, {"line_no": 78, "char_start": 1985, "char_end": 2012, "line": "\tif (tcp_hdrlen >= 15 * 4)\n"}, {"line_no": 79, "char_start": 2012, "char_end": 2024, "line": "\t\treturn 0;\n"}, {"line_no": 80, "char_start": 2024, "char_end": 2025, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 663, "char_end": 701, "chars": " || tcp_hdrlen < sizeof(struct tcphdr)"}, {"char_start": 1920, "char_end": 2010, "chars": ")\n\t\treturn 0;\n\n\t/* tcph->doff has 4 bits, do not wrap it to 0 */\n\tif (tcp_hdrlen >= 15 * 4"}]}, "commit_link": "github.com/torvalds/linux/commit/2638fd0f92d4397884fd991d8f4925cb3f081901", "file_name": "net/netfilter/xt_TCPMSS.c", "vul_type": "cwe-416"}
{"func_name": "luaD_shrinkstack", "func_src_before": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  /* respect stack limit */\n  /* if thread is currently not handling a stack overflow and its\n     good size is smaller than current size, shrink its stack */\n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n      goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  /* ok if that fails */\n  else  /* don't change stack */\n    condmovestack(L,{},{});  /* (change only for debugging) */\n  luaE_shrinkCI(L);  /* shrink CI list */\n}", "func_src_after": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + BASIC_STACK_SIZE;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  /* respect stack limit */\n  /* if thread is currently not handling a stack overflow and its\n     good size is smaller than current size, shrink its stack */\n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) && goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  /* ok if that fails */\n  else  /* don't change stack */\n    condmovestack(L,{},{});  /* (change only for debugging) */\n  luaE_shrinkCI(L);  /* shrink CI list */\n}", "line_changes": {"deleted": [{"line_no": 3, "char_start": 68, "char_end": 122, "line": "  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n"}, {"line_no": 8, "char_start": 342, "char_end": 390, "line": "  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n"}, {"line_no": 9, "char_start": 390, "char_end": 421, "line": "      goodsize < L->stacksize)\n"}], "added": [{"line_no": 3, "char_start": 68, "char_end": 111, "line": "  int goodsize = inuse + BASIC_STACK_SIZE;\n"}, {"line_no": 8, "char_start": 331, "char_end": 404, "line": "  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) && goodsize < L->stacksize)\n"}]}, "char_changes": {"deleted": [{"char_start": 93, "char_end": 113, "chars": "(inuse / 8) + 2*EXTR"}, {"char_start": 389, "char_end": 395, "chars": "\n     "}], "added": [{"char_start": 93, "char_end": 94, "chars": "B"}, {"char_start": 95, "char_end": 98, "chars": "SIC"}, {"char_start": 104, "char_end": 109, "chars": "_SIZE"}]}, "commit_link": "github.com/lua/lua/commit/6298903e35217ab69c279056f925fb72900ce0b7", "file_name": "ldo.c", "vul_type": "cwe-416"}
{"func_name": "mrb_vm_exec", "func_src_before": "mrb_vm_exec(mrb_state *mrb, struct RProc *proc, mrb_code *pc)\n{\n  /* mrb_assert(mrb_proc_cfunc_p(proc)) */\n  mrb_irep *irep = proc->body.irep;\n  mrb_value *pool = irep->pool;\n  mrb_sym *syms = irep->syms;\n  mrb_code i;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n\n#ifdef DIRECT_THREADED\n  static void *optable[] = {\n    &&L_OP_NOP, &&L_OP_MOVE,\n    &&L_OP_LOADL, &&L_OP_LOADI, &&L_OP_LOADSYM, &&L_OP_LOADNIL,\n    &&L_OP_LOADSELF, &&L_OP_LOADT, &&L_OP_LOADF,\n    &&L_OP_GETGLOBAL, &&L_OP_SETGLOBAL, &&L_OP_GETSPECIAL, &&L_OP_SETSPECIAL,\n    &&L_OP_GETIV, &&L_OP_SETIV, &&L_OP_GETCV, &&L_OP_SETCV,\n    &&L_OP_GETCONST, &&L_OP_SETCONST, &&L_OP_GETMCNST, &&L_OP_SETMCNST,\n    &&L_OP_GETUPVAR, &&L_OP_SETUPVAR,\n    &&L_OP_JMP, &&L_OP_JMPIF, &&L_OP_JMPNOT,\n    &&L_OP_ONERR, &&L_OP_RESCUE, &&L_OP_POPERR, &&L_OP_RAISE, &&L_OP_EPUSH, &&L_OP_EPOP,\n    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,\n    &&L_OP_CALL, &&L_OP_SUPER, &&L_OP_ARGARY, &&L_OP_ENTER,\n    &&L_OP_KARG, &&L_OP_KDICT, &&L_OP_RETURN, &&L_OP_TAILCALL, &&L_OP_BLKPUSH,\n    &&L_OP_ADD, &&L_OP_ADDI, &&L_OP_SUB, &&L_OP_SUBI, &&L_OP_MUL, &&L_OP_DIV,\n    &&L_OP_EQ, &&L_OP_LT, &&L_OP_LE, &&L_OP_GT, &&L_OP_GE,\n    &&L_OP_ARRAY, &&L_OP_ARYCAT, &&L_OP_ARYPUSH, &&L_OP_AREF, &&L_OP_ASET, &&L_OP_APOST,\n    &&L_OP_STRING, &&L_OP_STRCAT, &&L_OP_HASH,\n    &&L_OP_LAMBDA, &&L_OP_RANGE, &&L_OP_OCLASS,\n    &&L_OP_CLASS, &&L_OP_MODULE, &&L_OP_EXEC,\n    &&L_OP_METHOD, &&L_OP_SCLASS, &&L_OP_TCLASS,\n    &&L_OP_DEBUG, &&L_OP_STOP, &&L_OP_ERR,\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb->c->ci->proc = proc;\n  mrb->c->ci->nregs = irep->nregs;\n\n#define regs (mrb->c->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE) {\n      /* A B    R(A) := R(B) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL) {\n      /* A Bx   R(A) := Pool(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n#ifdef MRB_WORD_BOXING\n      mrb_value val = pool[bx];\n#ifndef MRB_WITHOUT_FLOAT\n      if (mrb_float_p(val)) {\n        val = mrb_float_value(mrb, mrb_float(val));\n      }\n#endif\n      regs[a] = val;\n#else\n      regs[a] = pool[bx];\n#endif\n      NEXT;\n    }\n\n    CASE(OP_LOADI) {\n      /* A sBx  R(A) := sBx */\n      int a = GETARG_A(i);\n      mrb_int bx = GETARG_sBx(i);\n      SET_INT_VALUE(regs[a], bx);\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM) {\n      /* A Bx   R(A) := Syms(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      SET_SYM_VALUE(regs[a], syms[bx]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF) {\n      /* A      R(A) := self */\n      int a = GETARG_A(i);\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT) {\n      /* A      R(A) := true */\n      int a = GETARG_A(i);\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF) {\n      /* A      R(A) := false */\n      int a = GETARG_A(i);\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGLOBAL) {\n      /* A Bx   R(A) := getglobal(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_gv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGLOBAL) {\n      /* A Bx   setglobal(Syms(Bx), R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_gv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSPECIAL) {\n      /* A Bx   R(A) := Special[Bx] */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_special_get(mrb, bx);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSPECIAL) {\n      /* A Bx   Special[Bx] := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_special_set(mrb, bx, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV) {\n      /* A Bx   R(A) := ivget(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_iv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETIV) {\n      /* A Bx   ivset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_iv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV) {\n      /* A Bx   R(A) := cvget(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val;\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_cv_get(mrb, syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV) {\n      /* A Bx   cvset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_cv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCONST) {\n      /* A Bx    R(A) := constget(Syms(Bx)) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_sym sym = syms[bx];\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_const_get(mrb, sym);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST) {\n      /* A Bx   constset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_const_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST) {\n      /* A Bx   R(A) := R(A)::Syms(Bx) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_const_get(mrb, regs[a], syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST) {\n      /* A Bx    R(A+1)::Syms(Bx) := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_const_set(mrb, regs[a+1], syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR) {\n      /* A B C  R(A) := uvget(B,C) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (!e) {\n        *regs_a = mrb_nil_value();\n      }\n      else {\n        *regs_a = e->stack[b];\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR) {\n      /* A B C  uvset(B,C,R(A)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_STACK_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP) {\n      /* sBx    pc+=sBx */\n      int sbx = GETARG_sBx(i);\n      pc += sbx;\n      JUMP;\n    }\n\n    CASE(OP_JMPIF) {\n      /* A sBx  if R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPNOT) {\n      /* A sBx  if !R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (!mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ONERR) {\n      /* sBx    pc+=sBx on exception */\n      int sbx = GETARG_sBx(i);\n      if (mrb->c->rsize <= mrb->c->ci->ridx) {\n        if (mrb->c->rsize == 0) mrb->c->rsize = RESCUE_STACK_INIT_SIZE;\n        else mrb->c->rsize *= 2;\n        mrb->c->rescue = (mrb_code **)mrb_realloc(mrb, mrb->c->rescue, sizeof(mrb_code*) * mrb->c->rsize);\n      }\n      mrb->c->rescue[mrb->c->ci->ridx++] = pc + sbx;\n      NEXT;\n    }\n\n    CASE(OP_RESCUE) {\n      /* A B    R(A) := exc; clear(exc); R(B) := matched (bool) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value exc;\n\n      if (c == 0) {\n        exc = mrb_obj_value(mrb->exc);\n        mrb->exc = 0;\n      }\n      else {           /* continued; exc taken from R(A) */\n        exc = regs[a];\n      }\n      if (b != 0) {\n        mrb_value e = regs[b];\n        struct RClass *ec;\n\n        switch (mrb_type(e)) {\n        case MRB_TT_CLASS:\n        case MRB_TT_MODULE:\n          break;\n        default:\n          {\n            mrb_value exc;\n\n            exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                  \"class or module required for rescue clause\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n        }\n        ec = mrb_class_ptr(e);\n        regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      }\n      if (a != 0 && c == 0) {\n        regs[a] = exc;\n      }\n      NEXT;\n    }\n\n    CASE(OP_POPERR) {\n      /* A      A.times{rescue_pop()} */\n      int a = GETARG_A(i);\n\n      mrb->c->ci->ridx -= a;\n      NEXT;\n    }\n\n    CASE(OP_RAISE) {\n      /* A      raise(R(A)) */\n      int a = GETARG_A(i);\n\n      mrb_exc_set(mrb, regs[a]);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EPUSH) {\n      /* Bx     ensure_push(SEQ[Bx]) */\n      int bx = GETARG_Bx(i);\n      struct RProc *p;\n\n      p = mrb_closure_new(mrb, irep->reps[bx]);\n      /* push ensure_stack */\n      if (mrb->c->esize <= mrb->c->eidx+1) {\n        if (mrb->c->esize == 0) mrb->c->esize = ENSURE_STACK_INIT_SIZE;\n        else mrb->c->esize *= 2;\n        mrb->c->ensure = (struct RProc **)mrb_realloc(mrb, mrb->c->ensure, sizeof(struct RProc*) * mrb->c->esize);\n      }\n      mrb->c->ensure[mrb->c->eidx++] = p;\n      mrb->c->ensure[mrb->c->eidx] = NULL;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EPOP) {\n      /* A      A.times{ensure_pop().call} */\n      int a = GETARG_A(i);\n      mrb_callinfo *ci = mrb->c->ci;\n      int n, epos = ci->epos;\n      mrb_value self = regs[0];\n      struct RClass *target_class = ci->target_class;\n\n      if (mrb->c->eidx <= epos) {\n        NEXT;\n      }\n\n      if (a > mrb->c->eidx - epos)\n        a = mrb->c->eidx - epos;\n      pc = pc + 1;\n      for (n=0; n<a; n++) {\n        proc = mrb->c->ensure[epos+n];\n        mrb->c->ensure[epos+n] = NULL;\n        if (proc == NULL) continue;\n        irep = proc->body.irep;\n        ci = cipush(mrb);\n        ci->mid = ci[-1].mid;\n        ci->argc = 0;\n        ci->proc = proc;\n        ci->stackent = mrb->c->stack;\n        ci->nregs = irep->nregs;\n        ci->target_class = target_class;\n        ci->pc = pc;\n        ci->acc = ci[-1].nregs;\n        mrb->c->stack += ci->acc;\n        stack_extend(mrb, ci->nregs);\n        regs[0] = self;\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb->c->eidx = epos;\n      JUMP;\n    }\n\n    CASE(OP_LOADNIL) {\n      /* A     R(A) := nil */\n      int a = GETARG_A(i);\n\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_SENDB) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C),&R(A+C+1))*/\n      /* fall through */\n    };\n\n  L_SEND:\n    CASE(OP_SEND) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = syms[GETARG_B(i)];\n\n      mrb_assert(bidx < ci->nregs);\n\n      recv = regs[a];\n      if (GET_OPCODE(i) != OP_SENDB) {\n        SET_NIL_VALUE(regs[bidx]);\n        blk = regs[bidx];\n      }\n      else {\n        blk = regs[bidx];\n        if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n          blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n          /* The stack might have been reallocated during mrb_convert_type(),\n             see #3622 */\n          regs[bidx] = blk;\n        }\n      }\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m) || (missing == mrb->c->ci->mid && mrb_obj_eq(mrb, regs[0], recv))) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        if (argc >= 0) {\n          if (a+2 >= irep->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));\n        mid = missing;\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->argc = argc;\n\n      ci->pc = pc + 1;\n      ci->acc = a;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          ci->proc = p;\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (GET_OPCODE(i) == OP_SENDB) {\n          if (mrb_type(blk) == MRB_TT_PROC) {\n            struct RProc *p = mrb_proc_ptr(blk);\n            if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == ci[-1].env) {\n              p->flags |= MRB_PROC_ORPHAN;\n            }\n          }\n        }\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = recv;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_FSEND) {\n      /* A B C  R(A) := fcall(R(A),Syms(B),R(A+1),... ,R(A+C-1)) */\n      /* not implemented yet */\n      NEXT;\n    }\n\n    CASE(OP_CALL) {\n      /* A      R(A) := self.call(frame.argc, frame.argv) */\n      mrb_callinfo *ci;\n      mrb_value recv = mrb->c->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->target_class = MRB_PROC_TARGET_CLASS(m);\n      ci->proc = m;\n      if (MRB_PROC_ENV_P(m)) {\n        mrb_sym mid;\n        struct REnv *e = MRB_PROC_ENV(m);\n\n        mid = e->mid;\n        if (mid) ci->mid = mid;\n        if (!e->stack) {\n          e->stack = mrb->c->stack;\n        }\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = mrb->c->ci;\n        mrb->c->stack = ci->stackent;\n        regs[ci->acc] = recv;\n        pc = ci->pc;\n        cipop(mrb);\n        irep = mrb->c->ci->proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->stack[0] = mrb_nil_value();\n          goto L_RETURN;\n        }\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, ci->nregs);\n        if (ci->argc < 0) {\n          if (irep->nregs > 3) {\n            stack_clear(regs+3, irep->nregs-3);\n          }\n        }\n        else if (ci->argc+2 < irep->nregs) {\n          stack_clear(regs+ci->argc+2, irep->nregs-ci->argc-2);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_SUPER) {\n      /* A C  R(A) := super(R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(ci->proc);\n\n      mrb_assert(bidx < ci->nregs);\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->tt == MRB_TT_MODULE) {\n        target_class = ci->target_class;\n        if (target_class->tt != MRB_TT_ICLASS) {\n          mrb_value exc = mrb_exc_new_str_lit(mrb, E_RUNTIME_ERROR, \"superclass info lost [mruby limitations]\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      blk = regs[bidx];\n      if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n        blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n        /* The stack or ci stack might have been reallocated during\n           mrb_convert_type(), see #3622 and #3784 */\n        regs[bidx] = blk;\n        ci = mrb->c->ci;\n      }\n      c = target_class->super;\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n\n        if (mid != missing) {\n          c = mrb_class(mrb, recv);\n        }\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (argc >= 0) {\n          if (a+2 >= ci->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(ci->mid));\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->pc = pc + 1;\n      ci->argc = argc;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n      mrb->c->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          ci->proc = MRB_METHOD_PROC(m);\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = v;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* fill callinfo */\n        ci->acc = a;\n\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_ARGARY) {\n      /* A Bx   R(A) := argument array (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb->c->ci->target_class == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_STACK_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = (int)ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      regs[a+1] = stack[m1+r+m2];\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER) {\n      /* Ax             arg setup according to flags (23=5:5:1:5:5:1:1) */\n      /* number of optional arguments times OP_JMP should follow */\n      mrb_aspec ax = GETARG_Ax(i);\n      int m1 = MRB_ASPEC_REQ(ax);\n      int o  = MRB_ASPEC_OPT(ax);\n      int r  = MRB_ASPEC_REST(ax);\n      int m2 = MRB_ASPEC_POST(ax);\n      /* unused\n      int k  = MRB_ASPEC_KEY(ax);\n      int kd = MRB_ASPEC_KDICT(ax);\n      int b  = MRB_ASPEC_BLOCK(ax);\n      */\n      int argc = mrb->c->ci->argc;\n      mrb_value *argv = regs+1;\n      mrb_value *argv0 = argv;\n      int len = m1 + o + r + m2;\n      mrb_value *blk = &argv[argc < 0 ? 1 : argc];\n\n      if (argc < 0) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n      if (mrb->c->ci->proc && MRB_PROC_STRICT_P(mrb->c->ci->proc)) {\n        if (argc >= 0) {\n          if (argc < m1 + m2 || (r == 0 && argc > len)) {\n            argnum_error(mrb, m1+m2);\n            goto L_RAISE;\n          }\n        }\n      }\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n      if (argc < len) {\n        int mlen = m2;\n        if (argc < m1+m2) {\n          if (m1 < argc)\n            mlen = argc - m1;\n          else\n            mlen = 0;\n        }\n        regs[len+1] = *blk; /* move block */\n        SET_NIL_VALUE(regs[argc+1]);\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        if (r) {\n          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);\n        }\n        if (o == 0 || argc < m1+m2) pc++;\n        else\n          pc += argc - m1 - m2 + 1;\n      }\n      else {\n        int rnum = 0;\n        if (argv0 != argv) {\n          regs[len+1] = *blk; /* move block */\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          regs[m1+o+1] = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n        }\n        if (m2) {\n          if (argc-m2 > m1) {\n            value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n          }\n        }\n        if (argv0 == argv) {\n          regs[len+1] = *blk; /* move block */\n        }\n        pc += o + 1;\n      }\n      mrb->c->ci->argc = len;\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-len-2 > 0) {\n        stack_clear(&regs[len+2], irep->nlocals-len-2);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG) {\n      /* A B C          R(A) := kdict[Syms(B)]; if C kdict.rm(Syms(B)) */\n      /* if C == 2; raise unless kdict.empty? */\n      /* OP_JMP should follow to skip init code */\n      NEXT;\n    }\n\n    CASE(OP_KDICT) {\n      /* A C            R(A) := kdict */\n      NEXT;\n    }\n\n    L_RETURN:\n      i = MKOP_AB(OP_RETURN, GETARG_A(i), OP_R_NORMAL);\n      /* fall through */\n    CASE(OP_RETURN) {\n      /* A B     return R(A) (B=normal,in-block return/break) */\n      mrb_callinfo *ci;\n\n#define ecall_adjust() do {\\\n  ptrdiff_t cioff = ci - mrb->c->cibase;\\\n  ecall(mrb);\\\n  ci = mrb->c->cibase + cioff;\\\n} while (0)\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk;\n\n        if (ci->argc < 0) {\n          blk = regs[2];\n        }\n        else {\n          blk = regs[ci->argc+1];\n        }\n        if (mrb_type(blk) == MRB_TT_PROC) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == ci[-1].env) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n        mrb_callinfo *ci0;\n\n      L_RAISE:\n        ci0 = ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          if (ci->ridx == 0) goto L_FTOP;\n          goto L_RESCUE;\n        }\n        while (ci[0].ridx == ci[-1].ridx) {\n          cipop(mrb);\n          mrb->c->stack = ci->stackent;\n          if (ci->acc == CI_ACC_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          ci = mrb->c->ci;\n          if (ci == mrb->c->cibase) {\n            if (ci->ridx == 0) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                while (c->eidx > ci->epos) {\n                  ecall_adjust();\n                }\n                if (c->fib) {\n                  mrb_write_barrier(mrb, (struct RBasic*)c->fib);\n                }\n                mrb->c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n          /* call ensure only when we skip this callinfo */\n          if (ci[0].ridx == ci[-1].ridx) {\n            while (mrb->c->eidx > ci->epos) {\n              ecall_adjust();\n            }\n          }\n        }\n      L_RESCUE:\n        if (ci->ridx == 0) goto L_STOP;\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci < ci0) {\n          mrb->c->stack = ci[1].stackent;\n        }\n        stack_extend(mrb, irep->nregs);\n        pc = mrb->c->rescue[--ci->ridx];\n      }\n      else {\n        int acc;\n        mrb_value v;\n        struct RProc *dst;\n\n        ci = mrb->c->ci;\n        v = regs[GETARG_A(i)];\n        mrb_gc_protect(mrb, v);\n        switch (GETARG_B(i)) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->acc >=0 && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            mrb_callinfo *cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_STACK_SHARED_P(e) || e->cxt != mrb->c) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->acc < 0) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) {\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            break;\n          }\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n\n            if (!mrb->c->prev) { /* toplevel return */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            if (mrb->c->prev->ci == mrb->c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_str_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            while (mrb->c->eidx > 0) {\n              ecall(mrb);\n            }\n            /* automatic yield at the end */\n            c = mrb->c;\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            c->prev = NULL;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            ci = mrb->c->ci;\n          }\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) { \n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_str_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_STACK_SHARED_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e == mrb->c->cibase->env && proc != mrb->c->cibase->proc) {\n              goto L_BREAK_ERROR;\n            }\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          while (mrb->c->eidx > mrb->c->ci->epos) {\n            ecall_adjust();\n          }\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->acc < 0) {\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n          L_BREAK:\n            v = ((struct RBreak*)mrb->exc)->val;\n            proc = ((struct RBreak*)mrb->exc)->proc;\n            mrb->exc = NULL;\n            ci = mrb->c->ci;\n          }\n          mrb->c->stack = ci->stackent;\n          proc = proc->upper;\n          while (mrb->c->cibase < ci &&  ci[-1].proc != proc) {\n            if (ci[-1].acc == CI_ACC_SKIP) {\n              while (ci < mrb->c->ci) {\n                cipop(mrb);\n              }\n              goto L_BREAK_ERROR;\n            }\n            ci--;\n          }\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        while (ci < mrb->c->ci) {\n          cipop(mrb);\n        }\n        ci[0].ridx = ci[-1].ridx;\n        while (mrb->c->eidx > ci->epos) {\n          ecall_adjust();\n        }\n        if (mrb->c->vmexec && !ci->target_class) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->acc;\n        mrb->c->stack = ci->stackent;\n        cipop(mrb);\n        if (acc == CI_ACC_SKIP || acc == CI_ACC_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        ci = mrb->c->ci;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym2name(mrb, ci->mid)));\n        proc = mrb->c->ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        regs[acc] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_TAILCALL) {\n      /* A B C  return call(R(A),Syms(B),R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int n = GETARG_C(i);\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci;\n      mrb_value recv;\n      mrb_sym mid = syms[b];\n\n      recv = regs[a];\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_value sym = mrb_symbol_value(mid);\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args;\n\n          if (n == CALL_MAXARGS) {\n            args = regs[a+1];\n          }\n          else {\n            args = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          }\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (n == CALL_MAXARGS) {\n          mrb_ary_unshift(mrb, regs[a+1], sym);\n        }\n        else {\n          value_move(regs+a+2, regs+a+1, ++n);\n          regs[a+1] = sym;\n        }\n      }\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->mid = mid;\n      ci->target_class = c;\n      if (n == CALL_MAXARGS) {\n        ci->argc = -1;\n      }\n      else {\n        ci->argc = n;\n      }\n\n      /* move stack */\n      value_move(mrb->c->stack, &regs[a], ci->argc+1);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb->c->stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n        goto L_RETURN;\n      }\n      else {\n        /* setup environment for calling method */\n        struct RProc *p = MRB_METHOD_PROC(m);\n        irep = p->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci->argc < 0) {\n          stack_extend(mrb, (irep->nregs < 3) ? 3 : irep->nregs);\n        }\n        else {\n          stack_extend(mrb, irep->nregs);\n        }\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH) {\n      /* A Bx   R(A) := block (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_STACK_SHARED_P(e) && e->mid == 0) ||\n            MRB_ENV_STACK_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2];\n      NEXT;\n    }\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH_BODY(op,v1,v2) do {\\\n  v1(regs[a]) = v1(regs[a]) op v2(regs[a+1]);\\\n} while(0)\n\n    CASE(OP_ADD) {\n      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n          mrb_value *regs_a = regs + a;\n\n          x = mrb_fixnum(regs_a[0]);\n          y = mrb_fixnum(regs_a[1]);\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):\n        regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);\n        break;\n      default:\n        goto L_SEND;\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SUB) {\n      /* A B C  R(A) := R(A)-R(A+1) (Syms[B]=:-,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_MUL) {\n      /* A B C  R(A) := R(A)*R(A+1) (Syms[B]=:*,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_mul_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_DIV) {\n      /* A B C  R(A) := R(A)/R(A+1) (Syms[B]=:/,C=1)*/\n      int a = GETARG_A(i);\n#ifndef MRB_WITHOUT_FLOAT\n      double x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n#ifdef MRB_WITHOUT_FLOAT\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_INT_VALUE(regs[a], y ? x / y : 0);\n        }\n        break;\n#else\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n\n#ifndef MRB_WITHOUT_FLOAT\n      if (y == 0) {\n        if (x > 0) f = INFINITY;\n        else if (x < 0) f = -INFINITY;\n        else /* if (x == 0) */ f = NAN;\n      }\n      else {\n        f = x / y;\n      }\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ADDI) {\n      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/\n      int a = GETARG_A(i);\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs[a])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + GETARG_C(i));\n        }\n#else\n        mrb_float(regs[a]) += GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs[a+1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SUBI) {\n      /* A B C  R(A) := R(A)-C (Syms[B]=:-)*/\n      int a = GETARG_A(i);\n      mrb_value *regs_a = regs + a;\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs_a[0])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs_a[0]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs_a[0], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - GETARG_C(i));\n        }\n#else\n        mrb_float(regs_a[0]) -= GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs_a[1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_WITHOUT_FLOAT\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ) {\n      /* A B C  R(A) := R(A)==R(A+1) (Syms[B]=:==,C=1)*/\n      int a = GETARG_A(i);\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT) {\n      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<);\n      NEXT;\n    }\n\n    CASE(OP_LE) {\n      /* A B C  R(A) := R(A)<=R(A+1) (Syms[B]=:<=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<=);\n      NEXT;\n    }\n\n    CASE(OP_GT) {\n      /* A B C  R(A) := R(A)>R(A+1) (Syms[B]=:>,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>);\n      NEXT;\n    }\n\n    CASE(OP_GE) {\n      /* A B C  R(A) := R(A)>=R(A+1) (Syms[B]=:>=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>=);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY) {\n      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT) {\n      /* A B            mrb_ary_concat(R(A),R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_value splat = mrb_ary_splat(mrb, regs[b]);\n      mrb_ary_concat(mrb, regs[a], splat);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH) {\n      /* A B            R(A).push(R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_ary_push(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_AREF) {\n      /* A B C          R(A) := R(B)[C] */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET) {\n      /* A B C          R(B)[C] := R(A) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST) {\n      /* A B C  *R(A),R(A+1)..R(A+C) := R(A) */\n      int a = GETARG_A(i);\n      mrb_value v = regs[a];\n      int pre  = GETARG_B(i);\n      int post = GETARG_C(i);\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRING) {\n      /* A Bx           R(A) := str_new(Lit(Bx)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int bx = GETARG_Bx(i);\n      mrb_value str = mrb_str_dup(mrb, pool[bx]);\n\n      regs[a] = str;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT) {\n      /* A B    R(A).concat(R(B)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int b = GETARG_B(i);\n\n      mrb_str_concat(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_HASH) {\n      /* A B C   R(A) := hash_new(R(B),R(B+1)..R(B+C)) */\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      int lim = b+c*2;\n      mrb_value hash = mrb_hash_new_capa(mrb, c);\n\n      while (b < lim) {\n        mrb_hash_set(mrb, hash, regs[b], regs[b+1]);\n        b+=2;\n      }\n      regs[GETARG_A(i)] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA) {\n      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */\n      struct RProc *p;\n      int a = GETARG_A(i);\n      int b = GETARG_b(i);\n      int c = GETARG_c(i);\n      mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS) {\n      /* A      R(A) := ::Object */\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS) {\n      /* A B    R(A) := newclass(R(A),Syms(B),R(A+1)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base, super;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE) {\n      /* A B            R(A) := newmodule(R(A),Syms(B)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC) {\n      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_callinfo *ci;\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      mrb_irep *nirep = irep->reps[bx];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      ci = cipush(mrb);\n      ci->pc = pc + 1;\n      ci->acc = a;\n      ci->mid = 0;\n      ci->stackent = mrb->c->stack;\n      ci->argc = 0;\n      ci->target_class = mrb_class_ptr(recv);\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      /* setup block to call */\n      ci->proc = p;\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      ci->nregs = irep->nregs;\n      stack_extend(mrb, ci->nregs);\n      stack_clear(regs+1, ci->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_METHOD) {\n      /* A B            R(A).newmethod(Syms(B),R(A+1)) */\n      int a = GETARG_A(i);\n      struct RClass *c = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, c, syms[GETARG_B(i)], m);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS) {\n      /* A B    R(A) := R(B).singleton_class */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n\n      regs[a] = mrb_singleton_class(mrb, regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS) {\n      /* A      R(A) := target_class */\n      if (!mrb->c->ci->target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR, \"no target class or module\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->c->ci->target_class);\n      NEXT;\n    }\n\n    CASE(OP_RANGE) {\n      /* A B C  R(A) := range_new(R(B),R(B+1),C) */\n      int b = GETARG_B(i);\n      mrb_value val = mrb_range_new(mrb, regs[b], regs[b+1], GETARG_C(i));\n      regs[GETARG_A(i)] = val;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG) {\n      /* A B C    debug print R(A),R(B),R(C) */\n#ifdef MRB_ENABLE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_DISABLE_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", GETARG_A(i), GETARG_B(i), GETARG_C(i));\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_STOP) {\n      /*        stop VM */\n    L_STOP:\n      while (mrb->c->eidx > 0) {\n        ecall(mrb);\n      }\n      ERR_PC_CLR(mrb);\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n\n    CASE(OP_ERR) {\n      /* Bx     raise RuntimeError with message Lit(Bx) */\n      mrb_value msg = mrb_str_dup(mrb, pool[GETARG_Bx(i)]);\n      mrb_value exc;\n\n      if (GETARG_A(i) == 0) {\n        exc = mrb_exc_new_str(mrb, E_RUNTIME_ERROR, msg);\n      }\n      else {\n        exc = mrb_exc_new_str(mrb, E_LOCALJUMP_ERROR, msg);\n      }\n      ERR_PC_SET(mrb, pc);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n  }\n  END_DISPATCH;\n#undef regs\n\n  }\n  MRB_CATCH(&c_jmp) {\n    exc_catched = TRUE;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}", "func_src_after": "mrb_vm_exec(mrb_state *mrb, struct RProc *proc, mrb_code *pc)\n{\n  /* mrb_assert(mrb_proc_cfunc_p(proc)) */\n  mrb_irep *irep = proc->body.irep;\n  mrb_value *pool = irep->pool;\n  mrb_sym *syms = irep->syms;\n  mrb_code i;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n\n#ifdef DIRECT_THREADED\n  static void *optable[] = {\n    &&L_OP_NOP, &&L_OP_MOVE,\n    &&L_OP_LOADL, &&L_OP_LOADI, &&L_OP_LOADSYM, &&L_OP_LOADNIL,\n    &&L_OP_LOADSELF, &&L_OP_LOADT, &&L_OP_LOADF,\n    &&L_OP_GETGLOBAL, &&L_OP_SETGLOBAL, &&L_OP_GETSPECIAL, &&L_OP_SETSPECIAL,\n    &&L_OP_GETIV, &&L_OP_SETIV, &&L_OP_GETCV, &&L_OP_SETCV,\n    &&L_OP_GETCONST, &&L_OP_SETCONST, &&L_OP_GETMCNST, &&L_OP_SETMCNST,\n    &&L_OP_GETUPVAR, &&L_OP_SETUPVAR,\n    &&L_OP_JMP, &&L_OP_JMPIF, &&L_OP_JMPNOT,\n    &&L_OP_ONERR, &&L_OP_RESCUE, &&L_OP_POPERR, &&L_OP_RAISE, &&L_OP_EPUSH, &&L_OP_EPOP,\n    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,\n    &&L_OP_CALL, &&L_OP_SUPER, &&L_OP_ARGARY, &&L_OP_ENTER,\n    &&L_OP_KARG, &&L_OP_KDICT, &&L_OP_RETURN, &&L_OP_TAILCALL, &&L_OP_BLKPUSH,\n    &&L_OP_ADD, &&L_OP_ADDI, &&L_OP_SUB, &&L_OP_SUBI, &&L_OP_MUL, &&L_OP_DIV,\n    &&L_OP_EQ, &&L_OP_LT, &&L_OP_LE, &&L_OP_GT, &&L_OP_GE,\n    &&L_OP_ARRAY, &&L_OP_ARYCAT, &&L_OP_ARYPUSH, &&L_OP_AREF, &&L_OP_ASET, &&L_OP_APOST,\n    &&L_OP_STRING, &&L_OP_STRCAT, &&L_OP_HASH,\n    &&L_OP_LAMBDA, &&L_OP_RANGE, &&L_OP_OCLASS,\n    &&L_OP_CLASS, &&L_OP_MODULE, &&L_OP_EXEC,\n    &&L_OP_METHOD, &&L_OP_SCLASS, &&L_OP_TCLASS,\n    &&L_OP_DEBUG, &&L_OP_STOP, &&L_OP_ERR,\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb->c->ci->proc = proc;\n  mrb->c->ci->nregs = irep->nregs;\n\n#define regs (mrb->c->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE) {\n      /* A B    R(A) := R(B) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL) {\n      /* A Bx   R(A) := Pool(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n#ifdef MRB_WORD_BOXING\n      mrb_value val = pool[bx];\n#ifndef MRB_WITHOUT_FLOAT\n      if (mrb_float_p(val)) {\n        val = mrb_float_value(mrb, mrb_float(val));\n      }\n#endif\n      regs[a] = val;\n#else\n      regs[a] = pool[bx];\n#endif\n      NEXT;\n    }\n\n    CASE(OP_LOADI) {\n      /* A sBx  R(A) := sBx */\n      int a = GETARG_A(i);\n      mrb_int bx = GETARG_sBx(i);\n      SET_INT_VALUE(regs[a], bx);\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM) {\n      /* A Bx   R(A) := Syms(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      SET_SYM_VALUE(regs[a], syms[bx]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF) {\n      /* A      R(A) := self */\n      int a = GETARG_A(i);\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT) {\n      /* A      R(A) := true */\n      int a = GETARG_A(i);\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF) {\n      /* A      R(A) := false */\n      int a = GETARG_A(i);\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGLOBAL) {\n      /* A Bx   R(A) := getglobal(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_gv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGLOBAL) {\n      /* A Bx   setglobal(Syms(Bx), R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_gv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSPECIAL) {\n      /* A Bx   R(A) := Special[Bx] */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_special_get(mrb, bx);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSPECIAL) {\n      /* A Bx   Special[Bx] := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_special_set(mrb, bx, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV) {\n      /* A Bx   R(A) := ivget(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_iv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETIV) {\n      /* A Bx   ivset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_iv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV) {\n      /* A Bx   R(A) := cvget(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val;\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_cv_get(mrb, syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV) {\n      /* A Bx   cvset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_cv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCONST) {\n      /* A Bx    R(A) := constget(Syms(Bx)) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_sym sym = syms[bx];\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_const_get(mrb, sym);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST) {\n      /* A Bx   constset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_const_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST) {\n      /* A Bx   R(A) := R(A)::Syms(Bx) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_const_get(mrb, regs[a], syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST) {\n      /* A Bx    R(A+1)::Syms(Bx) := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_const_set(mrb, regs[a+1], syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR) {\n      /* A B C  R(A) := uvget(B,C) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_STACK_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR) {\n      /* A B C  uvset(B,C,R(A)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_STACK_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP) {\n      /* sBx    pc+=sBx */\n      int sbx = GETARG_sBx(i);\n      pc += sbx;\n      JUMP;\n    }\n\n    CASE(OP_JMPIF) {\n      /* A sBx  if R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPNOT) {\n      /* A sBx  if !R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (!mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ONERR) {\n      /* sBx    pc+=sBx on exception */\n      int sbx = GETARG_sBx(i);\n      if (mrb->c->rsize <= mrb->c->ci->ridx) {\n        if (mrb->c->rsize == 0) mrb->c->rsize = RESCUE_STACK_INIT_SIZE;\n        else mrb->c->rsize *= 2;\n        mrb->c->rescue = (mrb_code **)mrb_realloc(mrb, mrb->c->rescue, sizeof(mrb_code*) * mrb->c->rsize);\n      }\n      mrb->c->rescue[mrb->c->ci->ridx++] = pc + sbx;\n      NEXT;\n    }\n\n    CASE(OP_RESCUE) {\n      /* A B    R(A) := exc; clear(exc); R(B) := matched (bool) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value exc;\n\n      if (c == 0) {\n        exc = mrb_obj_value(mrb->exc);\n        mrb->exc = 0;\n      }\n      else {           /* continued; exc taken from R(A) */\n        exc = regs[a];\n      }\n      if (b != 0) {\n        mrb_value e = regs[b];\n        struct RClass *ec;\n\n        switch (mrb_type(e)) {\n        case MRB_TT_CLASS:\n        case MRB_TT_MODULE:\n          break;\n        default:\n          {\n            mrb_value exc;\n\n            exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                  \"class or module required for rescue clause\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n        }\n        ec = mrb_class_ptr(e);\n        regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      }\n      if (a != 0 && c == 0) {\n        regs[a] = exc;\n      }\n      NEXT;\n    }\n\n    CASE(OP_POPERR) {\n      /* A      A.times{rescue_pop()} */\n      int a = GETARG_A(i);\n\n      mrb->c->ci->ridx -= a;\n      NEXT;\n    }\n\n    CASE(OP_RAISE) {\n      /* A      raise(R(A)) */\n      int a = GETARG_A(i);\n\n      mrb_exc_set(mrb, regs[a]);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EPUSH) {\n      /* Bx     ensure_push(SEQ[Bx]) */\n      int bx = GETARG_Bx(i);\n      struct RProc *p;\n\n      p = mrb_closure_new(mrb, irep->reps[bx]);\n      /* push ensure_stack */\n      if (mrb->c->esize <= mrb->c->eidx+1) {\n        if (mrb->c->esize == 0) mrb->c->esize = ENSURE_STACK_INIT_SIZE;\n        else mrb->c->esize *= 2;\n        mrb->c->ensure = (struct RProc **)mrb_realloc(mrb, mrb->c->ensure, sizeof(struct RProc*) * mrb->c->esize);\n      }\n      mrb->c->ensure[mrb->c->eidx++] = p;\n      mrb->c->ensure[mrb->c->eidx] = NULL;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EPOP) {\n      /* A      A.times{ensure_pop().call} */\n      int a = GETARG_A(i);\n      mrb_callinfo *ci = mrb->c->ci;\n      int n, epos = ci->epos;\n      mrb_value self = regs[0];\n      struct RClass *target_class = ci->target_class;\n\n      if (mrb->c->eidx <= epos) {\n        NEXT;\n      }\n\n      if (a > mrb->c->eidx - epos)\n        a = mrb->c->eidx - epos;\n      pc = pc + 1;\n      for (n=0; n<a; n++) {\n        proc = mrb->c->ensure[epos+n];\n        mrb->c->ensure[epos+n] = NULL;\n        if (proc == NULL) continue;\n        irep = proc->body.irep;\n        ci = cipush(mrb);\n        ci->mid = ci[-1].mid;\n        ci->argc = 0;\n        ci->proc = proc;\n        ci->stackent = mrb->c->stack;\n        ci->nregs = irep->nregs;\n        ci->target_class = target_class;\n        ci->pc = pc;\n        ci->acc = ci[-1].nregs;\n        mrb->c->stack += ci->acc;\n        stack_extend(mrb, ci->nregs);\n        regs[0] = self;\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb->c->eidx = epos;\n      JUMP;\n    }\n\n    CASE(OP_LOADNIL) {\n      /* A     R(A) := nil */\n      int a = GETARG_A(i);\n\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_SENDB) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C),&R(A+C+1))*/\n      /* fall through */\n    };\n\n  L_SEND:\n    CASE(OP_SEND) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = syms[GETARG_B(i)];\n\n      mrb_assert(bidx < ci->nregs);\n\n      recv = regs[a];\n      if (GET_OPCODE(i) != OP_SENDB) {\n        SET_NIL_VALUE(regs[bidx]);\n        blk = regs[bidx];\n      }\n      else {\n        blk = regs[bidx];\n        if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n          blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n          /* The stack might have been reallocated during mrb_convert_type(),\n             see #3622 */\n          regs[bidx] = blk;\n        }\n      }\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m) || (missing == mrb->c->ci->mid && mrb_obj_eq(mrb, regs[0], recv))) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        if (argc >= 0) {\n          if (a+2 >= irep->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));\n        mid = missing;\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->argc = argc;\n\n      ci->pc = pc + 1;\n      ci->acc = a;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          ci->proc = p;\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (GET_OPCODE(i) == OP_SENDB) {\n          if (mrb_type(blk) == MRB_TT_PROC) {\n            struct RProc *p = mrb_proc_ptr(blk);\n            if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == ci[-1].env) {\n              p->flags |= MRB_PROC_ORPHAN;\n            }\n          }\n        }\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = recv;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_FSEND) {\n      /* A B C  R(A) := fcall(R(A),Syms(B),R(A+1),... ,R(A+C-1)) */\n      /* not implemented yet */\n      NEXT;\n    }\n\n    CASE(OP_CALL) {\n      /* A      R(A) := self.call(frame.argc, frame.argv) */\n      mrb_callinfo *ci;\n      mrb_value recv = mrb->c->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->target_class = MRB_PROC_TARGET_CLASS(m);\n      ci->proc = m;\n      if (MRB_PROC_ENV_P(m)) {\n        mrb_sym mid;\n        struct REnv *e = MRB_PROC_ENV(m);\n\n        mid = e->mid;\n        if (mid) ci->mid = mid;\n        if (!e->stack) {\n          e->stack = mrb->c->stack;\n        }\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = mrb->c->ci;\n        mrb->c->stack = ci->stackent;\n        regs[ci->acc] = recv;\n        pc = ci->pc;\n        cipop(mrb);\n        irep = mrb->c->ci->proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->stack[0] = mrb_nil_value();\n          goto L_RETURN;\n        }\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, ci->nregs);\n        if (ci->argc < 0) {\n          if (irep->nregs > 3) {\n            stack_clear(regs+3, irep->nregs-3);\n          }\n        }\n        else if (ci->argc+2 < irep->nregs) {\n          stack_clear(regs+ci->argc+2, irep->nregs-ci->argc-2);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_SUPER) {\n      /* A C  R(A) := super(R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(ci->proc);\n\n      mrb_assert(bidx < ci->nregs);\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->tt == MRB_TT_MODULE) {\n        target_class = ci->target_class;\n        if (target_class->tt != MRB_TT_ICLASS) {\n          mrb_value exc = mrb_exc_new_str_lit(mrb, E_RUNTIME_ERROR, \"superclass info lost [mruby limitations]\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      blk = regs[bidx];\n      if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n        blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n        /* The stack or ci stack might have been reallocated during\n           mrb_convert_type(), see #3622 and #3784 */\n        regs[bidx] = blk;\n        ci = mrb->c->ci;\n      }\n      c = target_class->super;\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n\n        if (mid != missing) {\n          c = mrb_class(mrb, recv);\n        }\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (argc >= 0) {\n          if (a+2 >= ci->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(ci->mid));\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->pc = pc + 1;\n      ci->argc = argc;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n      mrb->c->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          ci->proc = MRB_METHOD_PROC(m);\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = v;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* fill callinfo */\n        ci->acc = a;\n\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_ARGARY) {\n      /* A Bx   R(A) := argument array (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb->c->ci->target_class == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_STACK_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = (int)ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      regs[a+1] = stack[m1+r+m2];\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER) {\n      /* Ax             arg setup according to flags (23=5:5:1:5:5:1:1) */\n      /* number of optional arguments times OP_JMP should follow */\n      mrb_aspec ax = GETARG_Ax(i);\n      int m1 = MRB_ASPEC_REQ(ax);\n      int o  = MRB_ASPEC_OPT(ax);\n      int r  = MRB_ASPEC_REST(ax);\n      int m2 = MRB_ASPEC_POST(ax);\n      /* unused\n      int k  = MRB_ASPEC_KEY(ax);\n      int kd = MRB_ASPEC_KDICT(ax);\n      int b  = MRB_ASPEC_BLOCK(ax);\n      */\n      int argc = mrb->c->ci->argc;\n      mrb_value *argv = regs+1;\n      mrb_value *argv0 = argv;\n      int len = m1 + o + r + m2;\n      mrb_value *blk = &argv[argc < 0 ? 1 : argc];\n\n      if (argc < 0) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n      if (mrb->c->ci->proc && MRB_PROC_STRICT_P(mrb->c->ci->proc)) {\n        if (argc >= 0) {\n          if (argc < m1 + m2 || (r == 0 && argc > len)) {\n            argnum_error(mrb, m1+m2);\n            goto L_RAISE;\n          }\n        }\n      }\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n      if (argc < len) {\n        int mlen = m2;\n        if (argc < m1+m2) {\n          if (m1 < argc)\n            mlen = argc - m1;\n          else\n            mlen = 0;\n        }\n        regs[len+1] = *blk; /* move block */\n        SET_NIL_VALUE(regs[argc+1]);\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        if (r) {\n          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);\n        }\n        if (o == 0 || argc < m1+m2) pc++;\n        else\n          pc += argc - m1 - m2 + 1;\n      }\n      else {\n        int rnum = 0;\n        if (argv0 != argv) {\n          regs[len+1] = *blk; /* move block */\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          regs[m1+o+1] = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n        }\n        if (m2) {\n          if (argc-m2 > m1) {\n            value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n          }\n        }\n        if (argv0 == argv) {\n          regs[len+1] = *blk; /* move block */\n        }\n        pc += o + 1;\n      }\n      mrb->c->ci->argc = len;\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-len-2 > 0) {\n        stack_clear(&regs[len+2], irep->nlocals-len-2);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG) {\n      /* A B C          R(A) := kdict[Syms(B)]; if C kdict.rm(Syms(B)) */\n      /* if C == 2; raise unless kdict.empty? */\n      /* OP_JMP should follow to skip init code */\n      NEXT;\n    }\n\n    CASE(OP_KDICT) {\n      /* A C            R(A) := kdict */\n      NEXT;\n    }\n\n    L_RETURN:\n      i = MKOP_AB(OP_RETURN, GETARG_A(i), OP_R_NORMAL);\n      /* fall through */\n    CASE(OP_RETURN) {\n      /* A B     return R(A) (B=normal,in-block return/break) */\n      mrb_callinfo *ci;\n\n#define ecall_adjust() do {\\\n  ptrdiff_t cioff = ci - mrb->c->cibase;\\\n  ecall(mrb);\\\n  ci = mrb->c->cibase + cioff;\\\n} while (0)\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk;\n\n        if (ci->argc < 0) {\n          blk = regs[2];\n        }\n        else {\n          blk = regs[ci->argc+1];\n        }\n        if (mrb_type(blk) == MRB_TT_PROC) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == ci[-1].env) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n        mrb_callinfo *ci0;\n\n      L_RAISE:\n        ci0 = ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          if (ci->ridx == 0) goto L_FTOP;\n          goto L_RESCUE;\n        }\n        while (ci[0].ridx == ci[-1].ridx) {\n          cipop(mrb);\n          mrb->c->stack = ci->stackent;\n          if (ci->acc == CI_ACC_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          ci = mrb->c->ci;\n          if (ci == mrb->c->cibase) {\n            if (ci->ridx == 0) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                while (c->eidx > ci->epos) {\n                  ecall_adjust();\n                }\n                if (c->fib) {\n                  mrb_write_barrier(mrb, (struct RBasic*)c->fib);\n                }\n                mrb->c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n          /* call ensure only when we skip this callinfo */\n          if (ci[0].ridx == ci[-1].ridx) {\n            while (mrb->c->eidx > ci->epos) {\n              ecall_adjust();\n            }\n          }\n        }\n      L_RESCUE:\n        if (ci->ridx == 0) goto L_STOP;\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci < ci0) {\n          mrb->c->stack = ci[1].stackent;\n        }\n        stack_extend(mrb, irep->nregs);\n        pc = mrb->c->rescue[--ci->ridx];\n      }\n      else {\n        int acc;\n        mrb_value v;\n        struct RProc *dst;\n\n        ci = mrb->c->ci;\n        v = regs[GETARG_A(i)];\n        mrb_gc_protect(mrb, v);\n        switch (GETARG_B(i)) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->acc >=0 && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            mrb_callinfo *cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_STACK_SHARED_P(e) || e->cxt != mrb->c) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->acc < 0) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) {\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            break;\n          }\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n\n            if (!mrb->c->prev) { /* toplevel return */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            if (mrb->c->prev->ci == mrb->c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_str_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            while (mrb->c->eidx > 0) {\n              ecall(mrb);\n            }\n            /* automatic yield at the end */\n            c = mrb->c;\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            c->prev = NULL;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            ci = mrb->c->ci;\n          }\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) { \n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_str_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_STACK_SHARED_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e == mrb->c->cibase->env && proc != mrb->c->cibase->proc) {\n              goto L_BREAK_ERROR;\n            }\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          while (mrb->c->eidx > mrb->c->ci->epos) {\n            ecall_adjust();\n          }\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->acc < 0) {\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n          L_BREAK:\n            v = ((struct RBreak*)mrb->exc)->val;\n            proc = ((struct RBreak*)mrb->exc)->proc;\n            mrb->exc = NULL;\n            ci = mrb->c->ci;\n          }\n          mrb->c->stack = ci->stackent;\n          proc = proc->upper;\n          while (mrb->c->cibase < ci &&  ci[-1].proc != proc) {\n            if (ci[-1].acc == CI_ACC_SKIP) {\n              while (ci < mrb->c->ci) {\n                cipop(mrb);\n              }\n              goto L_BREAK_ERROR;\n            }\n            ci--;\n          }\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        while (ci < mrb->c->ci) {\n          cipop(mrb);\n        }\n        ci[0].ridx = ci[-1].ridx;\n        while (mrb->c->eidx > ci->epos) {\n          ecall_adjust();\n        }\n        if (mrb->c->vmexec && !ci->target_class) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->acc;\n        mrb->c->stack = ci->stackent;\n        cipop(mrb);\n        if (acc == CI_ACC_SKIP || acc == CI_ACC_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        ci = mrb->c->ci;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym2name(mrb, ci->mid)));\n        proc = mrb->c->ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        regs[acc] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_TAILCALL) {\n      /* A B C  return call(R(A),Syms(B),R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int n = GETARG_C(i);\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci;\n      mrb_value recv;\n      mrb_sym mid = syms[b];\n\n      recv = regs[a];\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_value sym = mrb_symbol_value(mid);\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args;\n\n          if (n == CALL_MAXARGS) {\n            args = regs[a+1];\n          }\n          else {\n            args = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          }\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (n == CALL_MAXARGS) {\n          mrb_ary_unshift(mrb, regs[a+1], sym);\n        }\n        else {\n          value_move(regs+a+2, regs+a+1, ++n);\n          regs[a+1] = sym;\n        }\n      }\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->mid = mid;\n      ci->target_class = c;\n      if (n == CALL_MAXARGS) {\n        ci->argc = -1;\n      }\n      else {\n        ci->argc = n;\n      }\n\n      /* move stack */\n      value_move(mrb->c->stack, &regs[a], ci->argc+1);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb->c->stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n        goto L_RETURN;\n      }\n      else {\n        /* setup environment for calling method */\n        struct RProc *p = MRB_METHOD_PROC(m);\n        irep = p->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci->argc < 0) {\n          stack_extend(mrb, (irep->nregs < 3) ? 3 : irep->nregs);\n        }\n        else {\n          stack_extend(mrb, irep->nregs);\n        }\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH) {\n      /* A Bx   R(A) := block (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_STACK_SHARED_P(e) && e->mid == 0) ||\n            MRB_ENV_STACK_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2];\n      NEXT;\n    }\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH_BODY(op,v1,v2) do {\\\n  v1(regs[a]) = v1(regs[a]) op v2(regs[a+1]);\\\n} while(0)\n\n    CASE(OP_ADD) {\n      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n          mrb_value *regs_a = regs + a;\n\n          x = mrb_fixnum(regs_a[0]);\n          y = mrb_fixnum(regs_a[1]);\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):\n        regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);\n        break;\n      default:\n        goto L_SEND;\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SUB) {\n      /* A B C  R(A) := R(A)-R(A+1) (Syms[B]=:-,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_MUL) {\n      /* A B C  R(A) := R(A)*R(A+1) (Syms[B]=:*,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_mul_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_DIV) {\n      /* A B C  R(A) := R(A)/R(A+1) (Syms[B]=:/,C=1)*/\n      int a = GETARG_A(i);\n#ifndef MRB_WITHOUT_FLOAT\n      double x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n#ifdef MRB_WITHOUT_FLOAT\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_INT_VALUE(regs[a], y ? x / y : 0);\n        }\n        break;\n#else\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n\n#ifndef MRB_WITHOUT_FLOAT\n      if (y == 0) {\n        if (x > 0) f = INFINITY;\n        else if (x < 0) f = -INFINITY;\n        else /* if (x == 0) */ f = NAN;\n      }\n      else {\n        f = x / y;\n      }\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ADDI) {\n      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/\n      int a = GETARG_A(i);\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs[a])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + GETARG_C(i));\n        }\n#else\n        mrb_float(regs[a]) += GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs[a+1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SUBI) {\n      /* A B C  R(A) := R(A)-C (Syms[B]=:-)*/\n      int a = GETARG_A(i);\n      mrb_value *regs_a = regs + a;\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs_a[0])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs_a[0]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs_a[0], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - GETARG_C(i));\n        }\n#else\n        mrb_float(regs_a[0]) -= GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs_a[1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_WITHOUT_FLOAT\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ) {\n      /* A B C  R(A) := R(A)==R(A+1) (Syms[B]=:==,C=1)*/\n      int a = GETARG_A(i);\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT) {\n      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<);\n      NEXT;\n    }\n\n    CASE(OP_LE) {\n      /* A B C  R(A) := R(A)<=R(A+1) (Syms[B]=:<=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<=);\n      NEXT;\n    }\n\n    CASE(OP_GT) {\n      /* A B C  R(A) := R(A)>R(A+1) (Syms[B]=:>,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>);\n      NEXT;\n    }\n\n    CASE(OP_GE) {\n      /* A B C  R(A) := R(A)>=R(A+1) (Syms[B]=:>=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>=);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY) {\n      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT) {\n      /* A B            mrb_ary_concat(R(A),R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_value splat = mrb_ary_splat(mrb, regs[b]);\n      mrb_ary_concat(mrb, regs[a], splat);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH) {\n      /* A B            R(A).push(R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_ary_push(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_AREF) {\n      /* A B C          R(A) := R(B)[C] */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET) {\n      /* A B C          R(B)[C] := R(A) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST) {\n      /* A B C  *R(A),R(A+1)..R(A+C) := R(A) */\n      int a = GETARG_A(i);\n      mrb_value v = regs[a];\n      int pre  = GETARG_B(i);\n      int post = GETARG_C(i);\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRING) {\n      /* A Bx           R(A) := str_new(Lit(Bx)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int bx = GETARG_Bx(i);\n      mrb_value str = mrb_str_dup(mrb, pool[bx]);\n\n      regs[a] = str;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT) {\n      /* A B    R(A).concat(R(B)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int b = GETARG_B(i);\n\n      mrb_str_concat(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_HASH) {\n      /* A B C   R(A) := hash_new(R(B),R(B+1)..R(B+C)) */\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      int lim = b+c*2;\n      mrb_value hash = mrb_hash_new_capa(mrb, c);\n\n      while (b < lim) {\n        mrb_hash_set(mrb, hash, regs[b], regs[b+1]);\n        b+=2;\n      }\n      regs[GETARG_A(i)] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA) {\n      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */\n      struct RProc *p;\n      int a = GETARG_A(i);\n      int b = GETARG_b(i);\n      int c = GETARG_c(i);\n      mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS) {\n      /* A      R(A) := ::Object */\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS) {\n      /* A B    R(A) := newclass(R(A),Syms(B),R(A+1)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base, super;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE) {\n      /* A B            R(A) := newmodule(R(A),Syms(B)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC) {\n      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_callinfo *ci;\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      mrb_irep *nirep = irep->reps[bx];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      ci = cipush(mrb);\n      ci->pc = pc + 1;\n      ci->acc = a;\n      ci->mid = 0;\n      ci->stackent = mrb->c->stack;\n      ci->argc = 0;\n      ci->target_class = mrb_class_ptr(recv);\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      /* setup block to call */\n      ci->proc = p;\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      ci->nregs = irep->nregs;\n      stack_extend(mrb, ci->nregs);\n      stack_clear(regs+1, ci->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_METHOD) {\n      /* A B            R(A).newmethod(Syms(B),R(A+1)) */\n      int a = GETARG_A(i);\n      struct RClass *c = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, c, syms[GETARG_B(i)], m);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS) {\n      /* A B    R(A) := R(B).singleton_class */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n\n      regs[a] = mrb_singleton_class(mrb, regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS) {\n      /* A      R(A) := target_class */\n      if (!mrb->c->ci->target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR, \"no target class or module\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->c->ci->target_class);\n      NEXT;\n    }\n\n    CASE(OP_RANGE) {\n      /* A B C  R(A) := range_new(R(B),R(B+1),C) */\n      int b = GETARG_B(i);\n      mrb_value val = mrb_range_new(mrb, regs[b], regs[b+1], GETARG_C(i));\n      regs[GETARG_A(i)] = val;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG) {\n      /* A B C    debug print R(A),R(B),R(C) */\n#ifdef MRB_ENABLE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_DISABLE_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", GETARG_A(i), GETARG_B(i), GETARG_C(i));\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_STOP) {\n      /*        stop VM */\n    L_STOP:\n      while (mrb->c->eidx > 0) {\n        ecall(mrb);\n      }\n      ERR_PC_CLR(mrb);\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n\n    CASE(OP_ERR) {\n      /* Bx     raise RuntimeError with message Lit(Bx) */\n      mrb_value msg = mrb_str_dup(mrb, pool[GETARG_Bx(i)]);\n      mrb_value exc;\n\n      if (GETARG_A(i) == 0) {\n        exc = mrb_exc_new_str(mrb, E_RUNTIME_ERROR, msg);\n      }\n      else {\n        exc = mrb_exc_new_str(mrb, E_LOCALJUMP_ERROR, msg);\n      }\n      ERR_PC_SET(mrb, pc);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n  }\n  END_DISPATCH;\n#undef regs\n\n  }\n  MRB_CATCH(&c_jmp) {\n    exc_catched = TRUE;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}", "line_changes": {"deleted": [{"line_no": 244, "char_start": 6049, "char_end": 6065, "line": "      if (!e) {\n"}, {"line_no": 245, "char_start": 6065, "char_end": 6100, "line": "        *regs_a = mrb_nil_value();\n"}, {"line_no": 248, "char_start": 6121, "char_end": 6152, "line": "        *regs_a = e->stack[b];\n"}], "added": [{"line_no": 244, "char_start": 6049, "char_end": 6092, "line": "      if (e && b < MRB_ENV_STACK_LEN(e)) {\n"}, {"line_no": 245, "char_start": 6092, "char_end": 6123, "line": "        *regs_a = e->stack[b];\n"}, {"line_no": 248, "char_start": 6144, "char_end": 6179, "line": "        *regs_a = mrb_nil_value();\n"}]}, "char_changes": {"deleted": [{"char_start": 6059, "char_end": 6060, "chars": "!"}, {"char_start": 6083, "char_end": 6085, "chars": "mr"}, {"char_start": 6086, "char_end": 6098, "chars": "_nil_value()"}, {"char_start": 6139, "char_end": 6148, "chars": "e->stack["}, {"char_start": 6149, "char_end": 6150, "chars": "]"}], "added": [{"char_start": 6060, "char_end": 6088, "chars": " && b < MRB_ENV_STACK_LEN(e)"}, {"char_start": 6111, "char_end": 6121, "chars": "->stack[b]"}, {"char_start": 6162, "char_end": 6174, "chars": "mrb_nil_valu"}, {"char_start": 6175, "char_end": 6177, "chars": "()"}]}, "commit_link": "github.com/mruby/mruby/commit/1905091634a6a2925c911484434448e568330626", "file_name": "src/vm.c", "vul_type": "cwe-416"}
{"func_name": "__ns_get_path", "func_src_before": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}", "func_src_after": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 42, "char_start": 985, "char_end": 1023, "line": "\tdentry->d_flags |= DCACHE_RCUACCESS;\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 997, "char_end": 1035, "chars": "lags |= DCACHE_RCUACCESS;\n\tdentry->d_f"}]}, "commit_link": "github.com/torvalds/linux/commit/073c516ff73557a8f7315066856c04b50383ac34", "file_name": "fs/nsfs.c", "vul_type": "cwe-416"}
{"func_name": "PHP_FUNCTION", "func_src_before": "PHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n\tconst unsigned char *p;\n\tphp_unserialize_data_t var_hash;\n\tzval *options = NULL, *classes = NULL;\n\tHashTable *class_hash = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t}\n\t}\n\n\tif (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\tif (class_hash) {\n\t\t\tzend_hash_destroy(class_hash);\n\t\t\tFREE_HASHTABLE(class_hash);\n\t\t}\n\t\tzval_ptr_dtor(return_value);\n\t\tif (!EG(exception)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n\t\t\t\t(zend_long)((char*)p - buf), buf_len);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\t/* We should keep an reference to return_value to prevent it from being dtor\n\t   in case nesting calls to unserialize */\n\tvar_push_dtor(&var_hash, return_value);\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}", "func_src_after": "PHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n\tconst unsigned char *p;\n\tphp_unserialize_data_t var_hash;\n\tzval *options = NULL, *classes = NULL;\n\tzval *retval;\n\tHashTable *class_hash = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t}\n\t}\n\n\tretval = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\tif (class_hash) {\n\t\t\tzend_hash_destroy(class_hash);\n\t\t\tFREE_HASHTABLE(class_hash);\n\t\t}\n\t\tif (!EG(exception)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n\t\t\t\t(zend_long)((char*)p - buf), buf_len);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tZVAL_COPY(return_value, retval);\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}", "line_changes": {"deleted": [{"line_no": 39, "char_start": 1140, "char_end": 1226, "line": "\tif (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {\n"}, {"line_no": 45, "char_start": 1356, "char_end": 1387, "line": "\t\tzval_ptr_dtor(return_value);\n"}, {"line_no": 52, "char_start": 1563, "char_end": 1641, "line": "\t/* We should keep an reference to return_value to prevent it from being dtor\n"}, {"line_no": 53, "char_start": 1641, "char_end": 1685, "line": "\t   in case nesting calls to unserialize */\n"}, {"line_no": 54, "char_start": 1685, "char_end": 1726, "line": "\tvar_push_dtor(&var_hash, return_value);\n"}], "added": [{"line_no": 8, "char_start": 163, "char_end": 178, "line": "\tzval *retval;\n"}, {"line_no": 40, "char_start": 1155, "char_end": 1189, "line": "\tretval = var_tmp_var(&var_hash);\n"}, {"line_no": 41, "char_start": 1189, "char_end": 1269, "line": "\tif (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {\n"}, {"line_no": 53, "char_start": 1575, "char_end": 1576, "line": "\n"}, {"line_no": 54, "char_start": 1576, "char_end": 1610, "line": "\tZVAL_COPY(return_value, retval);\n"}]}, "char_changes": {"deleted": [{"char_start": 1172, "char_end": 1176, "chars": "urn_"}, {"char_start": 1179, "char_end": 1181, "chars": "ue"}, {"char_start": 1356, "char_end": 1387, "chars": "\t\tzval_ptr_dtor(return_value);\n"}, {"char_start": 1564, "char_end": 1598, "chars": "/* We should keep an reference to "}, {"char_start": 1610, "char_end": 1709, "chars": " to prevent it from being dtor\n\t   in case nesting calls to unserialize */\n\tvar_push_dtor(&var_hash"}, {"char_start": 1714, "char_end": 1718, "chars": "urn_"}, {"char_start": 1721, "char_end": 1723, "chars": "ue"}], "added": [{"char_start": 164, "char_end": 179, "chars": "zval *retval;\n\t"}, {"char_start": 1156, "char_end": 1190, "chars": "retval = var_tmp_var(&var_hash);\n\t"}, {"char_start": 1575, "char_end": 1576, "chars": "\n"}, {"char_start": 1577, "char_end": 1587, "chars": "ZVAL_COPY("}]}, "commit_link": "github.com/php/php-src/commit/b2af4e8868726a040234de113436c6e4f6372d17", "file_name": "ext/standard/var.c", "vul_type": "cwe-416"}
{"func_name": "TraceBezier", "func_src_before": "static MagickBooleanType TraceBezier(MVGInfo *mvg_info,\n  const size_t number_coordinates)\n{\n  double\n    alpha,\n    *coefficients,\n    weight;\n\n  PointInfo\n    end,\n    point,\n    *points;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  register PrimitiveInfo\n    *p;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    control_points,\n    quantum;\n\n  /*\n    Allocate coefficients.\n  */\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=number_coordinates;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n  {\n    for (j=i+1; j < (ssize_t) number_coordinates; j++)\n    {\n      alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n      alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n    }\n  }\n  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  coefficients=(double *) AcquireQuantumMemory(number_coordinates,\n    sizeof(*coefficients));\n  points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*\n    sizeof(*points));\n  if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))\n    {\n      if (points != (PointInfo *) NULL)\n        points=(PointInfo *) RelinquishMagickMemory(points);\n      if (coefficients != (double *) NULL)\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n      (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(MagickFalse);\n    }\n  control_points=quantum*number_coordinates;\n  if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  /*\n    Compute bezier points.\n  */\n  end=primitive_info[number_coordinates-1].point;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n    coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);\n  weight=0.0;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    p=primitive_info;\n    point.x=0.0;\n    point.y=0.0;\n    alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);\n    for (j=0; j < (ssize_t) number_coordinates; j++)\n    {\n      point.x+=alpha*coefficients[j]*p->point.x;\n      point.y+=alpha*coefficients[j]*p->point.y;\n      alpha*=weight/(1.0-weight);\n      p++;\n    }\n    points[i]=point;\n    weight+=1.0/control_points;\n  }\n  /*\n    Bezier curves are just short segmented polys.\n  */\n  p=primitive_info;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    if (TracePoint(p,points[i]) == MagickFalse)\n      {\n        points=(PointInfo *) RelinquishMagickMemory(points);\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n        return(MagickFalse);\n      }\n    p+=p->coordinates;\n  }\n  if (TracePoint(p,end) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  points=(PointInfo *) RelinquishMagickMemory(points);\n  coefficients=(double *) RelinquishMagickMemory(coefficients);\n  return(MagickTrue);\n}", "func_src_after": "static MagickBooleanType TraceBezier(MVGInfo *mvg_info,\n  const size_t number_coordinates)\n{\n  double\n    alpha,\n    *coefficients,\n    weight;\n\n  PointInfo\n    end,\n    point,\n    *points;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  register PrimitiveInfo\n    *p;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    control_points,\n    quantum;\n\n  /*\n    Allocate coefficients.\n  */\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=number_coordinates;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n  {\n    for (j=i+1; j < (ssize_t) number_coordinates; j++)\n    {\n      alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n      alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n    }\n  }\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n  coefficients=(double *) AcquireQuantumMemory(number_coordinates,\n    sizeof(*coefficients));\n  points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*\n    sizeof(*points));\n  if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))\n    {\n      if (points != (PointInfo *) NULL)\n        points=(PointInfo *) RelinquishMagickMemory(points);\n      if (coefficients != (double *) NULL)\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n      (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(MagickFalse);\n    }\n  control_points=quantum*number_coordinates;\n  if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  /*\n    Compute bezier points.\n  */\n  end=primitive_info[number_coordinates-1].point;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n    coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);\n  weight=0.0;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    p=primitive_info;\n    point.x=0.0;\n    point.y=0.0;\n    alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);\n    for (j=0; j < (ssize_t) number_coordinates; j++)\n    {\n      point.x+=alpha*coefficients[j]*p->point.x;\n      point.y+=alpha*coefficients[j]*p->point.y;\n      alpha*=weight/(1.0-weight);\n      p++;\n    }\n    points[i]=point;\n    weight+=1.0/control_points;\n  }\n  /*\n    Bezier curves are just short segmented polys.\n  */\n  p=primitive_info;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    if (TracePoint(p,points[i]) == MagickFalse)\n      {\n        points=(PointInfo *) RelinquishMagickMemory(points);\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n        return(MagickFalse);\n      }\n    p+=p->coordinates;\n  }\n  if (TracePoint(p,end) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  points=(PointInfo *) RelinquishMagickMemory(points);\n  coefficients=(double *) RelinquishMagickMemory(coefficients);\n  return(MagickTrue);\n}", "line_changes": {"deleted": [{"line_no": 57, "char_start": 1342, "char_end": 1405, "line": "  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n"}], "added": [{"line_no": 58, "char_start": 1405, "char_end": 1468, "line": "  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n"}, {"line_no": 80, "char_start": 2403, "char_end": 2466, "line": "  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n"}]}, "char_changes": {"deleted": [{"char_start": 1344, "char_end": 1407, "chars": "quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n  "}], "added": [{"char_start": 1344, "char_end": 1407, "chars": "primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  "}, {"char_start": 2402, "char_end": 2465, "chars": "\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;"}]}, "commit_link": "github.com/ImageMagick/ImageMagick/commit/ecf7c6b288e11e7e7f75387c5e9e93e423b98397", "file_name": "MagickCore/draw.c", "vul_type": "cwe-416"}
{"func_name": "parse_playlist", "func_src_before": "static int parse_playlist(HLSContext *c, const char *url,\n                          struct playlist *pls, AVIOContext *in)\n{\n    int ret = 0, is_segment = 0, is_variant = 0;\n    int64_t duration = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[MAX_URL_SIZE];\n    const char *ptr;\n    int close_in = 0;\n    int64_t seg_offset = 0;\n    int64_t seg_size = -1;\n    uint8_t *new_url = NULL;\n    struct variant_info variant_info;\n    char tmp_str[MAX_URL_SIZE];\n    struct segment *cur_init_section = NULL;\n\n    if (!in) {\n#if 1\n        AVDictionary *opts = NULL;\n        close_in = 1;\n        /* Some HLS servers don't like being sent the range header */\n        av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n        // broker prior HTTP options that should be consistent across requests\n        av_dict_set(&opts, \"user-agent\", c->user_agent, 0);\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n        av_dict_set(&opts, \"headers\", c->headers, 0);\n\n        ret = avio_open2(&in, url, AVIO_FLAG_READ,\n                         c->interrupt_callback, &opts);\n        av_dict_free(&opts);\n        if (ret < 0)\n            return ret;\n#else\n        ret = open_in(c, &in, url);\n        if (ret < 0)\n            return ret;\n        close_in = 1;\n#endif\n    }\n\n    if (av_opt_get(in, \"location\", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)\n        url = new_url;\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (pls) {\n        free_segment_list(pls);\n        pls->finished = 0;\n        pls->type = PLS_TYPE_UNSPECIFIED;\n    }\n    while (!avio_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            is_variant = 1;\n            memset(&variant_info, 0, sizeof(variant_info));\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &variant_info);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strcmp(info.method, \"SAMPLE-AES\"))\n                key_type = KEY_SAMPLE_AES;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-MEDIA:\", &ptr)) {\n            struct rendition_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,\n                               &info);\n            new_rendition(c, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->target_duration = atoi(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-PLAYLIST-TYPE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            if (!strcmp(ptr, \"EVENT\"))\n                pls->type = PLS_TYPE_EVENT;\n            else if (!strcmp(ptr, \"VOD\"))\n                pls->type = PLS_TYPE_VOD;\n        } else if (av_strstart(line, \"#EXT-X-MAP:\", &ptr)) {\n            struct init_section_info info = {{0}};\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,\n                               &info);\n            cur_init_section = new_init_section(pls, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (pls)\n                pls->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atof(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-BYTERANGE:\", &ptr)) {\n            seg_size = atoi(ptr);\n            ptr = strchr(ptr, '@');\n            if (ptr)\n                seg_offset = atoi(ptr+1);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, &variant_info, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!pls) {\n                    if (!new_variant(c, 0, url, NULL)) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                    pls = c->playlists[c->n_playlists - 1];\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = pls->start_seq_no + pls->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n\n                if (key_type != KEY_NONE) {\n                    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);\n                    seg->key = av_strdup(tmp_str);\n                    if (!seg->key) {\n                        av_free(seg);\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                } else {\n                    seg->key = NULL;\n                }\n\n                ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);\n                seg->url = av_strdup(tmp_str);\n                if (!seg->url) {\n                    av_free(seg->key);\n                    av_free(seg);\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n\n                dynarray_add(&pls->segments, &pls->n_segments, seg);\n                is_segment = 0;\n\n                seg->size = seg_size;\n                if (seg_size >= 0) {\n                    seg->url_offset = seg_offset;\n                    seg_offset += seg_size;\n                    seg_size = -1;\n                } else {\n                    seg->url_offset = 0;\n                    seg_offset = 0;\n                }\n\n                seg->init_section = cur_init_section;\n            }\n        }\n    }\n    if (pls)\n        pls->last_load_time = av_gettime_relative();\n\nfail:\n    av_free(new_url);\n    if (close_in)\n        avio_close(in);\n    return ret;\n}", "func_src_after": "static int parse_playlist(HLSContext *c, const char *url,\n                          struct playlist *pls, AVIOContext *in)\n{\n    int ret = 0, is_segment = 0, is_variant = 0;\n    int64_t duration = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[MAX_URL_SIZE];\n    const char *ptr;\n    int close_in = 0;\n    int64_t seg_offset = 0;\n    int64_t seg_size = -1;\n    uint8_t *new_url = NULL;\n    struct variant_info variant_info;\n    char tmp_str[MAX_URL_SIZE];\n    struct segment *cur_init_section = NULL;\n\n    if (!in) {\n#if 1\n        AVDictionary *opts = NULL;\n        close_in = 1;\n        /* Some HLS servers don't like being sent the range header */\n        av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n        // broker prior HTTP options that should be consistent across requests\n        av_dict_set(&opts, \"user-agent\", c->user_agent, 0);\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n        av_dict_set(&opts, \"headers\", c->headers, 0);\n\n        ret = avio_open2(&in, url, AVIO_FLAG_READ,\n                         c->interrupt_callback, &opts);\n        av_dict_free(&opts);\n        if (ret < 0)\n            return ret;\n#else\n        ret = open_in(c, &in, url);\n        if (ret < 0)\n            return ret;\n        close_in = 1;\n#endif\n    }\n\n    if (av_opt_get(in, \"location\", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)\n        url = new_url;\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (pls) {\n        free_segment_list(pls);\n        pls->finished = 0;\n        pls->type = PLS_TYPE_UNSPECIFIED;\n    }\n    while (!avio_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            is_variant = 1;\n            memset(&variant_info, 0, sizeof(variant_info));\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &variant_info);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strcmp(info.method, \"SAMPLE-AES\"))\n                key_type = KEY_SAMPLE_AES;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-MEDIA:\", &ptr)) {\n            struct rendition_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,\n                               &info);\n            new_rendition(c, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->target_duration = atoi(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-PLAYLIST-TYPE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            if (!strcmp(ptr, \"EVENT\"))\n                pls->type = PLS_TYPE_EVENT;\n            else if (!strcmp(ptr, \"VOD\"))\n                pls->type = PLS_TYPE_VOD;\n        } else if (av_strstart(line, \"#EXT-X-MAP:\", &ptr)) {\n            struct init_section_info info = {{0}};\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,\n                               &info);\n            cur_init_section = new_init_section(pls, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (pls)\n                pls->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atof(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-BYTERANGE:\", &ptr)) {\n            seg_size = atoi(ptr);\n            ptr = strchr(ptr, '@');\n            if (ptr)\n                seg_offset = atoi(ptr+1);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, &variant_info, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!pls) {\n                    if (!new_variant(c, 0, url, NULL)) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                    pls = c->playlists[c->n_playlists - 1];\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = pls->start_seq_no + pls->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n\n                if (key_type != KEY_NONE) {\n                    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);\n                    seg->key = av_strdup(tmp_str);\n                    if (!seg->key) {\n                        av_free(seg);\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                } else {\n                    seg->key = NULL;\n                }\n\n                ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);\n                seg->url = av_strdup(tmp_str);\n                if (!seg->url) {\n                    av_free(seg->key);\n                    av_free(seg);\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n\n                if (duration < 0.001 * AV_TIME_BASE) {\n                    duration = 0.001 * AV_TIME_BASE;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                dynarray_add(&pls->segments, &pls->n_segments, seg);\n                is_segment = 0;\n\n                seg->size = seg_size;\n                if (seg_size >= 0) {\n                    seg->url_offset = seg_offset;\n                    seg_offset += seg_size;\n                    seg_size = -1;\n                } else {\n                    seg->url_offset = 0;\n                    seg_offset = 0;\n                }\n\n                seg->init_section = cur_init_section;\n            }\n        }\n    }\n    if (pls)\n        pls->last_load_time = av_gettime_relative();\n\nfail:\n    av_free(new_url);\n    if (close_in)\n        avio_close(in);\n    return ret;\n}", "line_changes": {"deleted": [{"line_no": 147, "char_start": 5497, "char_end": 5539, "line": "                seg->duration = duration;\n"}, {"line_no": 148, "char_start": 5539, "char_end": 5581, "line": "                seg->key_type = key_type;\n"}], "added": [{"line_no": 176, "char_start": 6550, "char_end": 6605, "line": "                if (duration < 0.001 * AV_TIME_BASE) {\n"}, {"line_no": 177, "char_start": 6605, "char_end": 6658, "line": "                    duration = 0.001 * AV_TIME_BASE;\n"}, {"line_no": 178, "char_start": 6658, "char_end": 6676, "line": "                }\n"}, {"line_no": 179, "char_start": 6676, "char_end": 6718, "line": "                seg->duration = duration;\n"}, {"line_no": 180, "char_start": 6718, "char_end": 6760, "line": "                seg->key_type = key_type;\n"}]}, "char_changes": {"deleted": [{"char_start": 5513, "char_end": 5597, "chars": "seg->duration = duration;\n                seg->key_type = key_type;\n                "}], "added": [{"char_start": 6549, "char_end": 6759, "chars": "\n                if (duration < 0.001 * AV_TIME_BASE) {\n                    duration = 0.001 * AV_TIME_BASE;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;"}]}, "commit_link": "github.com/FFmpeg/FFmpeg/commit/6959358683c7533f586c07a766acc5fe9544d8b2", "file_name": "libavformat/hls.c", "vul_type": "cwe-416"}
{"func_name": "get_net_ns_by_id", "func_src_before": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\n\tif (id < 0)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tget_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\n\treturn peer;\n}", "func_src_after": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\n\tif (id < 0)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tpeer = maybe_get_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\n\treturn peer;\n}", "line_changes": {"deleted": [{"line_no": 12, "char_start": 205, "char_end": 222, "line": "\t\tget_net(peer);\n"}], "added": [{"line_no": 12, "char_start": 205, "char_end": 235, "line": "\t\tpeer = maybe_get_net(peer);\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 207, "char_end": 220, "chars": "peer = maybe_"}]}, "commit_link": "github.com/torvalds/linux/commit/21b5944350052d2583e82dd59b19a9ba94a007f0", "file_name": "net/core/net_namespace.c", "vul_type": "cwe-416"}
{"func_name": "usb_audio_probe", "func_src_before": "static int usb_audio_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *usb_id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tconst struct snd_usb_audio_quirk *quirk =\n\t\t(const struct snd_usb_audio_quirk *)usb_id->driver_info;\n\tstruct snd_usb_audio *chip;\n\tint i, err;\n\tstruct usb_host_interface *alts;\n\tint ifnum;\n\tu32 id;\n\n\talts = &intf->altsetting[0];\n\tifnum = get_iface_desc(alts)->bInterfaceNumber;\n\tid = USB_ID(le16_to_cpu(dev->descriptor.idVendor),\n\t\t    le16_to_cpu(dev->descriptor.idProduct));\n\tif (get_alias_id(dev, &id))\n\t\tquirk = get_alias_quirk(dev, id);\n\tif (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)\n\t\treturn -ENXIO;\n\n\terr = snd_usb_apply_boot_quirk(dev, intf, quirk, id);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * found a config.  now register to ALSA\n\t */\n\n\t/* check whether it's already registered */\n\tchip = NULL;\n\tmutex_lock(&register_mutex);\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (usb_chip[i] && usb_chip[i]->dev == dev) {\n\t\t\tif (atomic_read(&usb_chip[i]->shutdown)) {\n\t\t\t\tdev_err(&dev->dev, \"USB device is in the shutdown state, cannot create a card instance\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip = usb_chip[i];\n\t\t\tatomic_inc(&chip->active); /* avoid autopm */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (! chip) {\n\t\t/* it's a fresh one.\n\t\t * now look for an empty slot and create a new card instance\n\t\t */\n\t\tfor (i = 0; i < SNDRV_CARDS; i++)\n\t\t\tif (!usb_chip[i] &&\n\t\t\t    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&\n\t\t\t    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {\n\t\t\t\tif (enable[i]) {\n\t\t\t\t\terr = snd_usb_audio_create(intf, dev, i, quirk,\n\t\t\t\t\t\t\t\t   id, &chip);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\tgoto __error;\n\t\t\t\t\tchip->pm_intf = intf;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (vid[i] != -1 || pid[i] != -1) {\n\t\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t\t \"device (%04x:%04x) is disabled\\n\",\n\t\t\t\t\t\t USB_ID_VENDOR(id),\n\t\t\t\t\t\t USB_ID_PRODUCT(id));\n\t\t\t\t\terr = -ENOENT;\n\t\t\t\t\tgoto __error;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!chip) {\n\t\t\tdev_err(&dev->dev, \"no available usb audio device\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto __error;\n\t\t}\n\t}\n\tdev_set_drvdata(&dev->dev, chip);\n\n\t/*\n\t * For devices with more than one control interface, we assume the\n\t * first contains the audio controls. We might need a more specific\n\t * check here in the future.\n\t */\n\tif (!chip->ctrl_intf)\n\t\tchip->ctrl_intf = alts;\n\n\tchip->txfr_quirk = 0;\n\terr = 1; /* continue */\n\tif (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {\n\t\t/* need some special handlings */\n\t\terr = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tif (err > 0) {\n\t\t/* create normal USB audio interfaces */\n\t\terr = snd_usb_create_streams(chip, ifnum);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\terr = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\t/* we are allowed to call snd_card_register() many times */\n\terr = snd_card_register(chip->card);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tusb_chip[chip->index] = chip;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\tif (chip) {\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t\tatomic_dec(&chip->active);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}", "func_src_after": "static int usb_audio_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *usb_id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tconst struct snd_usb_audio_quirk *quirk =\n\t\t(const struct snd_usb_audio_quirk *)usb_id->driver_info;\n\tstruct snd_usb_audio *chip;\n\tint i, err;\n\tstruct usb_host_interface *alts;\n\tint ifnum;\n\tu32 id;\n\n\talts = &intf->altsetting[0];\n\tifnum = get_iface_desc(alts)->bInterfaceNumber;\n\tid = USB_ID(le16_to_cpu(dev->descriptor.idVendor),\n\t\t    le16_to_cpu(dev->descriptor.idProduct));\n\tif (get_alias_id(dev, &id))\n\t\tquirk = get_alias_quirk(dev, id);\n\tif (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)\n\t\treturn -ENXIO;\n\n\terr = snd_usb_apply_boot_quirk(dev, intf, quirk, id);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * found a config.  now register to ALSA\n\t */\n\n\t/* check whether it's already registered */\n\tchip = NULL;\n\tmutex_lock(&register_mutex);\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (usb_chip[i] && usb_chip[i]->dev == dev) {\n\t\t\tif (atomic_read(&usb_chip[i]->shutdown)) {\n\t\t\t\tdev_err(&dev->dev, \"USB device is in the shutdown state, cannot create a card instance\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip = usb_chip[i];\n\t\t\tatomic_inc(&chip->active); /* avoid autopm */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (! chip) {\n\t\t/* it's a fresh one.\n\t\t * now look for an empty slot and create a new card instance\n\t\t */\n\t\tfor (i = 0; i < SNDRV_CARDS; i++)\n\t\t\tif (!usb_chip[i] &&\n\t\t\t    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&\n\t\t\t    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {\n\t\t\t\tif (enable[i]) {\n\t\t\t\t\terr = snd_usb_audio_create(intf, dev, i, quirk,\n\t\t\t\t\t\t\t\t   id, &chip);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\tgoto __error;\n\t\t\t\t\tchip->pm_intf = intf;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (vid[i] != -1 || pid[i] != -1) {\n\t\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t\t \"device (%04x:%04x) is disabled\\n\",\n\t\t\t\t\t\t USB_ID_VENDOR(id),\n\t\t\t\t\t\t USB_ID_PRODUCT(id));\n\t\t\t\t\terr = -ENOENT;\n\t\t\t\t\tgoto __error;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!chip) {\n\t\t\tdev_err(&dev->dev, \"no available usb audio device\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto __error;\n\t\t}\n\t}\n\tdev_set_drvdata(&dev->dev, chip);\n\n\t/*\n\t * For devices with more than one control interface, we assume the\n\t * first contains the audio controls. We might need a more specific\n\t * check here in the future.\n\t */\n\tif (!chip->ctrl_intf)\n\t\tchip->ctrl_intf = alts;\n\n\tchip->txfr_quirk = 0;\n\terr = 1; /* continue */\n\tif (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {\n\t\t/* need some special handlings */\n\t\terr = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tif (err > 0) {\n\t\t/* create normal USB audio interfaces */\n\t\terr = snd_usb_create_streams(chip, ifnum);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\terr = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\t/* we are allowed to call snd_card_register() many times */\n\terr = snd_card_register(chip->card);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tusb_chip[chip->index] = chip;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\tif (chip) {\n\t\t/* chip->active is inside the chip->card object,\n\t\t * decrement before memory is possibly returned.\n\t\t */\n\t\tatomic_dec(&chip->active);\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}", "line_changes": {"deleted": [{"line_no": 120, "char_start": 3144, "char_end": 3173, "line": "\t\tatomic_dec(&chip->active);\n"}], "added": [{"line_no": 118, "char_start": 3085, "char_end": 3136, "line": "\t\t/* chip->active is inside the chip->card object,\n"}, {"line_no": 119, "char_start": 3136, "char_end": 3187, "line": "\t\t * decrement before memory is possibly returned.\n"}, {"line_no": 120, "char_start": 3187, "char_end": 3193, "line": "\t\t */\n"}, {"line_no": 121, "char_start": 3193, "char_end": 3222, "line": "\t\tatomic_dec(&chip->active);\n"}]}, "char_changes": {"deleted": [{"char_start": 3087, "char_end": 3089, "chars": "if"}, {"char_start": 3090, "char_end": 3092, "chars": "(!"}, {"char_start": 3098, "char_end": 3102, "chars": "num_"}, {"char_start": 3107, "char_end": 3109, "chars": "fa"}, {"char_start": 3110, "char_end": 3113, "chars": "es)"}, {"char_start": 3116, "char_end": 3119, "chars": "\tsn"}, {"char_start": 3120, "char_end": 3121, "chars": "_"}, {"char_start": 3122, "char_end": 3123, "chars": "a"}, {"char_start": 3124, "char_end": 3126, "chars": "d_"}, {"char_start": 3130, "char_end": 3133, "chars": "(ch"}, {"char_start": 3135, "char_end": 3139, "chars": "->ca"}, {"char_start": 3141, "char_end": 3143, "chars": ");"}], "added": [{"char_start": 3087, "char_end": 3224, "chars": "/* chip->active is inside the chip->card object,\n\t\t * decrement before memory is possibly returned.\n\t\t */\n\t\tatomic_dec(&chip->active);\n\t\t"}]}, "commit_link": "github.com/torvalds/linux/commit/5f8cf712582617d523120df67d392059eaf2fc4b", "file_name": "sound/usb/card.c", "vul_type": "cwe-416"}
{"func_name": "audio_sample_entry_Read", "func_src_before": "GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->is_qtff = 1;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->is_qtff = 0;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs)) {\n \t\tptr->is_qtff |= 1<<16;\n \t}\n\n\te = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);\n\tif (!e) return GF_OK;\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\tif (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\n\t\t\tif (e==GF_OK) {\n\t\t\t\tgf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);\n\t\t\t} else if (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\tgf_bs_del(mybs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}", "func_src_after": "GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->is_qtff = 1;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->is_qtff = 0;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs)) {\n \t\tptr->is_qtff |= 1<<16;\n \t}\n\n\te = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);\n\tif (!e) return GF_OK;\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\textern Bool use_dump_mode;\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\tif (ptr->esd) {\n\t\t\t\tif (!use_dump_mode) gf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\n\t\t\tif (e==GF_OK) {\n\t\t\t\tgf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);\n\t\t\t} else if (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\tgf_bs_del(mybs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}", "line_changes": {"deleted": [{"line_no": 58, "char_start": 1827, "char_end": 1868, "line": "\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n"}], "added": [{"line_no": 56, "char_start": 1734, "char_end": 1764, "line": "\t\t\textern Bool use_dump_mode;\n"}, {"line_no": 59, "char_start": 1857, "char_end": 1918, "line": "\t\t\t\tif (!use_dump_mode) gf_isom_box_del((GF_Box *)ptr->esd);\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1737, "char_end": 1767, "chars": "extern Bool use_dump_mode;\n\t\t\t"}, {"char_start": 1861, "char_end": 1881, "chars": "if (!use_dump_mode) "}]}, "commit_link": "github.com/gpac/gpac/commit/6063b1a011c3f80cee25daade18154e15e4c058c", "file_name": "src/isomedia/box_code_base.c", "vul_type": "cwe-416"}
{"func_name": "ffs_user_copy_worker", "func_src_before": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\n\tif (io_data->ffs->ffs_eventfd &&\n\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\n\tio_data->kiocb->private = NULL;\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}", "func_src_after": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\tbool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;\n\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\n\tif (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}", "line_changes": {"deleted": [{"line_no": 18, "char_start": 488, "char_end": 522, "line": "\tif (io_data->ffs->ffs_eventfd &&\n"}, {"line_no": 19, "char_start": 522, "char_end": 571, "line": "\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n"}, {"line_no": 24, "char_start": 670, "char_end": 703, "line": "\tio_data->kiocb->private = NULL;\n"}], "added": [{"line_no": 7, "char_start": 232, "char_end": 299, "line": "\tbool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;\n"}, {"line_no": 19, "char_start": 555, "char_end": 609, "line": "\tif (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)\n"}]}, "char_changes": {"deleted": [{"char_start": 521, "char_end": 526, "chars": "\n\t   "}, {"char_start": 528, "char_end": 538, "chars": "(io_data->"}, {"char_start": 543, "char_end": 547, "chars": "->ki"}, {"char_start": 548, "char_end": 550, "chars": "fl"}, {"char_start": 551, "char_end": 552, "chars": "g"}, {"char_start": 553, "char_end": 560, "chars": " & IOCB"}, {"char_start": 561, "char_end": 569, "chars": "EVENTFD)"}, {"char_start": 669, "char_end": 702, "chars": "\n\tio_data->kiocb->private = NULL;"}], "added": [{"char_start": 232, "char_end": 299, "chars": "\tbool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;\n"}, {"char_start": 596, "char_end": 597, "chars": "h"}, {"char_start": 600, "char_end": 607, "chars": "eventfd"}]}, "commit_link": "github.com/torvalds/linux/commit/38740a5b87d53ceb89eb2c970150f6e94e00373a", "file_name": "drivers/usb/gadget/function/f_fs.c", "vul_type": "cwe-416"}
{"func_name": "ndpi_reset_packet_line_info", "func_src_before": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "func_src_after": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->content_disposition_line.ptr = NULL,\n    packet->content_disposition_line.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "line_changes": {"deleted": [{"line_no": 8, "char_start": 688, "char_end": 793, "line": "    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n"}], "added": [{"line_no": 8, "char_start": 688, "char_end": 806, "line": "    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->content_disposition_line.ptr = NULL,\n"}, {"line_no": 9, "char_start": 806, "char_end": 884, "line": "    packet->content_disposition_line.len = 0, packet->http_cookie.ptr = NULL,\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 769, "char_end": 860, "chars": "content_disposition_line.ptr = NULL,\n    packet->content_disposition_line.len = 0, packet->"}]}, "commit_link": "github.com/ntop/nDPI/commit/6a9f5e4f7c3fd5ddab3e6727b071904d76773952", "file_name": "src/lib/ndpi_main.c", "vul_type": "cwe-416"}
{"func_name": "snd_seq_device_dev_free", "func_src_before": "static int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tput_device(&dev->dev);\n\treturn 0;\n}", "func_src_after": "static int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tcancel_autoload_drivers();\n\tput_device(&dev->dev);\n\treturn 0;\n}", "line_changes": {"deleted": [], "added": [{"line_no": 5, "char_start": 116, "char_end": 144, "line": "\tcancel_autoload_drivers();\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 117, "char_end": 145, "chars": "cancel_autoload_drivers();\n\t"}]}, "commit_link": "github.com/torvalds/linux/commit/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57", "file_name": "sound/core/seq_device.c", "vul_type": "cwe-416"}
{"func_name": "__mdiobus_register", "func_src_before": "int __mdiobus_register(struct mii_bus *bus, struct module *owner)\n{\n\tstruct mdio_device *mdiodev;\n\tint i, err;\n\tstruct gpio_desc *gpiod;\n\n\tif (NULL == bus || NULL == bus->name ||\n\t    NULL == bus->read || NULL == bus->write)\n\t\treturn -EINVAL;\n\n\tBUG_ON(bus->state != MDIOBUS_ALLOCATED &&\n\t       bus->state != MDIOBUS_UNREGISTERED);\n\n\tbus->owner = owner;\n\tbus->dev.parent = bus->parent;\n\tbus->dev.class = &mdio_bus_class;\n\tbus->dev.groups = NULL;\n\tdev_set_name(&bus->dev, \"%s\", bus->id);\n\n\terr = device_register(&bus->dev);\n\tif (err) {\n\t\tpr_err(\"mii_bus %s failed to register\\n\", bus->id);\n\t\tput_device(&bus->dev);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&bus->mdio_lock);\n\n\t/* de-assert bus level PHY GPIO reset */\n\tgpiod = devm_gpiod_get_optional(&bus->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiod)) {\n\t\tdev_err(&bus->dev, \"mii_bus %s couldn't get reset GPIO\\n\",\n\t\t\tbus->id);\n\t\tdevice_del(&bus->dev);\n\t\treturn PTR_ERR(gpiod);\n\t} else\tif (gpiod) {\n\t\tbus->reset_gpiod = gpiod;\n\n\t\tgpiod_set_value_cansleep(gpiod, 1);\n\t\tudelay(bus->reset_delay_us);\n\t\tgpiod_set_value_cansleep(gpiod, 0);\n\t}\n\n\tif (bus->reset)\n\t\tbus->reset(bus);\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tif ((bus->phy_mask & (1 << i)) == 0) {\n\t\t\tstruct phy_device *phydev;\n\n\t\t\tphydev = mdiobus_scan(bus, i);\n\t\t\tif (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {\n\t\t\t\terr = PTR_ERR(phydev);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tmdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);\n\n\tbus->state = MDIOBUS_REGISTERED;\n\tpr_info(\"%s: probed\\n\", bus->name);\n\treturn 0;\n\nerror:\n\twhile (--i >= 0) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\n\n\t/* Put PHYs in RESET to save power */\n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\n\tdevice_del(&bus->dev);\n\treturn err;\n}", "func_src_after": "int __mdiobus_register(struct mii_bus *bus, struct module *owner)\n{\n\tstruct mdio_device *mdiodev;\n\tint i, err;\n\tstruct gpio_desc *gpiod;\n\n\tif (NULL == bus || NULL == bus->name ||\n\t    NULL == bus->read || NULL == bus->write)\n\t\treturn -EINVAL;\n\n\tBUG_ON(bus->state != MDIOBUS_ALLOCATED &&\n\t       bus->state != MDIOBUS_UNREGISTERED);\n\n\tbus->owner = owner;\n\tbus->dev.parent = bus->parent;\n\tbus->dev.class = &mdio_bus_class;\n\tbus->dev.groups = NULL;\n\tdev_set_name(&bus->dev, \"%s\", bus->id);\n\n\terr = device_register(&bus->dev);\n\tif (err) {\n\t\tpr_err(\"mii_bus %s failed to register\\n\", bus->id);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&bus->mdio_lock);\n\n\t/* de-assert bus level PHY GPIO reset */\n\tgpiod = devm_gpiod_get_optional(&bus->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiod)) {\n\t\tdev_err(&bus->dev, \"mii_bus %s couldn't get reset GPIO\\n\",\n\t\t\tbus->id);\n\t\tdevice_del(&bus->dev);\n\t\treturn PTR_ERR(gpiod);\n\t} else\tif (gpiod) {\n\t\tbus->reset_gpiod = gpiod;\n\n\t\tgpiod_set_value_cansleep(gpiod, 1);\n\t\tudelay(bus->reset_delay_us);\n\t\tgpiod_set_value_cansleep(gpiod, 0);\n\t}\n\n\tif (bus->reset)\n\t\tbus->reset(bus);\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tif ((bus->phy_mask & (1 << i)) == 0) {\n\t\t\tstruct phy_device *phydev;\n\n\t\t\tphydev = mdiobus_scan(bus, i);\n\t\t\tif (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {\n\t\t\t\terr = PTR_ERR(phydev);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tmdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);\n\n\tbus->state = MDIOBUS_REGISTERED;\n\tpr_info(\"%s: probed\\n\", bus->name);\n\treturn 0;\n\nerror:\n\twhile (--i >= 0) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\n\n\t/* Put PHYs in RESET to save power */\n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\n\tdevice_del(&bus->dev);\n\treturn err;\n}", "line_changes": {"deleted": [{"line_no": 23, "char_start": 589, "char_end": 614, "line": "\t\tput_device(&bus->dev);\n"}], "added": []}, "char_changes": {"deleted": [{"char_start": 591, "char_end": 616, "chars": "put_device(&bus->dev);\n\t\t"}], "added": []}, "commit_link": "github.com/torvalds/linux/commit/6ff7b060535e87c2ae14dd8548512abfdda528fb", "file_name": "drivers/net/phy/mdio_bus.c", "vul_type": "cwe-416"}
{"func_name": "mrb_io_initialize_copy", "func_src_before": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n  mrb_bool failed = TRUE;\n\n  mrb_get_args(mrb, \"o\", &orig);\n  fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n  if (fptr_copy != NULL) {\n    fptr_finalize(mrb, fptr_copy, FALSE);\n    mrb_free(mrb, fptr_copy);\n  }\n  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n\n  DATA_TYPE(copy) = &mrb_io_type;\n  DATA_PTR(copy) = fptr_copy;\n\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n\n  return copy;\n}", "func_src_after": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n  mrb_bool failed = TRUE;\n\n  mrb_get_args(mrb, \"o\", &orig);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n  fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n  if (fptr_copy != NULL) {\n    fptr_finalize(mrb, fptr_copy, FALSE);\n    mrb_free(mrb, fptr_copy);\n  }\n  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n\n  DATA_TYPE(copy) = &mrb_io_type;\n  DATA_PTR(copy) = fptr_copy;\n\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n\n  return copy;\n}", "line_changes": {"deleted": [{"line_no": 16, "char_start": 408, "char_end": 451, "line": "  fptr_orig = io_get_open_fptr(mrb, orig);\n"}], "added": [{"line_no": 10, "char_start": 208, "char_end": 251, "line": "  fptr_orig = io_get_open_fptr(mrb, orig);\n"}]}, "char_changes": {"deleted": [{"char_start": 405, "char_end": 448, "chars": ");\n  fptr_orig = io_get_open_fptr(mrb, orig"}], "added": [{"char_start": 215, "char_end": 258, "chars": "orig = io_get_open_fptr(mrb, orig);\n  fptr_"}]}, "commit_link": "github.com/mruby/mruby/commit/b51b21fc63c9805862322551387d9036f2b63433", "file_name": "mrbgems/mruby-io/src/io.c", "vul_type": "cwe-416"}
{"func_name": "SMB2_write", "func_src_before": "SMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tstruct smb_rqst rqst;\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\tstruct kvec rsp_iov;\n\tint flags = 0;\n\tunsigned int total_len;\n\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\trc = smb2_plain_req_init(SMB2_WRITE, io_parms->tcon, (void **) &req,\n\t\t\t     &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->sync_hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer));\n\treq->RemainingBytes = 0;\n\n\ttrace_smb3_write_enter(xid, io_parms->persistent_fid,\n\t\tio_parms->tcon->tid, io_parms->tcon->ses->Suid,\n\t\tio_parms->offset, io_parms->length);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 1 for Buffer */\n\tiov[0].iov_len = total_len - 1;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = n_vec + 1;\n\n\trc = cifs_send_recv(xid, io_parms->tcon->ses, &rqst,\n\t\t\t    &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_write_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\ttrace_smb3_write_err(xid, req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset, io_parms->length, rc);\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\ttrace_smb3_write_done(xid, req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset, *nbytes);\n\t}\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}", "func_src_after": "SMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tstruct smb_rqst rqst;\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\tstruct kvec rsp_iov;\n\tint flags = 0;\n\tunsigned int total_len;\n\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\trc = smb2_plain_req_init(SMB2_WRITE, io_parms->tcon, (void **) &req,\n\t\t\t     &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->sync_hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer));\n\treq->RemainingBytes = 0;\n\n\ttrace_smb3_write_enter(xid, io_parms->persistent_fid,\n\t\tio_parms->tcon->tid, io_parms->tcon->ses->Suid,\n\t\tio_parms->offset, io_parms->length);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 1 for Buffer */\n\tiov[0].iov_len = total_len - 1;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = n_vec + 1;\n\n\trc = cifs_send_recv(xid, io_parms->tcon->ses, &rqst,\n\t\t\t    &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_write_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\ttrace_smb3_write_err(xid, req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset, io_parms->length, rc);\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\ttrace_smb3_write_done(xid, req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset, *nbytes);\n\t}\n\n\tcifs_small_buf_release(req);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}", "line_changes": {"deleted": [{"line_no": 56, "char_start": 1475, "char_end": 1505, "line": "\tcifs_small_buf_release(req);\n"}], "added": [{"line_no": 73, "char_start": 2020, "char_end": 2050, "line": "\tcifs_small_buf_release(req);\n"}]}, "char_changes": {"deleted": [{"char_start": 1476, "char_end": 1506, "chars": "cifs_small_buf_release(req);\n\t"}], "added": [{"char_start": 2019, "char_end": 2049, "chars": "\n\tcifs_small_buf_release(req);"}]}, "commit_link": "github.com/torvalds/linux/commit/6a3eb3360667170988f8a6477f6686242061488a", "file_name": "fs/cifs/smb2pdu.c", "vul_type": "cwe-416"}
